{"version":3,"sources":["webpack:///test/dist/jsmocktool.test.js","webpack:///webpack/bootstrap 883e94e3087ca5498049","webpack:///./src/global.js","webpack:///./src/testDouble.js","webpack:///./src/jsmocktool.js","webpack:///./src/mock/jsmock.js","webpack:///./src/mock/jsmockMethod.js","webpack:///./src/mock/jsmockMethodFactory.js","webpack:///./src/stub/jsstub.js","webpack:///./src/stub/jsstubMethod.js","webpack:///./~/qunitjs/qunit/qunit.js","webpack:///./test/jsmock.js","webpack:///./test/jsstub.js","webpack:///./test/start.js","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Math","self","Function","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","undefined","_typeof","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_global","_global2","TestDouble","name","type","this","createTestDouble","returnValue","testDoubleType","makeEnableObj","Error","testDoubleObj","depth","split","objectName","splice","forEach","v","returnObj","mock","stub","_jsstub","_jsstub2","_jsmock","_jsmock2","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","mockWrap","Mock","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","next","done","push","err","Array","isArray","_jsmockMethodFactory","_jsmockMethodFactory2","_testDouble","_testDouble2","_TestDouble","arguments","_this","getPrototypeOf","methodName","getMethod","getTestDouble","methodInfo","getData","get","record","total","_this2","verify","param","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_step$value","OBJECT","INSTANCE","anything","MockMethod","excuteObjs","Map","currentParam","transformParamToString","set","setup","JSON","stringify","that","_len","params","_key","argString","dataObj","excute","apply","info","arg","find","_len2","_key2","returnVal","and_template","returnFunction","returnException","_jsmockMethod","_jsmockMethod2","storage","createData","createMethod","data","methodObj","warn","msg","console","stubWrap","Stub","_jsstubMethod","_jsstubMethod2","functionName","StubMethod","__WEBPACK_AMD_DEFINE_RESULT__","process","global","diff","a","b","j","result","slice","inArray","elem","array","indexOf","objectValues","val","vals","QUnit","is","hasOwn","extend","undefOnly","prop","objectType","match","toString","isNaN","toLowerCase","extractStacktrace","e","offset","stack","include","test","shift","fileName","join","sourceFromStacktrace","error","registerLoggingCallbacks","registerLoggingCallback","loggingCallback","callback","config","callbacks","l","callbackNames","runLoggingCallbacks","args","begin","modulesLog","started","now","tests","totalTests","Test","count","blocking","last","start","queue","defined","setTimeout","updateRate","current","usedAsync","pauseProcessing","testTimeout","clearTimeout","timeout","semaphore","pushFailure","resumeProcessing","runStarted","runtime","passed","autorun","previousModule","failed","moduleStats","bad","all","stats","setHook","hookName","testEnvironment","settings","expected","assertions","currentModule","testName","testId","generateHash","skip","async","assert","Assert","internalReset","fixture","document","getElementById","innerHTML","hex","hash","str","len","charCodeAt","synchronize","priority","seed","index","priorityCount","unitSampler","unitSamplerGenerator","floor","sample","parseInt","saveGlobal","pollution","noglobals","checkPollution","newGlobals","deletedGlobals","old","focused","newTest","only","internalStop","internalStart","numberOfTests","childModule","notifyTestsRan","testsRun","parentModule","testContext","errorString","message","resultErrorString","substring","applyDeprecated","Date","getTime","sessionStorage","x","setItem","removeItem","replace","globalStartCalled","hasOwnProperty","reorder","altertitle","collapse","scrolltop","maxDepth","requireExpects","urlConfig","moduleStack","onErrorFnPrev","onerror","filePath","linerNr","ret","ignoreGlobalErrors","validTest","isLocal","location","protocol","version","executeNow","createModule","moduleName","env","beforeEach","afterEach","setCurrentModule","moduleFns","teardown","before","after","pop","globalStartAlreadyCalled","autostart","pageLoaded","load","filter","run","runTest","promise","resolvePromise","callbackStarted","notrycatch","queueHook","hook","hookOwner","callHook","preserveEnvironment","hooks","handler","processHooks","finish","skipped","source","preserveTestEnvironment","reverse","valid","getItem","pushResult","resultInfo","details","actual","negative","phase","then","moduleChainNameMatch","testModule","testModuleName","moduleChainIdMatch","regexFilter","exec","fullName","stringFilter","exclude","pattern","flags","regex","RegExp","charAt","currentTest","expect","asserts","popped","acceptCallCount","currentAssert","ok","dump","parse","notOk","equal","notEqual","propEqual","equiv","notPropEqual","deepEqual","notDeepEqual","strictEqual","notStrictEqual","throws","block","expectedType","expectedOutput","raises","useStrictEquality","valueOf","compareConstructors","protoA","getProto","protoB","getRegExpFlags","regexp","typeEquiv","innerEquiv","callers","parents","parentsB","string","boolean","number","null","symbol","date","nan","function","caller","loop","aCircular","bCircular","innerEq","outerEq","size","aVal","bVal","map","aKey","bKey","object","eq","aProperties","bProperties","sort","quote","literal","o","pre","post","s","separator","base","indent","inner","up","down","reName","objType","res","parser","parserType","inStack","typeOf","parsers","setInterval","nodeType","item","multiline","HTML","extra","chr","indentChar","setParser","unknown","fn","nodelist","keys","nonEnumerableProperties","node","open","close","tag","nodeName","attrs","attributes","nodeValue","functionArgs","String","fromCharCode","functionCode","attribute","jsDump","asyncTest","stop","reset","getUrlParams","urlParams","search","decodeURIComponent","concat","escapeText","addEvent","addEventListener","removeEvent","removeEventListener","addEvents","elems","hasClass","className","addClass","toggleClass","force","removeClass","trim","getUrlConfigHtml","escaped","escapedTooltip","selection","urlConfigHtml","label","tooltip","toolbarChanged","updatedUrl","field","options","selectedIndex","checked","defaultValue","setUrl","history","replaceState","arrValue","querystring","encodeURIComponent","host","pathname","applyUrlParams","selectedModules","modulesList","getElementsByTagName","getAttribute","toolbarUrlConfigContainer","urlConfigContainer","createElement","toolbarLooseFilter","input","button","appendChild","ev","preventDefault","moduleDropDownHtml","dropDownHtml","toolbarModuleFilter","toolbar","moduleFilter","moduleFilterComponent","moduleSearch","dropDownContainer","dropDownList","clearFilter","placeholder","onclick","style","display","hideHandler","contains","moduleText","searchText","listItems","children","textContent","appendToolbar","appendHeader","header","unfilteredUrl","appendBanner","banner","appendTestResults","parentNode","removeChild","insertBefore","storeFixture","appendFilteredTest","appendUserAgent","userAgent","createTextNode","navigator","appendInterface","qunit","title","appendTestsList","z","moduleObj","appendTest","rerunTrigger","testBlock","assertList","getNameHtml","href","nameHtml","stripHtml","random","option","init","collapseNext","localeCompare","hidepassed","html","scrollTo","testStart","running","log","assertLi","showDiff","testItem","testDone","testTitle","time","good","testCounts","sourceName","firstChild","notPhantom","major","phantom","readyState","DiffMatchPatch","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","DiffMain","text1","text2","optChecklines","deadline","checklines","commonlength","commonprefix","commonsuffix","diffs","diffCommonPrefix","diffCommonSuffix","diffCompute","unshift","diffCleanupMerge","diffCleanupEfficiency","changes","equalities","equalitiesLength","lastequality","pointer","preIns","preDel","postIns","postDel","diffPrettyHtml","op","pointermid","pointermax","pointermin","pointerstart","min","pointerend","longtext","shorttext","hm","text1A","text2A","text1B","text2B","midCommon","diffsA","diffsB","diffHalfMatch","diffLineMode","diffBisect","diffHalfMatchI","bestCommon","prefixLength","suffixLength","bestLongtextA","bestLongtextB","bestShorttextA","bestShorttextB","dmp","hm1","hm2","ceil","linearray","countInsert","countDelete","textInsert","textDelete","diffLinesToChars","chars1","chars2","lineArray","diffCharsToLines","diffCleanupSemantic","text1Length","text2Length","maxD","vOffset","vLength","v1","v2","delta","front","k1start","k1end","k2start","k2end","k2Offset","k1Offset","x1","x2","y1","y2","d","k1","k2","diffBisectSplit","y","text1a","text1b","text2a","text2b","diffsb","lengthInsertions2","lengthDeletions2","lengthInsertions1","lengthDeletions1","deletion","insertion","overlapLength1","overlapLength2","max","diffCommonOverlap","textLength","best","found","diffLinesToCharsMunge","text","chars","lineStart","lineEnd","lineArrayLength","line","lineHash","diffPointer","position","n","output","_jsmocktool","_qunit","mock_test1","mock_test2","mock_test3","RECEIVE","FOO","BAR","FOO2","FOO3","receiveMock","should_receive","receiveMock2","RECEIVE2","receive","mock_method","and_return","RECEIVE4","with_param","noneParam","oneParam","twoParam","error_message","and_throw","test2","and_function","test3","MockInstance","errormessage","mockInstance","commonfunc","aaa","bbb","ccc","ddd","aaaa","bbbb","cccc","aaaaa","bbbbb","ccccc","Verify","kall","[1,2]","Verify2","kall2","verify_all","[]","Verify4","Verify5","reset_all","originConsole","STUB","Obj","STUB2","funcObj","stub_obj","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","cachedSetTimeout","cachedClearTimeout","Item","fun","noop","nextTick","browser","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths"],"mappings":"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","file":"test/dist/jsmocktool.test.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(10);\n\t__webpack_require__(11);\n\tmodule.exports = __webpack_require__(12);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\t/* eslint-disable */\n\tmodule.exports = typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();\n\t/* eslint-enable */\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _global = __webpack_require__(1);\n\t\n\tvar _global2 = _interopRequireDefault(_global);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @access private\n\t **/\n\t\n\tvar TestDouble = function () {\n\t\tfunction TestDouble(name, type) {\n\t\t\t_classCallCheck(this, TestDouble);\n\t\n\t\t\tthis.createTestDouble(name, type);\n\t\t}\n\t\n\t\t_createClass(TestDouble, [{\n\t\t\tkey: 'createTestDouble',\n\t\t\tvalue: function createTestDouble(name, type) {\n\t\t\t\tthis.returnValue = '_js_testDouble_none';\n\t\t\t\tthis.testDoubleType = type;\n\t\n\t\t\t\tif (typeof name === 'string') {\n\t\t\t\t\tthis.makeEnableObj(name, type);\n\t\t\t\t} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' || typeof name === 'function') {\n\t\t\t\t\tthis.testDoubleObj = name;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Name of ' + this.type + ' is incorrect.\\n\\t\\t\\tThe Type only have String or Object or Function.');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTestDouble',\n\t\t\tvalue: function getTestDouble() {\n\t\t\t\tif (this.testDoubleType === 'object') {\n\t\t\t\t\treturn this.testDoubleObj;\n\t\t\t\t}\n\t\t\t\treturn this.testDoubleObj.prototype;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'makeEnableObj',\n\t\t\tvalue: function makeEnableObj(name, type) {\n\t\t\t\tvar depth = name.split('.');\n\t\t\t\tvar objectName = depth[0];\n\t\t\t\tvar obj = _global2.default;\n\t\t\t\tif (depth.length > 1) {\n\t\t\t\t\tdepth.splice(0, depth.length - 1).forEach(function (v) {\n\t\t\t\t\t\tif (typeof obj[v] === 'undefined') {\n\t\t\t\t\t\t\tobj[v] = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj = obj[v];\n\t\t\t\t\t});\n\t\t\t\t\tobjectName = depth[depth.length - 1];\n\t\t\t\t}\n\t\n\t\t\t\tvar returnObj = obj[objectName];\n\t\t\t\tthis.testDoubleObj = returnObj;\n\t\t\t\tif (type === 'object' && !returnObj) {\n\t\t\t\t\tthis.testDoubleObj = obj[objectName] = {};\n\t\t\t\t} else if (type === 'instance' && !returnObj) {\n\t\t\t\t\tthis.testDoubleObj = obj[objectName] = function () {};\n\t\t\t\t\tthis.testDoubleObj.prototype = obj[objectName].prototype = {};\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn TestDouble;\n\t}();\n\t\n\texports.default = TestDouble;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.mock = exports.stub = undefined;\n\t\n\tvar _jsstub = __webpack_require__(7);\n\t\n\tvar _jsstub2 = _interopRequireDefault(_jsstub);\n\t\n\tvar _jsmock = __webpack_require__(4);\n\t\n\tvar _jsmock2 = _interopRequireDefault(_jsmock);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.stub = _jsstub2.default;\n\texports.mock = _jsmock2.default;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.default = mockWrap;\n\t\n\tvar _jsmockMethodFactory = __webpack_require__(6);\n\t\n\tvar _jsmockMethodFactory2 = _interopRequireDefault(_jsmockMethodFactory);\n\t\n\tvar _testDouble = __webpack_require__(2);\n\t\n\tvar _testDouble2 = _interopRequireDefault(_testDouble);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/** @class Mock */\n\t\n\tvar Mock = function (_TestDouble) {\n\t\t_inherits(Mock, _TestDouble);\n\t\n\t\t/**\n\t  * @access private\n\t  **/\n\t\n\t\tfunction Mock(name) {\n\t\t\tvar type = arguments.length <= 1 || arguments[1] === undefined ? 'object' : arguments[1];\n\t\n\t\t\t_classCallCheck(this, Mock);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Mock).call(this, name, type));\n\t\n\t\t\t_this.type = 'Mock';\n\t\t\treturn _this;\n\t\t}\n\t\t/**\n\t  * should_receive make method in mock.\n\t  * @memberof Mock\n\t  * @instance\n\t  * @param {string} methodName - method name in mock.\n\t  * @function should_receive\n\t  * @returns {MockMethod}\n\t  * @example\n\t mock(\"obj\").should_receive(\"something\");\n\t // obj.something();\n\t mock(\"Sample\",mock.INSTANCE).should_receive(\"something\");\n\t // let sample = new Sample();\n\t // sample.something();\n\t // class Test\n\t // end\n\t // let test = new Test();\n\t mock(test).should_receive(\"something\");\n\t // test.something();\n\t mock(Test,mock.INSTANCE).should_receive(\"instance\");\n\t // let test = new Test();\n\t // test.instance()\n\t  **/\n\t\n\t\n\t\t_createClass(Mock, [{\n\t\t\tkey: 'should_receive',\n\t\t\tvalue: function should_receive(methodName) {\n\t\t\t\treturn _jsmockMethodFactory2.default.getMethod(this.getTestDouble(), methodName);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Return specific information called method.\n\t   * @memberof Mock\n\t   * @instance\n\t   * @function verify\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\");\n\t  obj.something();\n\t  mock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'verify',\n\t\t\tvalue: function verify(methodName) {\n\t\t\t\tvar methodInfo = _jsmockMethodFactory2.default.getData(this.getTestDouble()).get(methodName);\n\t\t\t\tif (methodInfo) {\n\t\t\t\t\tif (methodInfo.record.total === 0) {\n\t\t\t\t\t\tthrow new Error(methodName + ' isn\\'t called.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn methodInfo.record;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(methodName + ' isn\\'t method.');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Return all information called methods.\n\t   * @memberof Mock\n\t   * @instance\n\t   * @function verify_all\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\");\n\t  mock(\"obj\").should_receive(\"something2\");\n\t  obj.something();\n\t  obj.something2();\n\t  mock(\"obj\").verify_all();\n\t  //{\n\t  //\t\"something\": {total\" : 1, param : {}}\n\t  //\t\"something2\": {total\" : 1, param : {}}\n\t  //}\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'verify_all',\n\t\t\tvalue: function verify_all() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tvar returnValue = {};\n\t\n\t\t\t\tobj.forEach(function (v, i) {\n\t\t\t\t\tif (i !== 'current_obj') returnValue[i] = _this2.verify(i);\n\t\t\t\t});\n\t\n\t\t\t\treturn returnValue;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Resets specific information called method.\n\t   * @memberof Mock\n\t   * @instance\n\t   * @function reset\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\");\n\t  mock(\"obj\").should_receive(\"something2\");\n\t  obj.something();\n\t  obj.something2();\n\t  mock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\n\t  mock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\t  mock(\"obj\").reset(\"something\");\n\t  mock(\"obj\").verify(\"something\"); // throw new Error(`something isn't called.`);\n\t  mock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'reset',\n\t\t\tvalue: function reset(methodName) {\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tobj.get(methodName).record = { total: 0, param: {} };\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Resets all information called methods.\n\t   * @memberof Mock\n\t   * @instance\n\t   * @function reset_all\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\");\n\t  mock(\"obj\").should_receive(\"something2\");\n\t  obj.something();\n\t  obj.something2();\n\t  mock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\n\t  mock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\t  mock(\"obj\").reset_all();\n\t  mock(\"obj\").verify(\"something\"); // throw new Error(`something isn't called.`);\n\t  mock(\"obj\").verify(\"something2\"); // throw new Error(`something2 isn't called.`);\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'reset_all',\n\t\t\tvalue: function reset_all() {\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = _jsmockMethodFactory2.default.getData(this.getTestDouble())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar _step$value = _slicedToArray(_step.value, 2);\n\t\n\t\t\t\t\t\tvar key = _step$value[0];\n\t\t\t\t\t\tvar value = _step$value[1];\n\t\n\t\t\t\t\t\tif (key !== 'current_obj') {\n\t\t\t\t\t\t\tvalue.record = { total: 0, param: {} };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Mock;\n\t}(_testDouble2.default);\n\t\n\t/**\n\t * @desc create mock in global.\n\t * @param {string|object|function|class} name - Mock object of name, object, function or class.\n\t * @param {string} type - Mock object of type. - mock.INSTANCE, mock.OBJECT(defalut)\n\t * @function mock\n\t * @returns {Mock}\n\t * @example\n\t// If `name` is string and `global` not found `name` object that mock create object in global.\n\tmock(\"obj\").should_receive(\"something\");\n\tmock(\"Sample\",mock.INSTANCE).should_receive(\"something\");\n\t\n\t// If `name` is object that mock don`t create object.\n\tmock(obj).should_receive(\"something\");\n\tmock(zlass).should_receive(\"something\");\n\t **/\n\t\n\t\n\tfunction mockWrap(name, type) {\n\t\tif (this instanceof Mock) {\n\t\t\tthis.createTestDouble(name, type);\n\t\t} else {\n\t\t\treturn new Mock(name, type);\n\t\t}\n\t}\n\t\n\t/**\n\t * object string\n\t * @name mock.OBJECT\n\t * @global\n\t * @example\n\tmock(\"obj\", mock.OBJECT);\n\t **/\n\tmockWrap.OBJECT = 'object';\n\t\n\t/**\n\t * instance string\n\t * @name mock.INSTANCE\n\t * @global\n\t * @example\n\tmock(\"obj\", mock.INSTANCE);\n\t **/\n\tmockWrap.INSTANCE = 'instance';\n\t\n\t/**\n\t * `anything` return special string.\n\t * If you use `anything` in `with_param` that\n\t * `should_receive` execute method regardless of parameter value.\n\t * @name mock.anything\n\t * @global\n\t * @function anything\n\t * @returns {String} - '_js_mock_anything_param'\n\t * @example\n\tmock(\"obj\").should_receive(\"something\").with_param(1,mock.anything()).and_return(\"1\");\n\t **/\n\tmockWrap.anything = function () {\n\t\treturn '_js_mock_anything_param';\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/** @class MockMethod */\n\t\n\tvar MockMethod = function () {\n\t\t/**\n\t  * @access private\n\t  **/\n\t\n\t\tfunction MockMethod(obj, methodName) {\n\t\t\t_classCallCheck(this, MockMethod);\n\t\n\t\t\tthis.excuteObjs = new Map();\n\t\t\t// {\n\t\t\t//      key:{\n\t\t\t//          arg:[],\n\t\t\t//          type:'function',\n\t\t\t//          excute : function(){}\n\t\t\t//      }\n\t\t\t// };\n\t\t\tthis.record = { total: 0, param: {} };\n\t\t\tthis.currentParam = this.transformParamToString([]);\n\t\t\tthis.excuteObjs.set(this.currentParam, new Map());\n\t\t\tthis.setup(obj, methodName);\n\t\t}\n\t\n\t\t/**\n\t  * @access private\n\t  **/\n\t\n\t\n\t\t_createClass(MockMethod, [{\n\t\t\tkey: 'transformParamToString',\n\t\t\tvalue: function transformParamToString(obj) {\n\t\t\t\treturn JSON.stringify(obj);\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @access private\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'setup',\n\t\t\tvalue: function setup(obj, methodName) {\n\t\t\t\tvar that = this;\n\t\t\t\tvar target = obj;\n\t\t\t\ttarget[methodName] = function () {\n\t\t\t\t\tfor (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\t\tparams[_key] = arguments[_key];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthat.record.total++;\n\t\t\t\t\tvar argString = that.transformParamToString(params);\n\t\n\t\t\t\t\tif (that.record.param[argString]) {\n\t\t\t\t\t\tthat.record.param[argString] += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthat.record.param[argString] = 1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar dataObj = that.excuteObjs.get(argString);\n\t\n\t\t\t\t\tif (dataObj) {\n\t\t\t\t\t\tvar type = dataObj.get('type');\n\t\t\t\t\t\tvar excute = dataObj.get('excute');\n\t\t\t\t\t\tif (type === 'function') {\n\t\t\t\t\t\t\treturn excute.apply(dataObj, params);\n\t\t\t\t\t\t} else if (type === 'exception') {\n\t\t\t\t\t\t\tthrow excute;\n\t\t\t\t\t\t} else if (type === 'return') {\n\t\t\t\t\t\t\treturn excute;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\t\t\tvar _didIteratorError = false;\n\t\t\t\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfor (var _iterator = that.excuteObjs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\t\t\tvar _step$value = _slicedToArray(_step.value, 2);\n\t\n\t\t\t\t\t\t\t\tvar info = _step$value[1];\n\t\n\t\t\t\t\t\t\t\tvar arg = info.get('arg');\n\t\t\t\t\t\t\t\tif (arg && arg.length === params.length && !arg.find(function (v, i) {\n\t\t\t\t\t\t\t\t\treturn v !== params[i] && v !== '_js_mock_anything_param';\n\t\t\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\t\t\treturn info.get('excute');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t\t_iteratorError = err;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t/**\n\t   * set parameters of should_receive.\n\t   * If you use `with_param` that `and_xxx` method execute matching param.\n\t   * @instance\n\t   * @memberof MockMethod\n\t   * @param {...anything} params - list up parameters.\n\t   * @function with_param\n\t   * @returns {MockMethod}\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\").with_param(1,2).and_return(\"1\");\n\t  // obj.something(1); => not return anything\n\t  // obj.something(1, 2); => \"1\"\n\t  // You can use `mock.anything`.\n\t  mock(\"obj\").should_receive(\"something\").with_param(1,mock.anything()).and_return(\"1\");\n\t  // obj.something(1, 1); => \"1\"\n\t  // obj.something(1, 2); => \"1\"\n\t  // obj.something(1, 3); => \"1\"\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'with_param',\n\t\t\tvalue: function with_param() {\n\t\t\t\tfor (var _len2 = arguments.length, params = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\tparams[_key2] = arguments[_key2];\n\t\t\t\t}\n\t\n\t\t\t\tthis.currentParam = this.transformParamToString(params);\n\t\t\t\tthis.excuteObjs.set(this.currentParam, new Map().set('arg', params));\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * @access private\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'and_template',\n\t\t\tvalue: function and_template(type, excute) {\n\t\t\t\tthis.excuteObjs.get(this.currentParam).set('type', type).set('excute', excute);\n\t\n\t\t\t\tthis.currentParam = this.transformParamToString([]);\n\t\t\t}\n\t\t\t/**\n\t   * set return value when should_receive called.\n\t   * @instance\n\t   * @memberof MockMethod\n\t   * @param {Object} returnVal - return value\n\t   * @function and_return\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\").and_return(\"1\");\n\t  // obj.something(1); => \"1\"\n\t  // obj.something(1, 2); => \"1\"\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'and_return',\n\t\t\tvalue: function and_return(returnVal) {\n\t\t\t\tthis.and_template('return', returnVal);\n\t\t\t}\n\t\t\t/**\n\t   * Set execution function when should_receive called.\n\t   * @instance\n\t   * @memberof MockMethod\n\t   * @param {Function} returnFunction - execute function\n\t   * @function and_function\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\").and_function(function(){\n\t  return \"1\";\n\t  });\n\t  // obj.something(1); => \"1\"\n\t  // obj.something(1, 2); => \"1\"\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'and_function',\n\t\t\tvalue: function and_function(returnFunction) {\n\t\t\t\tthis.and_template('function', returnFunction);\n\t\t\t}\n\t\t\t/**\n\t   * Set exception error when should_receive called.\n\t   * @instance\n\t   * @memberof MockMethod\n\t   * @param {String} returnException - exception message\n\t   * @function and_throw\n\t   * @example\n\t  mock(\"obj\").should_receive(\"something\").and_throw(\"error\");\n\t  // obj.something(1); => new Error(\"error\")\n\t  // obj.something(1, 2); => new Error(\"error\")\n\t   **/\n\t\n\t\t}, {\n\t\t\tkey: 'and_throw',\n\t\t\tvalue: function and_throw(returnException) {\n\t\t\t\tthis.and_template('exception', returnException);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn MockMethod;\n\t}();\n\t\n\texports.default = MockMethod;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _jsmockMethod = __webpack_require__(5);\n\t\n\tvar _jsmockMethod2 = _interopRequireDefault(_jsmockMethod);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * @access private\n\t **/\n\texports.default = {\n\t\tstorage: [\n\t\t\t//      {\n\t\t\t//          current_obj : {}, object\n\t\t\t//          current_functions : {} mock method\n\t\t\t//      }\n\t\t],\n\t\tcreateData: function createData(obj) {\n\t\t\tvar dataObj = new Map().set('current_obj', obj);\n\t\t\tthis.storage.push(dataObj);\n\t\n\t\t\treturn dataObj;\n\t\t},\n\t\tcreateMethod: function createMethod(obj, methodName) {\n\t\t\treturn new _jsmockMethod2.default(obj, methodName);\n\t\t},\n\t\tgetData: function getData(obj) {\n\t\t\tvar data = this.storage.find(function (value) {\n\t\t\t\treturn value.get('current_obj') === obj;\n\t\t\t});\n\t\t\treturn data || this.createData(obj);\n\t\t},\n\t\tgetMethod: function getMethod(obj, methodName) {\n\t\t\tvar dataObj = this.getData(obj);\n\t\t\tvar methodObj = dataObj.get(methodName);\n\t\t\tif (!methodObj) {\n\t\t\t\tmethodObj = this.createMethod(obj, methodName);\n\t\t\t\tdataObj.set(methodName, methodObj);\n\t\t\t}\n\t\t\treturn methodObj;\n\t\t}\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.default = stubWrap;\n\t\n\tvar _jsstubMethod = __webpack_require__(8);\n\t\n\tvar _jsstubMethod2 = _interopRequireDefault(_jsstubMethod);\n\t\n\tvar _testDouble = __webpack_require__(2);\n\t\n\tvar _testDouble2 = _interopRequireDefault(_testDouble);\n\t\n\tvar _global = __webpack_require__(1);\n\t\n\tvar _global2 = _interopRequireDefault(_global);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\r\n\t * @access private\r\n\t **/\n\tfunction warn(msg) {\n\t\tif (_global2.default.console && console.warn) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t}\n\t\n\t/**\r\n\t * @access private\r\n\t **/\n\t\n\tvar Stub = function (_TestDouble) {\n\t\t_inherits(Stub, _TestDouble);\n\t\n\t\tfunction Stub(name) {\n\t\t\tvar type = arguments.length <= 1 || arguments[1] === undefined ? 'object' : arguments[1];\n\t\n\t\t\t_classCallCheck(this, Stub);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Stub).call(this, name, type));\n\t\n\t\t\t_this.type = 'Stub';\n\t\t\twarn('[WARN] : Deprecated Stub. You should be change to Mock.');\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t_createClass(Stub, [{\n\t\t\tkey: 'should_receive',\n\t\t\tvalue: function should_receive(functionName) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tthis.getTestDouble()[functionName] = function () {\n\t\t\t\t\tif (_this2.returnValue !== '_js_stub_none') {\n\t\t\t\t\t\treturn _this2.returnValue;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn new _jsstubMethod2.default(this);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Stub;\n\t}(_testDouble2.default);\n\t\n\t/**\r\n\t * @access private\r\n\t **/\n\t\n\t\n\tfunction stubWrap(name, type) {\n\t\tif (this instanceof Stub) {\n\t\t\tthis.createTestDouble(name, type);\n\t\t} else {\n\t\t\treturn new Stub(name, type);\n\t\t}\n\t}\n\t\n\t/**\r\n\t * @access private\r\n\t **/\n\tstubWrap.OBJECT = 'object';\n\t/**\r\n\t * @access private\r\n\t **/\n\tstubWrap.INSTANCE = 'instance';\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @access private\n\t **/\n\t\n\tvar StubMethod = function () {\n\t\tfunction StubMethod(stub) {\n\t\t\t_classCallCheck(this, StubMethod);\n\t\n\t\t\tthis.stub = stub;\n\t\t}\n\t\n\t\t_createClass(StubMethod, [{\n\t\t\tkey: \"and_return\",\n\t\t\tvalue: function and_return(returnValue) {\n\t\t\t\tthis.stub.returnValue = returnValue;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn StubMethod;\n\t}();\n\t\n\texports.default = StubMethod;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, module) {/*!\n\t * QUnit 2.0.0-rc1\n\t * https://qunitjs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-04-19T16:15Z\n\t */\n\t\n\t( function( global ) {\n\t\n\tvar QUnit = {};\n\t\n\tvar Date = global.Date;\n\tvar now = Date.now || function() {\n\t\treturn new Date().getTime();\n\t};\n\t\n\tvar setTimeout = global.setTimeout;\n\tvar clearTimeout = global.clearTimeout;\n\t\n\t// Store a local window from the global to allow direct references.\n\tvar window = global.window;\n\t\n\tvar defined = {\n\t\tdocument: window && window.document !== undefined,\n\t\tsetTimeout: setTimeout !== undefined,\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t};\n\t\n\tvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\n\tvar globalStartCalled = false;\n\tvar runStarted = false;\n\t\n\tvar autorun = false;\n\t\n\tvar toString = Object.prototype.toString,\n\t\thasOwn = Object.prototype.hasOwnProperty;\n\t\n\t// Returns a new Array with the elements that are in a but not in b\n\tfunction diff( a, b ) {\n\t\tvar i, j,\n\t\t\tresult = a.slice();\n\t\n\t\tfor ( i = 0; i < result.length; i++ ) {\n\t\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\t\tresult.splice( i, 1 );\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// From jquery.js\n\tfunction inArray( elem, array ) {\n\t\tif ( array.indexOf ) {\n\t\t\treturn array.indexOf( elem );\n\t\t}\n\t\n\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\tif ( array[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Makes a clone of an object using only Array or Object as base,\n\t * and copies over the own enumerable properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object} New object with only the own properties (recursively).\n\t */\n\tfunction objectValues ( obj ) {\n\t\tvar key, val,\n\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\tfor ( key in obj ) {\n\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\tval = obj[ key ];\n\t\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t}\n\t\n\tfunction extend( a, b, undefOnly ) {\n\t\tfor ( var prop in b ) {\n\t\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a;\n\t}\n\t\n\tfunction objectType( obj ) {\n\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\n\t\t// Consider: typeof null === object\n\t\tif ( obj === null ) {\n\t\t\treturn \"null\";\n\t\t}\n\t\n\t\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\t\ttype = match && match[ 1 ];\n\t\n\t\tswitch ( type ) {\n\t\t\tcase \"Number\":\n\t\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Set\":\n\t\t\tcase \"Map\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"Symbol\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ( typeof obj === \"object\" ) {\n\t\t\treturn \"object\";\n\t\t}\n\t}\n\t\n\t// Safe object type checking\n\tfunction is( type, obj ) {\n\t\treturn QUnit.objectType( obj ) === type;\n\t}\n\t\n\t// Doesn't support IE9, it will return undefined on these browsers\n\t// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\tfunction extractStacktrace( e, offset ) {\n\t\toffset = offset === undefined ? 4 : offset;\n\t\n\t\tvar stack, include, i;\n\t\n\t\tif ( e.stack ) {\n\t\t\tstack = e.stack.split( \"\\n\" );\n\t\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\t\tstack.shift();\n\t\t\t}\n\t\t\tif ( fileName ) {\n\t\t\t\tinclude = [];\n\t\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t\t}\n\t\t\t\tif ( include.length ) {\n\t\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stack[ offset ];\n\t\t}\n\t}\n\t\n\tfunction sourceFromStacktrace( offset ) {\n\t\tvar error = new Error();\n\t\n\t\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\t\tif ( !error.stack ) {\n\t\t\ttry {\n\t\t\t\tthrow error;\n\t\t\t} catch ( err ) {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t}\n\t\n\t\treturn extractStacktrace( error, offset );\n\t}\n\t\n\t/**\n\t * Config object: Maintain internal state\n\t * Later exposed as QUnit.config\n\t * `config` initialized at top of scope\n\t */\n\tvar config = {\n\t\n\t\t// The queue of tests to run\n\t\tqueue: [],\n\t\n\t\t// Block until document ready\n\t\tblocking: true,\n\t\n\t\t// By default, run previously failed tests first\n\t\t// very useful in combination with \"Hide passed tests\" checked\n\t\treorder: true,\n\t\n\t\t// By default, modify document.title when suite is done\n\t\taltertitle: true,\n\t\n\t\t// HTML Reporter: collapse every test except the first failing test\n\t\t// If false, all failing tests will be expanded\n\t\tcollapse: true,\n\t\n\t\t// By default, scroll to top of the page when suite is done\n\t\tscrolltop: true,\n\t\n\t\t// Depth up-to which object will be dumped\n\t\tmaxDepth: 5,\n\t\n\t\t// When enabled, all tests must call expect()\n\t\trequireExpects: false,\n\t\n\t\t// Placeholder for user-configurable form-exposed URL parameters\n\t\turlConfig: [],\n\t\n\t\t// Set of all modules.\n\t\tmodules: [],\n\t\n\t\t// Stack of nested modules\n\t\tmoduleStack: [],\n\t\n\t\t// The first unnamed module\n\t\tcurrentModule: {\n\t\t\tname: \"\",\n\t\t\ttests: []\n\t\t},\n\t\n\t\tcallbacks: {}\n\t};\n\t\n\t// Push a loose unnamed module to the modules collection\n\tconfig.modules.push( config.currentModule );\n\t\n\t// Register logging callbacks\n\tfunction registerLoggingCallbacks( obj ) {\n\t\tvar i, l, key,\n\t\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\t\"moduleStart\", \"moduleDone\" ];\n\t\n\t\tfunction registerLoggingCallback( key ) {\n\t\t\tvar loggingCallback = function( callback ) {\n\t\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t\t};\n\t\n\t\t\treturn loggingCallback;\n\t\t}\n\t\n\t\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\t\tkey = callbackNames[ i ];\n\t\n\t\t\t// Initialize key collection of logging callback\n\t\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\t\tconfig.callbacks[ key ] = [];\n\t\t\t}\n\t\n\t\t\tobj[ key ] = registerLoggingCallback( key );\n\t\t}\n\t}\n\t\n\tfunction runLoggingCallbacks( key, args ) {\n\t\tvar i, l, callbacks;\n\t\n\t\tcallbacks = config.callbacks[ key ];\n\t\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\t\tcallbacks[ i ]( args );\n\t\t}\n\t}\n\t\n\t( function() {\n\t\tif ( !defined.document ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// `onErrorFnPrev` initialized at top of scope\n\t\t// Preserve other handlers\n\t\tvar onErrorFnPrev = window.onerror;\n\t\n\t\t// Cover uncaught exceptions\n\t\t// Returning true will suppress the default browser handler,\n\t\t// returning false will let it run.\n\t\twindow.onerror = function( error, filePath, linerNr ) {\n\t\t\tvar ret = false;\n\t\t\tif ( onErrorFnPrev ) {\n\t\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t\t}\n\t\n\t\t\t// Treat return value as window.onerror itself does,\n\t\t\t// Only do our handling if not suppressed.\n\t\t\tif ( ret !== true ) {\n\t\t\t\tif ( QUnit.config.current ) {\n\t\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t} else {\n\t\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t\t}, { validTest: true } ) );\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t};\n\t}() );\n\t\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\t\n\t// Expose the current QUnit version\n\tQUnit.version = \"2.0.0-rc1\";\n\t\n\textend( QUnit, {\n\t\n\t\t// Call on start of module test to prepend name to all tests\n\t\tmodule: function( name, testEnvironment, executeNow ) {\n\t\t\tvar module, moduleFns;\n\t\t\tvar currentModule = config.currentModule;\n\t\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\t\ttestEnvironment = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tmodule = createModule();\n\t\n\t\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tmoduleFns = {\n\t\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\t\tafter: setHook( module, \"after\" )\n\t\t\t};\n\t\n\t\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\t\tconfig.moduleStack.push( module );\n\t\t\t\tsetCurrentModule( module );\n\t\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\t\tconfig.moduleStack.pop();\n\t\t\t\tmodule = module.parentModule || currentModule;\n\t\t\t}\n\t\n\t\t\tsetCurrentModule( module );\n\t\n\t\t\tfunction createModule() {\n\t\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\t\tvar module = {\n\t\t\t\t\tname: moduleName,\n\t\t\t\t\tparentModule: parentModule,\n\t\t\t\t\ttests: [],\n\t\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\t\ttestsRun: 0\n\t\t\t\t};\n\t\n\t\t\t\tvar env = {};\n\t\t\t\tif ( parentModule ) {\n\t\t\t\t\tparentModule.childModule = module;\n\t\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\t\tdelete env.beforeEach;\n\t\t\t\t\tdelete env.afterEach;\n\t\t\t\t}\n\t\t\t\textend( env, testEnvironment );\n\t\t\t\tmodule.testEnvironment = env;\n\t\n\t\t\t\tconfig.modules.push( module );\n\t\t\t\treturn module;\n\t\t\t}\n\t\n\t\t\tfunction setCurrentModule( module ) {\n\t\t\t\tconfig.currentModule = module;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttest: test,\n\t\n\t\tskip: skip,\n\t\n\t\tonly: only,\n\t\n\t\tstart: function( count ) {\n\t\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\t\n\t\t\tif ( !config.current ) {\n\t\t\t\tglobalStartCalled = true;\n\t\n\t\t\t\tif ( runStarted ) {\n\t\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t\t} else if ( config.autostart ) {\n\t\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t\t} else if ( !config.pageLoaded ) {\n\t\n\t\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\t\tconfig.autostart = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tresumeProcessing();\n\t\t},\n\t\n\t\tconfig: config,\n\t\n\t\tis: is,\n\t\n\t\tobjectType: objectType,\n\t\n\t\textend: extend,\n\t\n\t\tload: function() {\n\t\t\tconfig.pageLoaded = true;\n\t\n\t\t\t// Initialize the configuration options\n\t\t\textend( config, {\n\t\t\t\tstats: { all: 0, bad: 0 },\n\t\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\t\tstarted: 0,\n\t\t\t\tupdateRate: 1000,\n\t\t\t\tautostart: true,\n\t\t\t\tfilter: \"\"\n\t\t\t}, true );\n\t\n\t\t\tconfig.blocking = false;\n\t\n\t\t\tif ( config.autostart ) {\n\t\t\t\tresumeProcessing();\n\t\t\t}\n\t\t},\n\t\n\t\tstack: function( offset ) {\n\t\t\toffset = ( offset || 0 ) + 2;\n\t\t\treturn sourceFromStacktrace( offset );\n\t\t}\n\t} );\n\t\n\tregisterLoggingCallbacks( QUnit );\n\t\n\tfunction begin() {\n\t\tvar i, l,\n\t\t\tmodulesLog = [];\n\t\n\t\t// If the test run hasn't officially begun yet\n\t\tif ( !config.started ) {\n\t\n\t\t\t// Record the time of the test run's beginning\n\t\t\tconfig.started = now();\n\t\n\t\t\t// Delete the loose unnamed module if unused.\n\t\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\t\tconfig.modules.shift();\n\t\t\t}\n\t\n\t\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\t\tmodulesLog.push( {\n\t\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// The test run is officially beginning now\n\t\t\trunLoggingCallbacks( \"begin\", {\n\t\t\t\ttotalTests: Test.count,\n\t\t\t\tmodules: modulesLog\n\t\t\t} );\n\t\t}\n\t\n\t\tconfig.blocking = false;\n\t\tprocess( true );\n\t}\n\t\n\tfunction process( last ) {\n\t\tfunction next() {\n\t\t\tprocess( last );\n\t\t}\n\t\tvar start = now();\n\t\tconfig.depth = ( config.depth || 0 ) + 1;\n\t\n\t\twhile ( config.queue.length && !config.blocking ) {\n\t\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\t\tif ( config.current ) {\n\t\n\t\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t\t}\n\t\t\t\tconfig.queue.shift()();\n\t\t\t} else {\n\t\t\t\tsetTimeout( next, 13 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig.depth--;\n\t\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\t\tdone();\n\t\t}\n\t}\n\t\n\tfunction pauseProcessing( test ) {\n\t\tconfig.blocking = true;\n\t\n\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t\tconfig.timeout = setTimeout( function() {\n\t\t\t\ttest.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t\tresumeProcessing( test );\n\t\t\t}, config.testTimeout );\n\t\t}\n\t}\n\t\n\tfunction resumeProcessing( test ) {\n\t\trunStarted = true;\n\t\n\t\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\t\tif ( defined.setTimeout ) {\n\t\t\tsetTimeout( function() {\n\t\t\t\tvar current = test || config.current;\n\t\t\t\tif ( current && current.semaphore > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t}\n\t\n\t\t\t\tbegin();\n\t\t\t}, 13 );\n\t\t} else {\n\t\t\tbegin();\n\t\t}\n\t}\n\t\n\tfunction done() {\n\t\tvar runtime, passed;\n\t\n\t\tautorun = true;\n\t\n\t\t// Log the last module results\n\t\tif ( config.previousModule ) {\n\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\tname: config.previousModule.name,\n\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t} );\n\t\t}\n\t\tdelete config.previousModule;\n\t\n\t\truntime = now() - config.started;\n\t\tpassed = config.stats.all - config.stats.bad;\n\t\n\t\trunLoggingCallbacks( \"done\", {\n\t\t\tfailed: config.stats.bad,\n\t\t\tpassed: passed,\n\t\t\ttotal: config.stats.all,\n\t\t\truntime: runtime\n\t\t} );\n\t}\n\t\n\tfunction setHook( module, hookName ) {\n\t\tif ( module.testEnvironment === undefined ) {\n\t\t\tmodule.testEnvironment = {};\n\t\t}\n\t\n\t\treturn function( callback ) {\n\t\t\tmodule.testEnvironment[ hookName ] = callback;\n\t\t};\n\t}\n\t\n\tvar unitSampler,\n\t\tfocused = false,\n\t\tpriorityCount = 0;\n\t\n\tfunction Test( settings ) {\n\t\tvar i, l;\n\t\n\t\t++Test.count;\n\t\n\t\tthis.expected = null;\n\t\textend( this, settings );\n\t\tthis.assertions = [];\n\t\tthis.semaphore = 0;\n\t\tthis.usedAsync = false;\n\t\tthis.module = config.currentModule;\n\t\tthis.stack = sourceFromStacktrace( 3 );\n\t\n\t\t// Register unique strings\n\t\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\t\tthis.testName += \" \";\n\t\t\t}\n\t\t}\n\t\n\t\tthis.testId = generateHash( this.module.name, this.testName );\n\t\n\t\tthis.module.tests.push( {\n\t\t\tname: this.testName,\n\t\t\ttestId: this.testId\n\t\t} );\n\t\n\t\tif ( settings.skip ) {\n\t\n\t\t\t// Skipped tests will fully ignore any sent callback\n\t\t\tthis.callback = function() {};\n\t\t\tthis.async = false;\n\t\t\tthis.expected = 0;\n\t\t} else {\n\t\t\tthis.assert = new Assert( this );\n\t\t}\n\t}\n\t\n\tTest.count = 0;\n\t\n\tTest.prototype = {\n\t\tbefore: function() {\n\t\t\tif (\n\t\n\t\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\t\tthis.module !== config.previousModule ||\n\t\n\t\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t\t) {\n\t\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tconfig.previousModule = this.module;\n\t\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\t\tname: this.module.name,\n\t\t\t\t\ttests: this.module.tests\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tif ( this.module.testEnvironment ) {\n\t\t\t\tdelete this.module.testEnvironment.before;\n\t\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\t\tdelete this.module.testEnvironment.after;\n\t\t\t}\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\n\t\t\tthis.started = now();\n\t\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module.name,\n\t\t\t\ttestId: this.testId\n\t\t\t} );\n\t\n\t\t\tif ( !config.pollution ) {\n\t\t\t\tsaveGlobal();\n\t\t\t}\n\t\t},\n\t\n\t\trun: function() {\n\t\t\tvar promise;\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tif ( this.async ) {\n\t\t\t\tinternalStop( this );\n\t\t\t}\n\t\n\t\t\tthis.callbackStarted = now();\n\t\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\trunTest( this );\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttry {\n\t\t\t\trunTest( this );\n\t\t\t} catch ( e ) {\n\t\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\n\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t// Restart the tests if they're blocking\n\t\t\t\tif ( config.blocking ) {\n\t\t\t\t\tinternalStart( this );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction runTest( test ) {\n\t\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise );\n\t\t\t}\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\tcheckPollution();\n\t\t},\n\t\n\t\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\t\tvar promise,\n\t\t\t\ttest = this;\n\t\t\treturn function runHook() {\n\t\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tconfig.current = test;\n\t\t\t\tif ( config.notrycatch ) {\n\t\t\t\t\tcallHook();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tcallHook();\n\t\t\t\t} catch ( error ) {\n\t\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t\t}\n\t\n\t\t\t\tfunction callHook() {\n\t\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\n\t\t// Currently only used for module level hooks, can be used to add global level ones\n\t\thooks: function( handler ) {\n\t\t\tvar hooks = [];\n\t\n\t\t\tfunction processHooks( test, module ) {\n\t\t\t\tif ( module.parentModule ) {\n\t\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t\t}\n\t\t\t\tif ( module.testEnvironment &&\n\t\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Hooks are ignored on skipped tests\n\t\t\tif ( !this.skip ) {\n\t\t\t\tprocessHooks( this, this.module );\n\t\t\t}\n\t\t\treturn hooks;\n\t\t},\n\t\n\t\tfinish: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\t\"not called.\", this.stack );\n\t\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t\t}\n\t\n\t\t\tvar i,\n\t\t\t\tbad = 0;\n\t\n\t\t\tthis.runtime = now() - this.started;\n\t\t\tconfig.stats.all += this.assertions.length;\n\t\t\tconfig.moduleStats.all += this.assertions.length;\n\t\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tnotifyTestsRan( this.module );\n\t\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tskipped: !!this.skip,\n\t\t\t\tfailed: bad,\n\t\t\t\tpassed: this.assertions.length - bad,\n\t\t\t\ttotal: this.assertions.length,\n\t\t\t\truntime: this.runtime,\n\t\n\t\t\t\t// HTML Reporter use\n\t\t\t\tassertions: this.assertions,\n\t\t\t\ttestId: this.testId,\n\t\n\t\t\t\t// Source of Test\n\t\t\t\tsource: this.stack\n\t\t\t} );\n\t\n\t\t\tinternalReset();\n\t\n\t\t\tconfig.current = undefined;\n\t\t},\n\t\n\t\tpreserveTestEnvironment: function() {\n\t\t\tif ( this.preserveEnvironment ) {\n\t\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t\t}\n\t\t},\n\t\n\t\tqueue: function() {\n\t\t\tvar priority,\n\t\t\t\ttest = this;\n\t\n\t\t\tif ( !this.valid() ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tfunction run() {\n\t\n\t\t\t\t// Each of these can by async\n\t\t\t\tsynchronize( [\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.before();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"before\" ),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"beforeEach\" ),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.run();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.after();\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.finish();\n\t\t\t\t\t}\n\t\t\t\t] );\n\t\t\t}\n\t\n\t\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\t\n\t\t\treturn synchronize( run, priority, config.seed );\n\t\t},\n\t\n\t\tpushResult: function( resultInfo ) {\n\t\n\t\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\tvar source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: resultInfo.result,\n\t\t\t\t\tmessage: resultInfo.message,\n\t\t\t\t\tactual: resultInfo.actual,\n\t\t\t\t\texpected: resultInfo.expected,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\t\n\t\t\tif ( !resultInfo.result ) {\n\t\t\t\tsource = sourceFromStacktrace();\n\t\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", details );\n\t\n\t\t\tthis.assertions.push( {\n\t\t\t\tresult: !!resultInfo.result,\n\t\t\t\tmessage: resultInfo.message\n\t\t\t} );\n\t\t},\n\t\n\t\tpushFailure: function( message, source, actual ) {\n\t\t\tif ( !( this instanceof Test ) ) {\n\t\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t}\n\t\n\t\t\tvar details = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message || \"error\",\n\t\t\t\t\tactual: actual || null,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\t\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", details );\n\t\n\t\t\tthis.assertions.push( {\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tresolvePromise: function( promise, phase ) {\n\t\t\tvar then, message,\n\t\t\t\ttest = this;\n\t\t\tif ( promise != null ) {\n\t\t\t\tthen = promise.then;\n\t\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\t\tinternalStop( test );\n\t\t\t\t\tthen.call(\n\t\t\t\t\t\tpromise,\n\t\t\t\t\t\tfunction() { internalStart( test ); },\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\t\n\t\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\t\tinternalStart( test );\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tvalid: function() {\n\t\t\tvar filter = config.filter,\n\t\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\t\n\t\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\t\tif ( testModuleName === module ) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t\t}\n\t\n\t\t\t// Internally-generated tests are always valid\n\t\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t\t!moduleChainIdMatch( this.module ) ) {\n\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( !filter ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn regexFilter ?\n\t\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\t\tthis.stringFilter( filter, fullName );\n\t\t},\n\t\n\t\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\t\tvar regex = new RegExp( pattern, flags );\n\t\t\tvar match = regex.test( fullName );\n\t\n\t\t\treturn match !== exclude;\n\t\t},\n\t\n\t\tstringFilter: function( filter, fullName ) {\n\t\t\tfilter = filter.toLowerCase();\n\t\t\tfullName = fullName.toLowerCase();\n\t\n\t\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\t\tif ( !include ) {\n\t\t\t\tfilter = filter.slice( 1 );\n\t\t\t}\n\t\n\t\t\t// If the filter matches, we need to honour include\n\t\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\t\treturn include;\n\t\t\t}\n\t\n\t\t\t// Otherwise, do the opposite\n\t\t\treturn !include;\n\t\t}\n\t};\n\t\n\t// Resets the fixture DOM element if available.\n\tfunction internalReset() {\n\t\tvar fixture = defined.document && document.getElementById &&\n\t\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\t\n\t\tif ( fixture ) {\n\t\t\tfixture.innerHTML = config.fixture;\n\t\t}\n\t}\n\t\n\tQUnit.pushFailure = function() {\n\t\tif ( !QUnit.config.current ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\t\n\t\t// Gets current test obj\n\t\tvar currentTest = QUnit.config.current;\n\t\n\t\treturn currentTest.pushFailure.apply( currentTest, arguments );\n\t};\n\t\n\t// Based on Java's String.hashCode, a simple but not\n\t// rigorously collision resistant hashing function\n\tfunction generateHash( module, testName ) {\n\t\tvar hex,\n\t\t\ti = 0,\n\t\t\thash = 0,\n\t\t\tstr = module + \"\\x1C\" + testName,\n\t\t\tlen = str.length;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\t\thash |= 0;\n\t\t}\n\t\n\t\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\t\thex = ( 0x100000000 + hash ).toString( 16 );\n\t\tif ( hex.length < 8 ) {\n\t\t\thex = \"0000000\" + hex;\n\t\t}\n\t\n\t\treturn hex.slice( -8 );\n\t}\n\t\n\tfunction synchronize( callback, priority, seed ) {\n\t\tvar last = !priority,\n\t\t\tindex;\n\t\n\t\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\t\twhile ( callback.length ) {\n\t\t\t\tsynchronize( callback.shift() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\n\t\tif ( priority ) {\n\t\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t\t} else if ( seed ) {\n\t\t\tif ( !unitSampler ) {\n\t\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t\t}\n\t\n\t\t\t// Insert into a random position after all priority items\n\t\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t\t} else {\n\t\t\tconfig.queue.push( callback );\n\t\t}\n\t\n\t\tif ( autorun && !config.blocking ) {\n\t\t\tprocess( last );\n\t\t}\n\t}\n\t\n\tfunction unitSamplerGenerator( seed ) {\n\t\n\t\t// 32-bit xorshift, requires only a nonzero seed\n\t\t// http://excamera.com/sphinx/article-xorshift.html\n\t\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\t\treturn function() {\n\t\t\tsample ^= sample << 13;\n\t\t\tsample ^= sample >>> 17;\n\t\t\tsample ^= sample << 5;\n\t\n\t\t\t// ECMAScript has no unsigned number type\n\t\t\tif ( sample < 0 ) {\n\t\t\t\tsample += 0x100000000;\n\t\t\t}\n\t\n\t\t\treturn sample / 0x100000000;\n\t\t};\n\t}\n\t\n\tfunction saveGlobal() {\n\t\tconfig.pollution = [];\n\t\n\t\tif ( config.noglobals ) {\n\t\t\tfor ( var key in global ) {\n\t\t\t\tif ( hasOwn.call( global, key ) ) {\n\t\n\t\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconfig.pollution.push( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction checkPollution() {\n\t\tvar newGlobals,\n\t\t\tdeletedGlobals,\n\t\t\told = config.pollution;\n\t\n\t\tsaveGlobal();\n\t\n\t\tnewGlobals = diff( config.pollution, old );\n\t\tif ( newGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t\t}\n\t\n\t\tdeletedGlobals = diff( old, config.pollution );\n\t\tif ( deletedGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t\t}\n\t}\n\t\n\t// Will be exposed as QUnit.test\n\tfunction test( testName, callback ) {\n\t\tif ( focused )  { return; }\n\t\n\t\tvar newTest;\n\t\n\t\tnewTest = new Test( {\n\t\t\ttestName: testName,\n\t\t\tcallback: callback\n\t\t} );\n\t\n\t\tnewTest.queue();\n\t}\n\t\n\t// Will be exposed as QUnit.skip\n\tfunction skip( testName ) {\n\t\tif ( focused )  { return; }\n\t\n\t\tvar test = new Test( {\n\t\t\ttestName: testName,\n\t\t\tskip: true\n\t\t} );\n\t\n\t\ttest.queue();\n\t}\n\t\n\t// Will be exposed as QUnit.only\n\tfunction only( testName, callback ) {\n\t\tvar newTest;\n\t\n\t\tif ( focused )  { return; }\n\t\n\t\tQUnit.config.queue.length = 0;\n\t\tfocused = true;\n\t\n\t\tnewTest = new Test( {\n\t\t\ttestName: testName,\n\t\t\tcallback: callback\n\t\t} );\n\t\n\t\tnewTest.queue();\n\t}\n\t\n\tfunction internalStop( test ) {\n\t\n\t\t// If a test is running, adjust its semaphore\n\t\ttest.semaphore += 1;\n\t\n\t\tpauseProcessing( test );\n\t}\n\t\n\tfunction internalStart( test ) {\n\t\n\t\t// If a test is running, adjust its semaphore\n\t\ttest.semaphore -= 1;\n\t\n\t\t// If semaphore is non-numeric, throw error\n\t\tif ( isNaN( test.semaphore ) ) {\n\t\t\ttest.semaphore = 0;\n\t\n\t\t\tQUnit.pushFailure(\n\t\t\t\t\"Invalid value on test.semaphore\",\n\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Don't start until equal number of stop-calls\n\t\tif ( test.semaphore > 0 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Throw an Error if start is called more often than stop\n\t\tif ( test.semaphore < 0 ) {\n\t\t\ttest.semaphore = 0;\n\t\n\t\t\tQUnit.pushFailure(\n\t\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\n\t\tresumeProcessing( test );\n\t}\n\t\n\tfunction numberOfTests( module ) {\n\t\tvar count = module.tests.length;\n\t\twhile ( module = module.childModule ) {\n\t\t\tcount += module.tests.length;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tfunction notifyTestsRan( module ) {\n\t\tmodule.testsRun++;\n\t\twhile ( module = module.parentModule ) {\n\t\t\tmodule.testsRun++;\n\t\t}\n\t}\n\t\n\tfunction Assert( testContext ) {\n\t\tthis.test = testContext;\n\t}\n\t\n\t// Assert helpers\n\tQUnit.assert = Assert.prototype = {\n\t\n\t\t// Specify the number of expected assertions to guarantee that failed test\n\t\t// (no assertions are run at all) don't slip through.\n\t\texpect: function( asserts ) {\n\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\tthis.test.expected = asserts;\n\t\t\t} else {\n\t\t\t\treturn this.test.expected;\n\t\t\t}\n\t\t},\n\t\n\t\t// Increment this Test's semaphore counter, then return a function that\n\t\t// decrements that counter a maximum of once.\n\t\tasync: function( count ) {\n\t\t\tvar test = this.test,\n\t\t\t\tpopped = false,\n\t\t\t\tacceptCallCount = count;\n\t\n\t\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\t\tacceptCallCount = 1;\n\t\t\t}\n\t\n\t\t\ttest.semaphore += 1;\n\t\t\ttest.usedAsync = true;\n\t\t\tpauseProcessing( test );\n\t\n\t\t\treturn function done() {\n\t\n\t\t\t\tif ( popped ) {\n\t\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tacceptCallCount -= 1;\n\t\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\ttest.semaphore -= 1;\n\t\t\t\tpopped = true;\n\t\t\t\tresumeProcessing();\n\t\t\t};\n\t\t},\n\t\n\t\t// Exports test.push() to the user API\n\t\t// Alias of pushResult.\n\t\tpush: function( result, actual, expected, message, negative ) {\n\t\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\t\treturn currentAssert.pushResult( {\n\t\t\t\tresult: result,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: negative\n\t\t\t} );\n\t\t},\n\t\n\t\tpushResult: function( resultInfo ) {\n\t\n\t\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\tvar assert = this,\n\t\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\t\n\t\t\t// Backwards compatibility fix.\n\t\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t\t// not exactly the test where assertion were intended to be called.\n\t\t\tif ( !currentTest ) {\n\t\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t\t}\n\t\n\t\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\n\t\t\t\t// Allow this assertion to continue running anyway...\n\t\t\t}\n\t\n\t\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\t\tassert = currentTest.assert;\n\t\t\t}\n\t\n\t\t\treturn assert.test.pushResult( resultInfo );\n\t\t},\n\t\n\t\tok: function( result, message ) {\n\t\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\t\tQUnit.dump.parse( result ) );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !!result,\n\t\t\t\tactual: result,\n\t\t\t\texpected: true,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotOk: function( result, message ) {\n\t\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\t\tQUnit.dump.parse( result ) );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !result,\n\t\t\t\tactual: result,\n\t\t\t\texpected: false,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tequal: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected == actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotEqual: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected != actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tpropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues( actual );\n\t\t\texpected = objectValues( expected );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotPropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues( actual );\n\t\t\texpected = objectValues( expected );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tdeepEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotDeepEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tstrictEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected === actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotStrictEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected !== actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\t\"throws\": function( block, expected, message ) {\n\t\t\tvar actual, expectedType,\n\t\t\t\texpectedOutput = expected,\n\t\t\t\tok = false,\n\t\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\t\n\t\t\t// 'expected' is optional unless doing string comparison\n\t\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\tif ( message == null ) {\n\t\t\t\t\tmessage = expected;\n\t\t\t\t\texpected = null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\t\ttry {\n\t\t\t\tblock.call( currentTest.testEnvironment );\n\t\t\t} catch ( e ) {\n\t\t\t\tactual = e;\n\t\t\t}\n\t\t\tcurrentTest.ignoreGlobalErrors = false;\n\t\n\t\t\tif ( actual ) {\n\t\t\t\texpectedType = QUnit.objectType( expected );\n\t\n\t\t\t\t// We don't want to validate thrown error\n\t\t\t\tif ( !expected ) {\n\t\t\t\t\tok = true;\n\t\t\t\t\texpectedOutput = null;\n\t\n\t\t\t\t// Expected is a regexp\n\t\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\t\tok = expected.test( errorString( actual ) );\n\t\n\t\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\t\tok = true;\n\t\n\t\t\t\t// Expected is an Error object\n\t\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\t\tactual.message === expected.message;\n\t\n\t\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcurrentTest.assert.pushResult( {\n\t\t\t\tresult: ok,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expectedOutput,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t}\n\t};\n\t\n\t// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n\t// Known to us are: Closure Compiler, Narwhal\n\t( function() {\n\t\t/*jshint sub:true */\n\t\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n\t}() );\n\t\n\tfunction errorString( error ) {\n\t\tvar name, message,\n\t\t\tresultErrorString = error.toString();\n\t\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif ( name && message ) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if ( name ) {\n\t\t\t\treturn name;\n\t\t\t} else if ( message ) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn resultErrorString;\n\t\t}\n\t}\n\t\n\t// Test for equality any JavaScript type.\n\t// Author: Philippe Rath <prathe@gmail.com>\n\tQUnit.equiv = ( function() {\n\t\n\t\t// Stack to decide between skip/abort functions\n\t\tvar callers = [];\n\t\n\t\t// Stack to avoiding loops from circular referencing\n\t\tvar parents = [];\n\t\tvar parentsB = [];\n\t\n\t\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\t\n\t\t\t/*jshint proto: true */\n\t\t\treturn obj.__proto__;\n\t\t};\n\t\n\t\tfunction useStrictEquality( b, a ) {\n\t\n\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t// `var i = 1;`\n\t\t\t// `var j = new Number(1);`\n\t\t\tif ( typeof a === \"object\" ) {\n\t\t\t\ta = a.valueOf();\n\t\t\t}\n\t\t\tif ( typeof b === \"object\" ) {\n\t\t\t\tb = b.valueOf();\n\t\t\t}\n\t\n\t\t\treturn a === b;\n\t\t}\n\t\n\t\tfunction compareConstructors( a, b ) {\n\t\t\tvar protoA = getProto( a );\n\t\t\tvar protoB = getProto( b );\n\t\n\t\t\t// Comparing constructors is more strict than using `instanceof`\n\t\t\tif ( a.constructor === b.constructor ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Ref #851\n\t\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t\t// as a null prototype.\n\t\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\t\tprotoA = null;\n\t\t\t}\n\t\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\t\tprotoB = null;\n\t\t\t}\n\t\n\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t// objects with Object as their constructor.\n\t\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction getRegExpFlags( regexp ) {\n\t\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t\t}\n\t\n\t\tvar callbacks = {\n\t\t\t\"string\": useStrictEquality,\n\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\"number\": useStrictEquality,\n\t\t\t\"null\": useStrictEquality,\n\t\t\t\"undefined\": useStrictEquality,\n\t\t\t\"symbol\": useStrictEquality,\n\t\t\t\"date\": useStrictEquality,\n\t\n\t\t\t\"nan\": function() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\treturn a.source === b.source &&\n\t\n\t\t\t\t\t// Include flags in the comparison\n\t\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t\t},\n\t\n\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t// - abort otherwise,\n\t\t\t// initial === would have catch identical references anyway\n\t\t\t\"function\": function() {\n\t\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t},\n\t\n\t\t\t\"array\": function( b, a ) {\n\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\t\n\t\t\t\tlen = a.length;\n\t\t\t\tif ( len !== b.length ) {\n\t\n\t\t\t\t\t// Safe and faster\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\t// Track reference to avoid circular references\n\t\t\t\tparents.push( a );\n\t\t\t\tparentsB.push( b );\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tloop = false;\n\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparents.pop();\n\t\t\t\tparentsB.pop();\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"set\": function( b, a ) {\n\t\t\t\tvar innerEq,\n\t\t\t\t\touterEq = true;\n\t\n\t\t\t\tif ( a.size !== b.size ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\ta.forEach( function( aVal ) {\n\t\t\t\t\tinnerEq = false;\n\t\n\t\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\t\touterEq = false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\n\t\t\t\treturn outerEq;\n\t\t\t},\n\t\n\t\t\t\"map\": function( b, a ) {\n\t\t\t\tvar innerEq,\n\t\t\t\t\touterEq = true;\n\t\n\t\t\t\tif ( a.size !== b.size ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\t\tinnerEq = false;\n\t\n\t\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\t\touterEq = false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\n\t\t\t\treturn outerEq;\n\t\t\t},\n\t\n\t\t\t\"object\": function( b, a ) {\n\t\t\t\tvar i, j, loop, aCircular, bCircular;\n\t\n\t\t\t\t// Default to true\n\t\t\t\tvar eq = true;\n\t\t\t\tvar aProperties = [];\n\t\t\t\tvar bProperties = [];\n\t\n\t\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\t// Stack constructor before traversing properties\n\t\t\t\tcallers.push( a.constructor );\n\t\n\t\t\t\t// Track reference to avoid circular references\n\t\t\t\tparents.push( a );\n\t\t\t\tparentsB.push( b );\n\t\n\t\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\tfor ( i in a ) {\n\t\t\t\t\tloop = false;\n\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taProperties.push( i );\n\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\teq = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tparents.pop();\n\t\t\t\tparentsB.pop();\n\t\n\t\t\t\t// Unstack, we are done\n\t\t\t\tcallers.pop();\n\t\n\t\t\t\tfor ( i in b ) {\n\t\n\t\t\t\t\t// Collect b's properties\n\t\t\t\t\tbProperties.push( i );\n\t\t\t\t}\n\t\n\t\t\t\t// Ensures identical properties name\n\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t}\n\t\t};\n\t\n\t\tfunction typeEquiv( a, b ) {\n\t\t\tvar type = QUnit.objectType( a );\n\t\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t\t}\n\t\n\t\t// The real equiv function\n\t\tfunction innerEquiv( a, b ) {\n\t\n\t\t\t// We're done when there's nothing more to compare\n\t\t\tif ( arguments.length < 2 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Require type-specific equality\n\t\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\t\n\t\t\t\t// ...across all consecutive argument pairs\n\t\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t\t}\n\t\n\t\treturn innerEquiv;\n\t}() );\n\t\n\t// Based on jsDump by Ariel Flesler\n\t// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\n\tQUnit.dump = ( function() {\n\t\tfunction quote( str ) {\n\t\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t\t}\n\t\tfunction literal( o ) {\n\t\t\treturn o + \"\";\n\t\t}\n\t\tfunction join( pre, arr, post ) {\n\t\t\tvar s = dump.separator(),\n\t\t\t\tbase = dump.indent(),\n\t\t\t\tinner = dump.indent( 1 );\n\t\t\tif ( arr.join ) {\n\t\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t\t}\n\t\t\tif ( !arr ) {\n\t\t\t\treturn pre + post;\n\t\t\t}\n\t\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t\t}\n\t\tfunction array( arr, stack ) {\n\t\t\tvar i = arr.length,\n\t\t\t\tret = new Array( i );\n\t\n\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\treturn \"[object Array]\";\n\t\t\t}\n\t\n\t\t\tthis.up();\n\t\t\twhile ( i-- ) {\n\t\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t\t}\n\t\t\tthis.down();\n\t\t\treturn join( \"[\", ret, \"]\" );\n\t\t}\n\t\n\t\tvar reName = /^function (\\w+)/,\n\t\t\tdump = {\n\t\n\t\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\t\tstack = stack || [];\n\t\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\t\tinStack = inArray( obj, stack );\n\t\n\t\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\t\tparserType = typeof parser;\n\t\n\t\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\t\tstack.push( obj );\n\t\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t\t},\n\t\t\t\ttypeOf: function( obj ) {\n\t\t\t\t\tvar type;\n\t\t\t\t\tif ( obj === null ) {\n\t\t\t\t\t\ttype = \"null\";\n\t\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\t\ttype = \"date\";\n\t\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\t\ttype = \"function\";\n\t\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\t\ttype = \"window\";\n\t\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\t\ttype = \"document\";\n\t\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\t\ttype = \"node\";\n\t\t\t\t\t} else if (\n\t\n\t\t\t\t\t\t// Native arrays\n\t\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\n\t\t\t\t\t\t// NodeList objects\n\t\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\ttype = \"array\";\n\t\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\t\ttype = \"error\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = typeof obj;\n\t\t\t\t\t}\n\t\t\t\t\treturn type;\n\t\t\t\t},\n\t\n\t\t\t\tseparator: function() {\n\t\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t\t},\n\t\n\t\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\t\tindent: function( extra ) {\n\t\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tvar chr = this.indentChar;\n\t\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t\t},\n\t\t\t\tup: function( a ) {\n\t\t\t\t\tthis.depth += a || 1;\n\t\t\t\t},\n\t\t\t\tdown: function( a ) {\n\t\t\t\t\tthis.depth -= a || 1;\n\t\t\t\t},\n\t\t\t\tsetParser: function( name, parser ) {\n\t\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t\t},\n\t\n\t\t\t\t// The next 3 are exposed so you can use them\n\t\t\t\tquote: quote,\n\t\t\t\tliteral: literal,\n\t\t\t\tjoin: join,\n\t\t\t\tdepth: 1,\n\t\t\t\tmaxDepth: QUnit.config.maxDepth,\n\t\n\t\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\t\tparsers: {\n\t\t\t\t\twindow: \"[Window]\",\n\t\t\t\t\tdocument: \"[Document]\",\n\t\t\t\t\terror: function( error ) {\n\t\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t\t},\n\t\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\t\"null\": \"null\",\n\t\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\t\tvar ret = \"function\",\n\t\n\t\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\t\n\t\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += \"(\";\n\t\n\t\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnodelist: array,\n\t\t\t\t\t\"arguments\": array,\n\t\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\t\tret = [];\n\t\n\t\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tdump.up();\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.sort();\n\t\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdump.down();\n\t\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tnode: function( node ) {\n\t\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\t\tattrs = node.attributes;\n\t\n\t\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\t\n\t\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += close;\n\t\n\t\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\t\tvar args,\n\t\t\t\t\t\t\tl = fn.length;\n\t\n\t\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\targs = new Array( l );\n\t\t\t\t\t\twhile ( l-- ) {\n\t\n\t\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\t\tkey: quote,\n\t\n\t\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\t\tfunctionCode: \"[code]\",\n\t\n\t\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\t\tattribute: quote,\n\t\t\t\t\tstring: quote,\n\t\t\t\t\tdate: quote,\n\t\t\t\t\tregexp: literal,\n\t\t\t\t\tnumber: literal,\n\t\t\t\t\t\"boolean\": literal\n\t\t\t\t},\n\t\n\t\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\t\tHTML: false,\n\t\n\t\t\t\t// Indentation unit\n\t\t\t\tindentChar: \"  \",\n\t\n\t\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\t\tmultiline: true\n\t\t\t};\n\t\n\t\treturn dump;\n\t}() );\n\t\n\t// Back compat\n\tQUnit.jsDump = QUnit.dump;\n\t\n\tfunction applyDeprecated( name ) {\n\t\treturn function() {\n\t\t\tthrow new Error(\n\t\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t};\n\t}\n\t\n\tObject.keys( Assert.prototype ).forEach( function( key ) {\n\t\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n\t} );\n\t\n\tQUnit.asyncTest = function() {\n\t\tthrow new Error(\n\t\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tQUnit.stop = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tQUnit.reset = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tif ( defined.document ) {\n\t\t[\n\t\t\t\"test\",\n\t\t\t\"module\",\n\t\t\t\"expect\",\n\t\t\t\"start\",\n\t\t\t\"ok\",\n\t\t\t\"notOk\",\n\t\t\t\"equal\",\n\t\t\t\"notEqual\",\n\t\t\t\"propEqual\",\n\t\t\t\"notPropEqual\",\n\t\t\t\"deepEqual\",\n\t\t\t\"notDeepEqual\",\n\t\t\t\"strictEqual\",\n\t\t\t\"notStrictEqual\",\n\t\t\t\"throws\",\n\t\t\t\"raises\"\n\t\t].forEach( function( key ) {\n\t\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t\t} );\n\t\n\t\twindow.QUnit = QUnit;\n\t}\n\t\n\t// For nodejs\n\tif ( typeof module !== \"undefined\" && module && module.exports ) {\n\t\tmodule.exports = QUnit;\n\t\n\t\t// For consistency with CommonJS environments' exports\n\t\tmodule.exports.QUnit = QUnit;\n\t}\n\t\n\t// For CommonJS with exports, but without module.exports, like Rhino\n\tif ( typeof exports !== \"undefined\" && exports ) {\n\t\texports.QUnit = QUnit;\n\t}\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn QUnit;\n\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\tQUnit.config.autostart = false;\n\t}\n\t\n\t// Get a reference to the global object, like window in browsers\n\t}( ( function() {\n\t\treturn this;\n\t}() ) ) );\n\t\n\t( function() {\n\t\n\t// Only interact with URLs via window.location\n\tvar location = typeof window !== \"undefined\" && window.location;\n\tif ( !location ) {\n\t\treturn;\n\t}\n\t\n\tvar urlParams = getUrlParams();\n\t\n\tQUnit.urlParams = urlParams;\n\t\n\t// Match module/test by inclusion in an array\n\tQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\n\tQUnit.config.testId = [].concat( urlParams.testId || [] );\n\t\n\t// Exact case-insensitive match of the module name\n\tQUnit.config.module = urlParams.module;\n\t\n\t// Regular expression or case-insenstive substring match against \"moduleName: testName\"\n\tQUnit.config.filter = urlParams.filter;\n\t\n\t// Test order randomization\n\tif ( urlParams.seed === true ) {\n\t\n\t\t// Generate a random seed if the option is specified without a value\n\t\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n\t} else if ( urlParams.seed ) {\n\t\tQUnit.config.seed = urlParams.seed;\n\t}\n\t\n\t// Add URL-parameter-mapped config values with UI form rendering data\n\tQUnit.config.urlConfig.push(\n\t\t{\n\t\t\tid: \"hidepassed\",\n\t\t\tlabel: \"Hide passed tests\",\n\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t);\n\t\n\tQUnit.begin( function() {\n\t\tvar i, option,\n\t\t\turlConfig = QUnit.config.urlConfig;\n\t\n\t\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\t\n\t\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\t\toption = QUnit.config.urlConfig[ i ];\n\t\t\tif ( typeof option !== \"string\" ) {\n\t\t\t\toption = option.id;\n\t\t\t}\n\t\n\t\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tfunction getUrlParams() {\n\t\tvar i, param, name, value;\n\t\tvar urlParams = {};\n\t\tvar params = location.search.slice( 1 ).split( \"&\" );\n\t\tvar length = params.length;\n\t\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tif ( params[ i ] ) {\n\t\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\t\tname = decodeURIComponent( param[ 0 ] );\n\t\n\t\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t\tvalue = param.length === 1 ||\n\t\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t\t} else {\n\t\t\t\t\turlParams[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn urlParams;\n\t}\n\t\n\t// Don't load the HTML Reporter on non-browser environments\n\tif ( typeof window === \"undefined\" || !window.document ) {\n\t\treturn;\n\t}\n\t\n\tQUnit.init = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tvar config = QUnit.config,\n\t\tdocument = window.document,\n\t\tcollapseNext = false,\n\t\thasOwn = Object.prototype.hasOwnProperty,\n\t\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\t\tmoduleId: undefined, testId: undefined } ),\n\t\tdefined = {\n\t\t\tsessionStorage: ( function() {\n\t\t\t\tvar x = \"qunit-test-string\";\n\t\t\t\ttry {\n\t\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\t\treturn true;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}() )\n\t\t},\n\t\tmodulesList = [];\n\t\n\t// Escape text for attribute or text content.\n\tfunction escapeText( s ) {\n\t\tif ( !s ) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = s + \"\";\n\t\n\t\t// Both single quotes and double quotes (for attributes)\n\t\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\t\tswitch ( s ) {\n\t\t\tcase \"'\":\n\t\t\t\treturn \"&#039;\";\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn \"&quot;\";\n\t\t\tcase \"<\":\n\t\t\t\treturn \"&lt;\";\n\t\t\tcase \">\":\n\t\t\t\treturn \"&gt;\";\n\t\t\tcase \"&\":\n\t\t\t\treturn \"&amp;\";\n\t\t\t}\n\t\t} );\n\t}\n\t\n\tfunction addEvent( elem, type, fn ) {\n\t\telem.addEventListener( type, fn, false );\n\t}\n\t\n\tfunction removeEvent( elem, type, fn ) {\n\t\telem.removeEventListener( type, fn, false );\n\t}\n\t\n\tfunction addEvents( elems, type, fn ) {\n\t\tvar i = elems.length;\n\t\twhile ( i-- ) {\n\t\t\taddEvent( elems[ i ], type, fn );\n\t\t}\n\t}\n\t\n\tfunction hasClass( elem, name ) {\n\t\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n\t}\n\t\n\tfunction addClass( elem, name ) {\n\t\tif ( !hasClass( elem, name ) ) {\n\t\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t\t}\n\t}\n\t\n\tfunction toggleClass( elem, name, force ) {\n\t\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\t\taddClass( elem, name );\n\t\t} else {\n\t\t\tremoveClass( elem, name );\n\t\t}\n\t}\n\t\n\tfunction removeClass( elem, name ) {\n\t\tvar set = \" \" + elem.className + \" \";\n\t\n\t\t// Class name may appear multiple times\n\t\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t\t}\n\t\n\t\t// Trim for prettiness\n\t\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n\t}\n\t\n\tfunction id( name ) {\n\t\treturn document.getElementById && document.getElementById( name );\n\t}\n\t\n\tfunction getUrlConfigHtml() {\n\t\tvar i, j, val,\n\t\t\tescaped, escapedTooltip,\n\t\t\tselection = false,\n\t\t\turlConfig = config.urlConfig,\n\t\t\turlConfigHtml = \"\";\n\t\n\t\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\t\n\t\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\t\tval = config.urlConfig[ i ];\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\tval = {\n\t\t\t\t\tid: val,\n\t\t\t\t\tlabel: val\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tescaped = escapeText( val.id );\n\t\t\tescapedTooltip = escapeText( val.tooltip );\n\t\n\t\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t\t} else {\n\t\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\t\n\t\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t\turlConfigHtml += \"</select>\";\n\t\t\t}\n\t\t}\n\t\n\t\treturn urlConfigHtml;\n\t}\n\t\n\t// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n\t// Updates the URL with the new state of `config.urlConfig` values.\n\tfunction toolbarChanged() {\n\t\tvar updatedUrl, value, tests,\n\t\t\tfield = this,\n\t\t\tparams = {};\n\t\n\t\t// Detect if field is a select menu or a checkbox\n\t\tif ( \"selectedIndex\" in field ) {\n\t\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t\t} else {\n\t\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t\t}\n\t\n\t\tparams[ field.name ] = value;\n\t\tupdatedUrl = setUrl( params );\n\t\n\t\t// Check if we can apply the change without a page refresh\n\t\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\t\tQUnit.urlParams[ field.name ] = value;\n\t\t\tconfig[ field.name ] = value || false;\n\t\t\ttests = id( \"qunit-tests\" );\n\t\t\tif ( tests ) {\n\t\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t\t}\n\t\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t\t} else {\n\t\t\twindow.location = updatedUrl;\n\t\t}\n\t}\n\t\n\tfunction setUrl( params ) {\n\t\tvar key, arrValue, i,\n\t\t\tquerystring = \"?\",\n\t\t\tlocation = window.location;\n\t\n\t\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\t\n\t\tfor ( key in params ) {\n\t\n\t\t\t// Skip inherited or undefined properties\n\t\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\t\n\t\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tquerystring += \"&\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn location.protocol + \"//\" + location.host +\n\t\t\tlocation.pathname + querystring.slice( 0, -1 );\n\t}\n\t\n\tfunction applyUrlParams() {\n\t\tvar i,\n\t\t\tselectedModules = [],\n\t\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\t\tfilter = id( \"qunit-filter-input\" ).value;\n\t\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\tif ( modulesList[ i ].checked ) {\n\t\t\t\tselectedModules.push( modulesList[ i ].getAttribute( \"module-id\" ) );\n\t\t\t}\n\t\t}\n\t\n\t\twindow.location = setUrl( {\n\t\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\t\n\t\t\t// Remove module and testId filter\n\t\t\tmodule: undefined,\n\t\t\ttestId: undefined\n\t\t} );\n\t}\n\t\n\tfunction toolbarUrlConfigContainer() {\n\t\tvar urlConfigContainer = document.createElement( \"span\" );\n\t\n\t\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\t\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\t\n\t\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\t\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\t\n\t\treturn urlConfigContainer;\n\t}\n\t\n\tfunction toolbarLooseFilter() {\n\t\tvar filter = document.createElement( \"form\" ),\n\t\t\tlabel = document.createElement( \"label\" ),\n\t\t\tinput = document.createElement( \"input\" ),\n\t\t\tbutton = document.createElement( \"button\" );\n\t\n\t\taddClass( filter, \"qunit-filter\" );\n\t\n\t\tlabel.innerHTML = \"Filter: \";\n\t\n\t\tinput.type = \"text\";\n\t\tinput.value = config.filter || \"\";\n\t\tinput.name = \"filter\";\n\t\tinput.id = \"qunit-filter-input\";\n\t\n\t\tbutton.innerHTML = \"Go\";\n\t\n\t\tlabel.appendChild( input );\n\t\n\t\tfilter.appendChild( label );\n\t\tfilter.appendChild( button );\n\t\taddEvent( filter, \"submit\", function( ev ) {\n\t\t\tapplyUrlParams();\n\t\n\t\t\tif ( ev && ev.preventDefault ) {\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t} );\n\t\n\t\treturn filter;\n\t}\n\t\n\tfunction moduleDropDownHtml () {\n\t\tvar i,\n\t\t\tdropDownHtml = \"\";\n\t\n\t\tif ( !config.modules.length ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\t\tdropDownHtml += \"<li><label><input type='checkbox' \" +\n\t\t\t\t\"module-id='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t\t( config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1 ? \" checked\" : \"\" ) +\n\t\t\t\t\">\" + escapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t\t}\n\t\t}\n\t\treturn dropDownHtml;\n\t}\n\t\n\tfunction toolbarModuleFilter () {\n\t\tvar dropDownHtml = moduleDropDownHtml(),\n\t\t\ttoolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\t\tlabel = document.createElement( \"label\" ),\n\t\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\t\tmoduleFilterComponent = document.createElement( \"div\" ),\n\t\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\t\tdropDownContainer = document.createElement( \"div\" ),\n\t\t\tdropDownList = document.createElement( \"ul\" ),\n\t\t\tclearFilter = document.createElement( \"span\" );\n\t\n\t\tif ( !toolbar || !dropDownHtml ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tmoduleSearch.placeholder = \"Select modules\";\n\t\n\t\tlabel.innerHTML = \"Module: \";\n\t\n\t\tclearFilter.id = \"clear-module-filter\";\n\t\tclearFilter.innerHTML = \"<span id='clear-module-filter-text'>All modules</span><hr/>\";\n\t\n\t\tclearFilter.onclick = function() {\n\t\t\tvar i,\n\t\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" );\n\t\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\t\tmodulesList[ i ].checked = false;\n\t\t\t}\n\t\t\tapplyUrlParams();\n\t\t};\n\t\n\t\tmoduleFilter.id = \"qunit-modulefilter-container\";\n\t\tmoduleFilterComponent.id = \"qunit-modulefilter-component\";\n\t\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\t\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\t\tdropDownContainer.id = \"qunit-modulefilter-dropdown-container\";\n\t\n\t\tdropDownContainer.style.display = \"none\";\n\t\n\t\tdropDownContainer.appendChild( clearFilter );\n\t\tmoduleFilter.appendChild( label );\n\t\tmoduleFilter.appendChild( moduleFilterComponent );\n\t\tmoduleFilterComponent.appendChild( moduleSearch );\n\t\tmoduleFilterComponent.appendChild( dropDownContainer ) ;\n\t\n\t\t// Enables show/hide for the dropdown\n\t\taddEvent( moduleSearch, \"focus\", function() {\n\t\t\tvar dropDownList = id( \"qunit-modulefilter-dropdown-container\" );\n\t\t\tif ( dropDownList.style.display === \"none\" ) {\n\t\t\t\taddEvent( document, \"click\", function hideHandler( e )  {\n\t\t\t\t\tif ( !id( \"qunit-modulefilter-container\" ).contains( e.target ) ) {\n\t\t\t\t\t\tid( \"qunit-modulefilter-dropdown-container\" ).style.display = \"none\";\n\t\t\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tdropDownList.style.display = \"block\";\n\t\t\t}\n\t\t} );\n\t\n\t\t// Enables search to the module filter\n\t\taddEvent( moduleSearch, \"input\", function() {\n\t\t\tvar i,\n\t\t\tmoduleText,\n\t\t\tsearchText = this.value.toLowerCase(),\n\t\t\tlistItems = id( \"qunit-modulefilter-dropdown-list\" ).children;\n\t\n\t\t\tif ( !searchText ) {\n\t\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\t\tmoduleText = listItems[ i ].textContent.toLowerCase();\n\t\t\t\t\tif ( moduleText.indexOf( searchText ) > -1 ) {\n\t\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistItems[ i ].style.display = \"none\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tdropDownList.innerHTML = dropDownHtml;\n\t\tdropDownContainer.appendChild( dropDownList );\n\t\ttoolbar.appendChild( moduleFilter );\n\t}\n\t\n\tfunction appendToolbar() {\n\t\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\t\n\t\tif ( toolbar ) {\n\t\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\t\ttoolbarModuleFilter();\n\t\t}\n\t}\n\t\n\tfunction appendHeader() {\n\t\tvar header = id( \"qunit-header\" );\n\t\n\t\tif ( header ) {\n\t\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\t\"</a> \";\n\t\t}\n\t}\n\t\n\tfunction appendBanner() {\n\t\tvar banner = id( \"qunit-banner\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\t}\n\t\n\tfunction appendTestResults() {\n\t\tvar tests = id( \"qunit-tests\" ),\n\t\t\tresult = id( \"qunit-testresult\" );\n\t\n\t\tif ( result ) {\n\t\t\tresult.parentNode.removeChild( result );\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\ttests.innerHTML = \"\";\n\t\t\tresult = document.createElement( \"p\" );\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t\t}\n\t}\n\t\n\tfunction storeFixture() {\n\t\tvar fixture = id( \"qunit-fixture\" );\n\t\tif ( fixture ) {\n\t\t\tconfig.fixture = fixture.innerHTML;\n\t\t}\n\t}\n\t\n\tfunction appendFilteredTest() {\n\t\tvar testId = QUnit.config.testId;\n\t\tif ( !testId || testId.length <= 0 ) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\t\tescapeText( unfilteredUrl ) +\n\t\t\t\"'>Run all tests</a></div>\";\n\t}\n\t\n\tfunction appendUserAgent() {\n\t\tvar userAgent = id( \"qunit-userAgent\" );\n\t\n\t\tif ( userAgent ) {\n\t\t\tuserAgent.innerHTML = \"\";\n\t\t\tuserAgent.appendChild(\n\t\t\t\tdocument.createTextNode(\n\t\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\t\n\tfunction appendInterface() {\n\t\tvar qunit = id( \"qunit\" );\n\t\n\t\tif ( qunit ) {\n\t\t\tqunit.innerHTML =\n\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\tappendFilteredTest() +\n\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t}\n\t\n\t\tappendHeader();\n\t\tappendBanner();\n\t\tappendTestResults();\n\t\tappendUserAgent();\n\t\tappendToolbar();\n\t}\n\t\n\tfunction appendTestsList( modules ) {\n\t\tvar i, l, x, z, test, moduleObj;\n\t\n\t\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\t\tmoduleObj = modules[ i ];\n\t\n\t\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\t\ttest = moduleObj.tests[ x ];\n\t\n\t\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction appendTest( name, testId, moduleName ) {\n\t\tvar title, rerunTrigger, testBlock, assertList,\n\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\tif ( !tests ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttitle = document.createElement( \"strong\" );\n\t\ttitle.innerHTML = getNameHtml( name, moduleName );\n\t\n\t\trerunTrigger = document.createElement( \"a\" );\n\t\trerunTrigger.innerHTML = \"Rerun\";\n\t\trerunTrigger.href = setUrl( { testId: testId } );\n\t\n\t\ttestBlock = document.createElement( \"li\" );\n\t\ttestBlock.appendChild( title );\n\t\ttestBlock.appendChild( rerunTrigger );\n\t\ttestBlock.id = \"qunit-test-output-\" + testId;\n\t\n\t\tassertList = document.createElement( \"ol\" );\n\t\tassertList.className = \"qunit-assert-list\";\n\t\n\t\ttestBlock.appendChild( assertList );\n\t\n\t\ttests.appendChild( testBlock );\n\t}\n\t\n\t// HTML Reporter initialization and load\n\tQUnit.begin( function( details ) {\n\t\tvar i, moduleObj, tests;\n\t\n\t\t// Sort modules by name for the picker\n\t\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\t\tmoduleObj = details.modules[ i ];\n\t\t\tif ( moduleObj.name ) {\n\t\t\t\tmodulesList.push( moduleObj.name );\n\t\t\t}\n\t\t}\n\t\tmodulesList.sort( function( a, b ) {\n\t\t\treturn a.localeCompare( b );\n\t\t} );\n\t\n\t\t// Capture fixture HTML from the page\n\t\tstoreFixture();\n\t\n\t\t// Initialize QUnit elements\n\t\tappendInterface();\n\t\tappendTestsList( details.modules );\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests && config.hidepassed ) {\n\t\t\taddClass( tests, \"hidepass\" );\n\t\t}\n\t} );\n\t\n\tQUnit.done( function( details ) {\n\t\tvar i, key,\n\t\t\tbanner = id( \"qunit-banner\" ),\n\t\t\ttests = id( \"qunit-tests\" ),\n\t\t\thtml = [\n\t\t\t\t\"Tests completed in \",\n\t\t\t\tdetails.runtime,\n\t\t\t\t\" milliseconds.<br />\",\n\t\t\t\t\"<span class='passed'>\",\n\t\t\t\tdetails.passed,\n\t\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\t\tdetails.total,\n\t\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\t\tdetails.failed,\n\t\t\t\t\"</span> failed.\"\n\t\t\t].join( \"\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t\t}\n\t\n\t\tif ( config.altertitle && document.title ) {\n\t\n\t\t\t// Show  for good,  for bad suite result in title\n\t\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\t\tdocument.title = [\n\t\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t\t].join( \" \" );\n\t\t}\n\t\n\t\t// Clear own sessionStorage items if all tests passed\n\t\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\t\tkey = sessionStorage.key( i++ );\n\t\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Scroll back to top to show results\n\t\tif ( config.scrolltop && window.scrollTo ) {\n\t\t\twindow.scrollTo( 0, 0 );\n\t\t}\n\t} );\n\t\n\tfunction getNameHtml( name, module ) {\n\t\tvar nameHtml = \"\";\n\t\n\t\tif ( module ) {\n\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t\t}\n\t\n\t\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\t\n\t\treturn nameHtml;\n\t}\n\t\n\tQUnit.testStart( function( details ) {\n\t\tvar running, testBlock, bad;\n\t\n\t\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\t\tif ( testBlock ) {\n\t\t\ttestBlock.className = \"running\";\n\t\t} else {\n\t\n\t\t\t// Report later registered tests\n\t\t\tappendTest( details.name, details.testId, details.module );\n\t\t}\n\t\n\t\trunning = id( \"qunit-testresult\" );\n\t\tif ( running ) {\n\t\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\n\t\t\trunning.innerHTML = ( bad ?\n\t\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\t\"Running: <br />\" ) +\n\t\t\t\tgetNameHtml( details.name, details.module );\n\t\t}\n\t\n\t} );\n\t\n\tfunction stripHtml( string ) {\n\t\n\t\t// Strip tags, html entity and whitespaces\n\t\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n\t}\n\t\n\tQUnit.log( function( details ) {\n\t\tvar assertList, assertLi,\n\t\t\tmessage, expected, actual, diff,\n\t\t\tshowDiff = false,\n\t\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\t\n\t\tif ( !testItem ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\t\n\t\t// The pushFailure doesn't provide details.expected\n\t\t// when it calls, it's implicit to also not show expected and diff stuff\n\t\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\t\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\t\tif ( details.negative ) {\n\t\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t\t} else {\n\t\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t\t}\n\t\n\t\t\tactual = QUnit.dump.parse( details.actual );\n\t\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\t\tescapeText( expected ) +\n\t\t\t\t\"</pre></td></tr>\";\n\t\n\t\t\tif ( actual !== expected ) {\n\t\n\t\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\t\n\t\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t\t}\n\t\n\t\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\t\tif ( showDiff ) {\n\t\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t\t} else {\n\t\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\t\" serialization</td></tr>\";\n\t\t\t}\n\t\n\t\t\tif ( details.source ) {\n\t\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\tmessage += \"</table>\";\n\t\n\t\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t\t} else if ( !details.result && details.source ) {\n\t\t\tmessage += \"<table>\" +\n\t\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\t\"</table>\";\n\t\t}\n\t\n\t\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\t\n\t\tassertLi = document.createElement( \"li\" );\n\t\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\t\tassertLi.innerHTML = message;\n\t\tassertList.appendChild( assertLi );\n\t} );\n\t\n\tQUnit.testDone( function( details ) {\n\t\tvar testTitle, time, testItem, assertList,\n\t\t\tgood, bad, testCounts, skipped, sourceName,\n\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\tif ( !tests ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\t\n\t\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\t\n\t\tgood = details.passed;\n\t\tbad = details.failed;\n\t\n\t\t// Store result when possible\n\t\tif ( config.reorder && defined.sessionStorage ) {\n\t\t\tif ( bad ) {\n\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t\t} else {\n\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( bad === 0 ) {\n\t\n\t\t\t// Collapse the passing tests\n\t\t\taddClass( assertList, \"qunit-collapsed\" );\n\t\t} else if ( bad && config.collapse && !collapseNext ) {\n\t\n\t\t\t// Skip collapsing the first failing test\n\t\t\tcollapseNext = true;\n\t\t} else {\n\t\n\t\t\t// Collapse remaining tests\n\t\t\taddClass( assertList, \"qunit-collapsed\" );\n\t\t}\n\t\n\t\t// The testItem.firstChild is the test name\n\t\ttestTitle = testItem.firstChild;\n\t\n\t\ttestCounts = bad ?\n\t\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\t\"\";\n\t\n\t\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\t\tdetails.assertions.length + \")</b>\";\n\t\n\t\tif ( details.skipped ) {\n\t\t\ttestItem.className = \"skipped\";\n\t\t\tskipped = document.createElement( \"em\" );\n\t\t\tskipped.className = \"qunit-skipped-label\";\n\t\t\tskipped.innerHTML = \"skipped\";\n\t\t\ttestItem.insertBefore( skipped, testTitle );\n\t\t} else {\n\t\t\taddEvent( testTitle, \"click\", function() {\n\t\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t\t} );\n\t\n\t\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\t\n\t\t\ttime = document.createElement( \"span\" );\n\t\t\ttime.className = \"runtime\";\n\t\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\t\ttestItem.insertBefore( time, assertList );\n\t\t}\n\t\n\t\t// Show the source of the test when showing assertions\n\t\tif ( details.source ) {\n\t\t\tsourceName = document.createElement( \"p\" );\n\t\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\t\taddClass( sourceName, \"qunit-source\" );\n\t\t\tif ( bad === 0 ) {\n\t\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t\t}\n\t\t\taddEvent( testTitle, \"click\", function() {\n\t\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t\t} );\n\t\t\ttestItem.appendChild( sourceName );\n\t\t}\n\t} );\n\t\n\t// Avoid readyState issue with phantomjs\n\t// Ref: #818\n\tvar notPhantom = ( function( p ) {\n\t\treturn !( p && p.version && p.version.major > 0 );\n\t} )( window.phantom );\n\t\n\tif ( notPhantom && document.readyState === \"complete\" ) {\n\t\tQUnit.load();\n\t} else {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n\t\n\t/*\n\t * This file is a modified version of google-diff-match-patch's JavaScript implementation\n\t * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n\t * modifications are licensed as more fully set forth in LICENSE.txt.\n\t *\n\t * The original source of google-diff-match-patch is attributable and licensed as follows:\n\t *\n\t * Copyright 2006 Google Inc.\n\t * https://code.google.com/p/google-diff-match-patch/\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * https://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * More Info:\n\t *  https://code.google.com/p/google-diff-match-patch/\n\t *\n\t * Usage: QUnit.diff(expected, actual)\n\t *\n\t */\n\tQUnit.diff = ( function() {\n\t\tfunction DiffMatchPatch() {\n\t\t}\n\t\n\t\t//  DIFF FUNCTIONS\n\t\n\t\t/**\n\t\t * The data structure representing a diff is an array of tuples:\n\t\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t\t */\n\t\tvar DIFF_DELETE = -1,\n\t\t\tDIFF_INSERT = 1,\n\t\t\tDIFF_EQUAL = 0;\n\t\n\t\t/**\n\t\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t\t * any common prefix or suffix off the texts before diffing.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t\t *     then don't run a line-level diff first to identify the changed areas.\n\t\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\t\tvar deadline, checklines, commonlength,\n\t\t\t\tcommonprefix, commonsuffix, diffs;\n\t\n\t\t\t// The diff must be complete in up to 1 second.\n\t\t\tdeadline = ( new Date() ).getTime() + 1000;\n\t\n\t\t\t// Check for null inputs.\n\t\t\tif ( text1 === null || text2 === null ) {\n\t\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t\t}\n\t\n\t\t\t// Check for equality (speedup).\n\t\t\tif ( text1 === text2 ) {\n\t\t\t\tif ( text1 ) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\t\toptChecklines = true;\n\t\t\t}\n\t\n\t\t\tchecklines = optChecklines;\n\t\n\t\t\t// Trim off common prefix (speedup).\n\t\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\t\ttext1 = text1.substring( commonlength );\n\t\t\ttext2 = text2.substring( commonlength );\n\t\n\t\t\t// Trim off common suffix (speedup).\n\t\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\t\n\t\t\t// Compute the diff on the middle block.\n\t\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\t\n\t\t\t// Restore the prefix and suffix.\n\t\t\tif ( commonprefix ) {\n\t\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t\t}\n\t\t\tif ( commonsuffix ) {\n\t\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t\t}\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\treturn diffs;\n\t\t};\n\t\n\t\t/**\n\t\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\n\t\t\t// Is there an insertion operation before the last equality.\n\t\t\tpreIns = false;\n\t\n\t\t\t// Is there a deletion operation before the last equality.\n\t\t\tpreDel = false;\n\t\n\t\t\t// Is there an insertion operation after the last equality.\n\t\t\tpostIns = false;\n\t\n\t\t\t// Is there a deletion operation after the last equality.\n\t\t\tpostDel = false;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\n\t\t\t\t// Equality found.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\t\n\t\t\t\t\t\t// Candidate found.\n\t\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t}\n\t\t\t\t\tpostIns = postDel = false;\n\t\n\t\t\t\t// An insertion or deletion.\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\t\tpostDel = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostIns = true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * Five types to be split:\n\t\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t\t */\n\t\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\t\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tif ( preIns && preDel ) {\n\t\n\t\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Convert a diff array into a pretty HTML report.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t * @param {integer} string to be beautified.\n\t\t * @return {string} HTML representation.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\t\tvar op, data, x,\n\t\t\t\thtml = [];\n\t\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\t\tswitch ( op ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn html.join( \"\" );\n\t\t};\n\t\n\t\t/**\n\t\t * Determine the common prefix of two strings.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the start of each\n\t\t *     string.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\n\t\t\t// Quick check for common null cases.\n\t\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min( text1.length, text2.length );\n\t\t\tpointermid = pointermax;\n\t\t\tpointerstart = 0;\n\t\t\twhile ( pointermin < pointermid ) {\n\t\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerstart = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\t\n\t\t/**\n\t\t * Determine the common suffix of two strings.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the end of each string.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\n\t\t\t// Quick check for common null cases.\n\t\t\tif ( !text1 ||\n\t\t\t\t\t!text2 ||\n\t\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min( text1.length, text2.length );\n\t\t\tpointermid = pointermax;\n\t\t\tpointerend = 0;\n\t\t\twhile ( pointermin < pointermid ) {\n\t\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerend = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\t\n\t\t/**\n\t\t * Find the differences between two texts.  Assumes that the texts do not\n\t\t * have any common prefix or suffix.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t\t *     line-level diff first to identify the changed areas.\n\t\t *     If true, then run a faster, slightly less optimal diff.\n\t\t * @param {number} deadline Time when the diff should be complete by.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\t\tmidCommon, diffsA, diffsB;\n\t\n\t\t\tif ( !text1 ) {\n\t\n\t\t\t\t// Just add some text (speedup).\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\tif ( !text2 ) {\n\t\n\t\t\t\t// Just delete some text (speedup).\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\ti = longtext.indexOf( shorttext );\n\t\t\tif ( i !== -1 ) {\n\t\n\t\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\t\tdiffs = [\n\t\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t\t];\n\t\n\t\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t}\n\t\t\t\treturn diffs;\n\t\t\t}\n\t\n\t\t\tif ( shorttext.length === 1 ) {\n\t\n\t\t\t\t// Single character string.\n\t\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\t// Check to see if the problem can be split in two.\n\t\t\thm = this.diffHalfMatch( text1, text2 );\n\t\t\tif ( hm ) {\n\t\n\t\t\t\t// A half-match was found, sort out the return data.\n\t\t\t\ttext1A = hm[ 0 ];\n\t\t\t\ttext1B = hm[ 1 ];\n\t\t\t\ttext2A = hm[ 2 ];\n\t\t\t\ttext2B = hm[ 3 ];\n\t\t\t\tmidCommon = hm[ 4 ];\n\t\n\t\t\t\t// Send both pairs off for separate processing.\n\t\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\t\n\t\t\t\t// Merge the results.\n\t\t\t\treturn diffsA.concat( [\n\t\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t\t], diffsB );\n\t\t\t}\n\t\n\t\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t\t}\n\t\n\t\t\treturn this.diffBisect( text1, text2, deadline );\n\t\t};\n\t\n\t\t/**\n\t\t * Do the two texts share a substring which is at least half the length of the\n\t\t * longer text?\n\t\t * This speedup can produce non-minimal diffs.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t\t *     text2 and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\t\tvar longtext, shorttext, dmp,\n\t\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\t\thm1, hm2, hm;\n\t\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\t\treturn null; // Pointless.\n\t\t\t}\n\t\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\t\n\t\t\t/**\n\t\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t\t * is at least half the length of longtext?\n\t\t\t * Closure, but does not reference any external variables.\n\t\t\t * @param {string} longtext Longer string.\n\t\t\t * @param {string} shorttext Shorter string.\n\t\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t\t * @private\n\t\t\t */\n\t\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\n\t\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\t\tj = -1;\n\t\t\t\tbestCommon = \"\";\n\t\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// First check if the second quarter is the seed for a half-match.\n\t\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\t\tMath.ceil( longtext.length / 4 ) );\n\t\n\t\t\t// Check again based on the third quarter.\n\t\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\t\tif ( !hm1 && !hm2 ) {\n\t\t\t\treturn null;\n\t\t\t} else if ( !hm2 ) {\n\t\t\t\thm = hm1;\n\t\t\t} else if ( !hm1 ) {\n\t\t\t\thm = hm2;\n\t\t\t} else {\n\t\n\t\t\t\t// Both matched.  Select the longest.\n\t\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t\t}\n\t\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A, text1B, text2A, text2B;\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\ttext1A = hm[ 0 ];\n\t\t\t\ttext1B = hm[ 1 ];\n\t\t\t\ttext2A = hm[ 2 ];\n\t\t\t\ttext2B = hm[ 3 ];\n\t\t\t} else {\n\t\t\t\ttext2A = hm[ 0 ];\n\t\t\t\ttext2B = hm[ 1 ];\n\t\t\t\ttext1A = hm[ 2 ];\n\t\t\t\ttext1B = hm[ 3 ];\n\t\t\t}\n\t\t\tmidCommon = hm[ 4 ];\n\t\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t\t};\n\t\n\t\t/**\n\t\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t\t * greater accuracy.\n\t\t * This speedup can produce non-minimal diffs.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} deadline Time when the diff should be complete by.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\t\tcountDelete, textInsert, textDelete, j;\n\t\n\t\t\t// Scan the text on a line-by-line basis first.\n\t\t\ta = this.diffLinesToChars( text1, text2 );\n\t\t\ttext1 = a.chars1;\n\t\t\ttext2 = a.chars2;\n\t\t\tlinearray = a.lineArray;\n\t\n\t\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\t\n\t\t\t// Convert the diff back to original text.\n\t\t\tthis.diffCharsToLines( diffs, linearray );\n\t\n\t\t\t// Eliminate freak matches (e.g. blank lines)\n\t\t\tthis.diffCleanupSemantic( diffs );\n\t\n\t\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t\t// Add a dummy entry at the end.\n\t\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\t\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\n\t\t\treturn diffs;\n\t\t};\n\t\n\t\t/**\n\t\t * Find the 'middle snake' of a diff, split the problem in two\n\t\t * and return the recursively constructed diff.\n\t\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} deadline Time at which to bail if not yet complete.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\t\tvOffset = maxD;\n\t\t\tvLength = 2 * maxD;\n\t\t\tv1 = new Array( vLength );\n\t\t\tv2 = new Array( vLength );\n\t\n\t\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t\t// integers and undefined.\n\t\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\t\tv1[ x ] = -1;\n\t\t\t\tv2[ x ] = -1;\n\t\t\t}\n\t\t\tv1[ vOffset + 1 ] = 0;\n\t\t\tv2[ vOffset + 1 ] = 0;\n\t\t\tdelta = text1Length - text2Length;\n\t\n\t\t\t// If the total number of characters is odd, then the front path will collide\n\t\t\t// with the reverse path.\n\t\t\tfront = ( delta % 2 !== 0 );\n\t\n\t\t\t// Offsets for start and end of k loop.\n\t\t\t// Prevents mapping of space beyond the grid.\n\t\t\tk1start = 0;\n\t\t\tk1end = 0;\n\t\t\tk2start = 0;\n\t\t\tk2end = 0;\n\t\t\tfor ( d = 0; d < maxD; d++ ) {\n\t\n\t\t\t\t// Bail out if deadline is reached.\n\t\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\t\t\t// Walk the front path one step.\n\t\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty1 = x1 - k1;\n\t\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\t\tx1++;\n\t\t\t\t\t\ty1++;\n\t\t\t\t\t}\n\t\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\t\tif ( x1 > text1Length ) {\n\t\n\t\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\t\tk1end += 2;\n\t\t\t\t\t} else if ( y1 > text2Length ) {\n\t\n\t\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\t\tk1start += 2;\n\t\t\t\t\t} else if ( front ) {\n\t\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\t\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Walk the reverse path one step.\n\t\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty2 = x2 - k2;\n\t\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\t\tx2++;\n\t\t\t\t\t\ty2++;\n\t\t\t\t\t}\n\t\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\t\tif ( x2 > text1Length ) {\n\t\n\t\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\t\tk2end += 2;\n\t\t\t\t\t} else if ( y2 > text2Length ) {\n\t\n\t\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\t\tk2start += 2;\n\t\t\t\t\t} else if ( !front ) {\n\t\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Diff took too long and hit the deadline or\n\t\t\t// number of diffs equals number of characters, no commonality at all.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t};\n\t\n\t\t/**\n\t\t * Given the location of the 'middle snake', split the diff in two parts\n\t\t * and recurse.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} x Index of split point in text1.\n\t\t * @param {number} y Index of split point in text2.\n\t\t * @param {number} deadline Time at which to bail if not yet complete.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\t\ttext1a = text1.substring( 0, x );\n\t\t\ttext2a = text2.substring( 0, y );\n\t\t\ttext1b = text1.substring( x );\n\t\t\ttext2b = text2.substring( y );\n\t\n\t\t\t// Compute both diffs serially.\n\t\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\t\n\t\t\treturn diffs.concat( diffsb );\n\t\t};\n\t\n\t\t/**\n\t\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\n\t\t\t// Number of characters that changed prior to the equality.\n\t\t\tlengthInsertions1 = 0;\n\t\t\tlengthDeletions1 = 0;\n\t\n\t\t\t// Number of characters that changed after the equality.\n\t\t\tlengthInsertions2 = 0;\n\t\t\tlengthDeletions2 = 0;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else { // An insertion or deletion.\n\t\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t\t// sides of it.\n\t\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\t\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\n\t\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\t\tequalitiesLength--;\n\t\n\t\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\n\t\t\t\t\t\t// Reset the counters.\n\t\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\t// Normalize the diff.\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\n\t\t\t// Find any overlaps between deletions and insertions.\n\t\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\t\tpointer = 1;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\t\n\t\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\t\n\t\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Determine if the suffix of one string is the prefix of another.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the end of the first\n\t\t *     string and the start of the second string.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\t\tvar text1Length, text2Length, textLength,\n\t\t\t\tbest, length, pattern, found;\n\t\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\n\t\t\t// Eliminate the null case.\n\t\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Truncate the longer string.\n\t\t\tif ( text1Length > text2Length ) {\n\t\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t\t} else if ( text1Length < text2Length ) {\n\t\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t\t}\n\t\t\ttextLength = Math.min( text1Length, text2Length );\n\t\n\t\t\t// Quick check for the worst case.\n\t\t\tif ( text1 === text2 ) {\n\t\t\t\treturn textLength;\n\t\t\t}\n\t\n\t\t\t// Start by looking for a single character match\n\t\t\t// and increase length until no match is found.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\t\tbest = 0;\n\t\t\tlength = 1;\n\t\t\twhile ( true ) {\n\t\t\t\tpattern = text1.substring( textLength - length );\n\t\t\t\tfound = text2.indexOf( pattern );\n\t\t\t\tif ( found === -1 ) {\n\t\t\t\t\treturn best;\n\t\t\t\t}\n\t\t\t\tlength += found;\n\t\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\t\tbest = length;\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t\t *     An object containing the encoded text1, the encoded text2 and\n\t\t *     the array of unique strings.\n\t\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\t\tvar lineArray, lineHash, chars1, chars2;\n\t\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\t\n\t\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\t\tlineArray[ 0 ] = \"\";\n\t\n\t\t\t/**\n\t\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t\t * hashes where each Unicode character represents one line.\n\t\t\t * Modifies linearray and linehash through being a closure.\n\t\t\t * @param {string} text String to encode.\n\t\t\t * @return {string} Encoded string.\n\t\t\t * @private\n\t\t\t */\n\t\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\t\tchars = \"\";\n\t\n\t\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\t\tlineStart = 0;\n\t\t\t\tlineEnd = -1;\n\t\n\t\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\t\tlineArrayLength = lineArray.length;\n\t\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t\t}\n\t\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\t\tlineStart = lineEnd + 1;\n\t\n\t\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn chars;\n\t\t\t}\n\t\n\t\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\t\treturn {\n\t\t\t\tchars1: chars1,\n\t\t\t\tchars2: chars2,\n\t\t\t\tlineArray: lineArray\n\t\t\t};\n\t\t};\n\t\n\t\t/**\n\t\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t\t * text.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\t\tvar x, chars, text, y;\n\t\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\t\ttext = [];\n\t\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t\t}\n\t\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Reorder and merge like edit sections.  Merge equalities.\n\t\t * Any edit section can move as long as it doesn't cross an equality.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\t\tcommonlength, changes, diffPointer, position;\n\t\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\tcommonlength;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\t\n\t\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\t\n\t\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t\t}\n\t\n\t\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t\t// which can be shifted sideways to eliminate an equality.\n\t\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\t\tchanges = false;\n\t\t\tpointer = 1;\n\t\n\t\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\t\n\t\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\t\n\t\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\t\n\t\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\t};\n\t\n\t\treturn function( o, n ) {\n\t\t\tvar diff, output, text;\n\t\t\tdiff = new DiffMatchPatch();\n\t\t\toutput = diff.DiffMain( o, n );\n\t\t\tdiff.diffCleanupEfficiency( output );\n\t\t\ttext = diff.diffPrettyHtml( output );\n\t\n\t\t\treturn text;\n\t\t};\n\t}() );\n\t\n\t}() );\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(14)(module)))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _jsmocktool = __webpack_require__(3);\n\t\n\tvar _qunit = __webpack_require__(9);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n\t                                                                                                                                                           * @author mixed\n\t                                                                                                                                                           */\n\t\n\tvar global = window;\n\t\n\t(0, _qunit.module)('jsmock - Object type', {\n\t  'beforeEach': function beforeEach() {\n\t    this.mock = (0, _jsmocktool.mock)('RECEIVE');\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    RECEIVE = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('Must be first prameter is string or object', function (assert) {\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO');\n\t  // Then\n\t  assert.deepEqual(FOO, {});\n\t\n\t  // Given\n\t  var BAR = {};\n\t  // When\n\t  (0, _jsmocktool.mock)(BAR);\n\t  // Then\n\t  assert.deepEqual(BAR, BAR);\n\t});\n\t\n\t(0, _qunit.test)(\"Must be second parameter is 'instance','object',none.\", function (assert) {\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO2');\n\t  // Then\n\t  assert.deepEqual(FOO2, {});\n\t\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO3', _jsmocktool.mock.INSTANCE);\n\t  // Then\n\t  assert.equal(FOO3.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is set method of mock Object.', function (assert) {\n\t  // Given\n\t  var receiveMock = (0, _jsmocktool.mock)('RECEIVE');\n\t  // Then\n\t  receiveMock.should_receive('test');\n\t  // When\n\t  assert.equal(RECEIVE.test.constructor, Function);\n\t\n\t  // Given\n\t  var receiveMock2 = (0, _jsmocktool.mock)('RECEIVE2', _jsmocktool.mock.INSTANCE);\n\t  // Then\n\t  receiveMock2.should_receive('test');\n\t  // When\n\t  assert.equal(RECEIVE2.prototype.test.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('Return value of should_receive is MockMethod.', function (assert) {\n\t  // Given\n\t  var receive = (0, _jsmocktool.mock)('RECEIVE3');\n\t  // When\n\t  var mock_method = receive.should_receive('test');\n\t  // The MockMethod is private. so I can't test.\n\t  // Instead, I made a Ducktyping test(?).\n\t  // I believe correct when The return value of should_receive have and_return function.\n\t  // ok(stub_obj instanceof MockMethod);\n\t  // Then\n\t  assert.equal(mock_method.and_return.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The and_return is  setting value to return.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('RECEIVE4').should_receive('test').and_return(3);\n\t  // When\n\t  var returnVal = RECEIVE4.test();\n\t  // Then\n\t  assert.equal(returnVal, 3);\n\t});\n\t\n\t(0, _qunit.test)('If use with_param, mock will return value when same param.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('RECEIVE4').should_receive('test').with_param(1, 2).and_return(4);\n\t  // When\n\t  var returnVal = RECEIVE4.test(1, 2);\n\t  // Then\n\t  assert.equal(returnVal, 4);\n\t});\n\t\n\t(0, _qunit.test)('The Mock must be work mock before set parameter when add new parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').and_return(3);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(4);\n\t  this.mock.should_receive('test').with_param(1, 2, 3).and_return(5);\n\t  // When\n\t  var noneParam = RECEIVE.test();\n\t  var oneParam = RECEIVE.test(1, 2);\n\t  var twoParam = RECEIVE.test(1, 2, 3);\n\t  // Then\n\t  assert.equal(noneParam, 3);\n\t  assert.equal(oneParam, 4);\n\t  assert.equal(twoParam, 5);\n\t});\n\t\n\t(0, _qunit.test)('The Mock must be change return value when add same parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').and_return(3);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(4);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(5);\n\t  // When\n\t  var noneParam = RECEIVE.test();\n\t  var twoParam = RECEIVE.test(1, 2);\n\t  // Then\n\t  assert.equal(noneParam, 3);\n\t  assert.equal(twoParam, 5);\n\t});\n\t\n\t(0, _qunit.test)('The add_throw is throw exception when match param.', function (assert) {\n\t  // Given\n\t  var error_message = '';\n\t  this.mock.should_receive('test2').and_throw(new Error('and_throw test.'));\n\t  // When\n\t  try {\n\t    RECEIVE.test2();\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test.');\n\t});\n\t\n\t(0, _qunit.test)('If set with_param of and_throw then throw exception when match parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2.'));\n\t  var error_message = '';\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test2.');\n\t});\n\t\n\t(0, _qunit.test)('The and_throw is well work when change parameter', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param().and_throw(new Error('and_throw test'));\n\t  this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2'));\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test3'));\n\t  var error_message = '';\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2();\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test');\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test2');\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test3');\n\t});\n\t(0, _qunit.test)('The and_throw throw new exception when some function, same parameter, change exception.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test'));\n\t  var error_message = '';\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test');\n\t\n\t  // Then\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('change throw'));\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // When\n\t  assert.equal(error_message, 'change throw');\n\t});\n\t\n\t(0, _qunit.test)('The and_function run function when set new function', function (assert) {\n\t\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').and_function(function () {\n\t    that.mock_test1 = 'first';\n\t  });\n\t  // Then\n\t  RECEIVE.test3();\n\t  // When\n\t  assert.equal(that.mock_test1, 'first');\n\t});\n\t\n\t(0, _qunit.test)('If set a with_param then the and_functon run function when only match parameter.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param(1, 2).and_function(function () {\n\t    that.mock_test2 = 'second';\n\t  });\n\t  // Then\n\t  RECEIVE.test3(1, 2);\n\t  // When\n\t  assert.equal(that.mock_test2, 'second');\n\t});\n\t\n\t(0, _qunit.test)('Then and_function is well work when same function change parameter.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param().and_function(function () {\n\t    that.mock_test1 = 'first';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2).and_function(function () {\n\t    that.mock_test2 = 'second';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'third';\n\t  });\n\t  // When\n\t  RECEIVE.test3();\n\t  // Then\n\t  assert.equal(that.mock_test1, 'first');\n\t\n\t  // When\n\t  RECEIVE.test3(1, 2);\n\t  // Then\n\t  assert.equal(that.mock_test2, 'second');\n\t\n\t  // When\n\t  RECEIVE.test3(1, 2, 3);\n\t  // Then\n\t  assert.equal(that.mock_test3, 'third');\n\t});\n\t(0, _qunit.test)('The and_function run new function when some function, same parameter, change and_function.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'third';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'change third';\n\t  });\n\t  // When\n\t  RECEIVE.test3(1, 2, 3);\n\t  // Then\n\t  assert.equal(that.mock_test3, 'change third');\n\t});\n\t(0, _qunit.test)('If use Mock.anything when run function without reference to parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').with_param(1, 2).and_return('1');\n\t  this.mock.should_receive('test').with_param(1, 2, _jsmocktool.mock.anything()).and_return('2');\n\t  this.mock.should_receive('test').with_param(1, 2, _jsmocktool.mock.anything(), _jsmocktool.mock.anything()).and_return('3');\n\t\n\t  // When, Then\n\t  assert.equal(RECEIVE.test(1, 2), '1');\n\t  assert.equal(RECEIVE.test(1, 2, 3), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 1), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 4), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 4, 5), '3');\n\t  assert.equal(RECEIVE.test(1, 2, 4, 6), '3');\n\t});\n\t\n\t//    'param anything           .':function(){\n\t//      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"5\");\n\t//      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"5\");\n\t\n\t//      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"6\");\n\t//      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"6\");\n\t\n\t//    },\n\t\n\t(0, _qunit.module)('jsmock - other type', {\n\t  'beforeEach': function beforeEach() {\n\t\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    global.MockInstance = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('The instance type is well work too.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  var receive = (0, _jsmocktool.mock)('MockInstance', _jsmocktool.mock.INSTANCE);\n\t  receive.should_receive('test').with_param(1).and_return('1');\n\t  receive.should_receive('test').with_param(2).and_throw(new Error('test'));\n\t  receive.should_receive('test').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'test';\n\t  });\n\t  var errormessage = '';\n\t\n\t  // When\n\t  var mockInstance = new MockInstance();\n\t  // Then\n\t  assert.equal(mockInstance.test(1), '1');\n\t\n\t  // When\n\t  try {\n\t    mockInstance.test(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, 'test');\n\t\n\t  // When\n\t  mockInstance.test(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'test');\n\t});\n\t\n\t(0, _qunit.test)('The normal functon is well work too.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  var receive = (0, _jsmocktool.mock)(global);\n\t  receive.should_receive('commonfunc').with_param(1).and_return('1');\n\t  receive.should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n\t  receive.should_receive('commonfunc').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'commonfunc';\n\t  });\n\t  var errormessage = '';\n\t\n\t  // When\n\t  var returnVal = commonfunc(1);\n\t  // Then\n\t  assert.equal(returnVal, '1');\n\t\n\t  // When\n\t  try {\n\t    commonfunc(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, 'test2');\n\t\n\t  // When\n\t  commonfunc(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'commonfunc');\n\t});\n\t\n\t(0, _qunit.test)('The namespace type is well work too.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaaa.bbbb.cccc', _jsmocktool.mock.INSTANCE).should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\t\n\t  // Given\n\t  global['aaaaa'] = {};\n\t  aaaaa.bbbbb = {};\n\t  (0, _jsmocktool.mock)('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(aaaaa.bbbbb.test(), 'test');\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t  // When,Then\n\t  assert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('The with_param well work when use namespace.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(1).and_return('1');\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'commonfunc';\n\t  });\n\t\n\t  // When, Then\n\t  assert.equal(param.test.commonfunc(1), '1');\n\t\n\t  // Given\n\t  var errormessage = '';\n\t  try {\n\t    param.test.commonfunc(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // When, Then\n\t  assert.equal(errormessage, 'test2');\n\t\n\t  // When\n\t  param.test.commonfunc(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'commonfunc');\n\t});\n\t\n\t(0, _qunit.module)('jsmock - verify', {\n\t  'beforeEach': function beforeEach() {\n\t    this.mock = (0, _jsmocktool.mock)('Verify');\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    Verify = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('The verify is well work.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('kall').with_param(1, 2).and_return('1');\n\t  this.mock.should_receive('kall2').and_return('1');\n\t  Verify.kall(1, 2);\n\t  var errormessage = '';\n\t  // When\n\t  var result = this.mock.verify('kall');\n\t  // Then\n\t  assert.deepEqual(result, { 'total': 1, 'param': { '[1,2]': 1 } });\n\t\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify').verify('kall2');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall2 isn't called.\");\n\t\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify').verify('kall3');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall3 isn't method.\");\n\t});\n\t(0, _qunit.test)('The verify_all is check all method.', function (assert) {\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify2').should_receive('kall').with_param(1, 2).and_return('1');\n\t  (0, _jsmocktool.mock)('Verify2').should_receive('kall2').and_return('1');\n\t  Verify2.kall(1, 2);\n\t  Verify2.kall2();\n\t  var returnVal;\n\t  // When\n\t  returnVal = (0, _jsmocktool.mock)('Verify2').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify3').should_receive('kall').with_param(1, 2).and_return('1');\n\t  var errormessage;\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify3').verify_all();\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t(0, _qunit.test)('The reset is remove info of function call.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify4').should_receive('kall').with_param(1, 2).and_return('1');\n\t  Verify4.kall(1, 2);\n\t  // When\n\t  var returnVal = (0, _jsmocktool.mock)('Verify4').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } } });\n\t\n\t  // Given\n\t  var errormessage;\n\t  // When\n\t  (0, _jsmocktool.mock)('Verify4').reset('kall');\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify4').verify('kall');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t\n\t(0, _qunit.test)('The reset_all is remove all info of function call.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify5').should_receive('kall').with_param(1, 2).and_return('1');\n\t  (0, _jsmocktool.mock)('Verify5').should_receive('kall2').and_return('1');\n\t  Verify5.kall(1, 2);\n\t  Verify5.kall2();\n\t  // When\n\t  var returnVal = (0, _jsmocktool.mock)('Verify5').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\t\n\t  // Given\n\t  var errormessage;\n\t  // When\n\t  (0, _jsmocktool.mock)('Verify5').reset_all();\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify5').verify_all();\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t\n\t(0, _qunit.module)('jsmock - Support Class');\n\t\n\t(0, _qunit.test)('Add method to Class', function (assert) {\n\t  // Given\n\t\n\t  var Test = function Test() {\n\t    _classCallCheck(this, Test);\n\t  };\n\t\n\t  // When\n\t\n\t\n\t  (0, _jsmocktool.mock)(Test, _jsmocktool.mock.INSTANCE).should_receive('kall').and_return('1');\n\t\n\t  // Then\n\t  var test = new Test();\n\t  assert.equal(test.kall(), '1');\n\t});\n\t\n\t(0, _qunit.test)('Add method to Class instance', function (assert) {\n\t  // Given\n\t\n\t  var Test = function Test() {\n\t    _classCallCheck(this, Test);\n\t  };\n\t\n\t  var test = new Test();\n\t\n\t  // When\n\t  (0, _jsmocktool.mock)(test).should_receive('kall').and_return('1');\n\t\n\t  // Then\n\t  assert.equal(test.kall(), '1');\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _jsmocktool = __webpack_require__(3);\n\t\n\tvar _qunit = __webpack_require__(9);\n\t\n\t/**\n\t * @author mixed\n\t */\n\t\n\tvar global = window;\n\t\n\t(0, _qunit.module)('jsstub', {\n\t\t'beforeEach': function beforeEach() {\n\t\n\t\t\tthis.originConsole = global.console;\n\t\t\tglobal.console = {\n\t\t\t\t'warn': function warn(msg) {}\n\t\t\t};\n\t\t\tthis.stub = (0, _jsmocktool.stub)('STUB');\n\t\t},\n\t\t'afterEach': function afterEach() {\n\t\t\tthis.stub = undefined;\n\t\t\tSTUB = undefined;\n\t\t\tglobal.console = this.originConsole;\n\t\t}\n\t});\n\t\n\t(0, _qunit.test)('The first parameter of stub is must be string,object.', function (assert) {\n\t\t// Given, When\n\t\t(0, _jsmocktool.stub)('FOO');\n\t\t// Then\n\t\tassert.deepEqual(FOO, {});\n\t\n\t\t// Given\n\t\tvar BAR = {};\n\t\t// When\n\t\t(0, _jsmocktool.stub)(BAR);\n\t\t// Then\n\t\tassert.deepEqual(BAR, BAR);\n\t});\n\t\n\t(0, _qunit.test)('The Stub is only add function when already made object.', function (assert) {\n\t\t// Given\n\t\tvar Obj = { test: function test() {} };\n\t\t// When\n\t\t(0, _jsmocktool.stub)('Obj');\n\t\t// Then\n\t\tassert.equal(Obj, Obj);\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)(Obj);\n\t\t// Then\n\t\tassert.equal(Obj, Obj);\n\t});\n\t\n\t(0, _qunit.test)(\"The second parameter of stub is must be none, 'instance' or 'object'\", function (assert) {\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('FOO2');\n\t\t// Then\n\t\tassert.deepEqual(FOO2, {});\n\t\n\t\t// when\n\t\t(0, _jsmocktool.stub)('FOO3', _jsmocktool.stub.INSTANCE);\n\t\t// Then\n\t\tassert.equal(FOO3.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is set empty function', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test');\n\t\t// Then\n\t\tassert.equal(STUB.test.constructor, Function);\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('STUB2', _jsmocktool.stub.INSTANCE).should_receive('test');\n\t\t// Then\n\t\tassert.equal(STUB2.prototype.test.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is change function when already function.', function (assert) {\n\t\t// Given\n\t\tvar funcObj = { test: function test() {\n\t\t\t\treturn false;\n\t\t\t} };\n\t\t// When\n\t\t(0, _jsmocktool.stub)('funcObj').should_receive('test');\n\t\t// Then\n\t\tassert.equal(funcObj.test(), '');\n\t});\n\t\n\t(0, _qunit.test)('Return value of should_receive is StubMethod.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tvar stub_obj = this.stub.should_receive('test');\n\t\t// Then\n\t\t// The StubMethod is private. so I can't test.\n\t\t// Instead, I made a Ducktyping test(?).\n\t\t// I believe correct when The return value of should_receive have and_return function.\n\t\t// ok(stub_obj instanceof StubMethod);\n\t\tassert.equal(stub_obj.and_return.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The and_return is return value when and_return set value.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(STUB.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('The namespace type is well work too.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(STUB.test(), 'test');\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaa.bbbb.cccc', _jsmocktool.stub.INSTANCE).should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\t\n\t\t// Given\n\t\tglobal['aaaaa'] = {};\n\t\taaaaa.bbbbb = {};\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaaaa.bbbbb.test(), 'test');\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('deprecated stub.', function (assert) {\n\t\t// Given\n\t\tvar message = '';\n\t\tglobal.console = {\n\t\t\t'warn': function warn(msg) {\n\t\t\t\tmessage = msg;\n\t\t\t}\n\t\t};\n\t\t// When\n\t\t(0, _jsmocktool.stub)('FOO');\n\t\n\t\t// Then\n\t\tassert.equal(message, '[WARN] : Deprecated Stub. You should be change to Mock.');\n\t});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _qunit = __webpack_require__(9);\n\t\n\t(0, _qunit.start)();\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t  try {\n\t    cachedSetTimeout = setTimeout;\n\t  } catch (e) {\n\t    cachedSetTimeout = function () {\n\t      throw new Error('setTimeout is not defined');\n\t    }\n\t  }\n\t  try {\n\t    cachedClearTimeout = clearTimeout;\n\t  } catch (e) {\n\t    cachedClearTimeout = function () {\n\t      throw new Error('clearTimeout is not defined');\n\t    }\n\t  }\n\t} ())\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** test/dist/jsmocktool.test.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 883e94e3087ca5498049\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n/* eslint-disable */\nmodule.exports = typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();\n/* eslint-enable */\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/global.js\n **/","import global from './global';\n\n/**\n * @access private\n **/\nexport default class TestDouble {\n\tconstructor(name, type) {\n\t\tthis.createTestDouble(name, type);\n\t}\n\n\tcreateTestDouble(name, type) {\n\t\tthis.returnValue = '_js_testDouble_none';\n\t\tthis.testDoubleType = type;\n\n\t\tif (typeof name === 'string') {\n\t\t\tthis.makeEnableObj(name, type);\n\t\t} else if (typeof name === 'object' || typeof name === 'function') {\n\t\t\tthis.testDoubleObj = name;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t`Name of ${this.type} is incorrect.\n\t\t\tThe Type only have String or Object or Function.`);\n\t\t}\n\t}\n\n\tgetTestDouble() {\n\t\tif (this.testDoubleType === 'object') {\n\t\t\treturn this.testDoubleObj;\n\t\t}\n\t\treturn this.testDoubleObj.prototype;\n\t}\n\n\tmakeEnableObj(name, type) {\n\t\tconst depth = name.split('.');\n\t\tlet objectName = depth[0];\n\t\tlet obj = global;\n\t\tif (depth.length > 1) {\n\t\t\tdepth.splice(0, depth.length - 1).forEach((v) => {\n\t\t\t\tif (typeof obj[v] === 'undefined') {\n\t\t\t\t\tobj[v] = {};\n\t\t\t\t}\n\t\t\t\tobj = obj[v];\n\t\t\t});\n\t\t\tobjectName = depth[depth.length - 1];\n\t\t}\n\n\t\tconst returnObj = obj[objectName];\n\t\tthis.testDoubleObj = returnObj;\n\t\tif (type === 'object' && !returnObj) {\n\t\t\tthis.testDoubleObj = obj[objectName] = {};\n\t\t} else if (type === 'instance' && !returnObj) {\n\t\t\tthis.testDoubleObj = obj[objectName] = () => {};\n\t\t\tthis.testDoubleObj.prototype = obj[objectName].prototype = {};\n\t\t}\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/testDouble.js\n **/","import stub from './stub/jsstub';\nimport mock from './mock/jsmock';\n\nexport { stub, mock };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/jsmocktool.js\n **/","import MockMethodFactory from './jsmockMethodFactory';\nimport TestDouble from '../testDouble';\n\n/** @class Mock */\nclass Mock extends TestDouble {\n\t/**\n\t * @access private\n\t **/\n\tconstructor(name, type = 'object') {\n\t\tsuper(name, type);\n\t\tthis.type = 'Mock';\n\t}\n\t/**\n\t * should_receive make method in mock.\n\t * @memberof Mock\n\t * @instance\n\t * @param {string} methodName - method name in mock.\n\t * @function should_receive\n\t * @returns {MockMethod}\n\t * @example\nmock(\"obj\").should_receive(\"something\");\n// obj.something();\n\nmock(\"Sample\",mock.INSTANCE).should_receive(\"something\");\n// let sample = new Sample();\n// sample.something();\n\n// class Test\n// end\n// let test = new Test();\nmock(test).should_receive(\"something\");\n// test.something();\n\nmock(Test,mock.INSTANCE).should_receive(\"instance\");\n// let test = new Test();\n// test.instance()\n\t **/\n\tshould_receive(methodName) {\n\t\treturn MockMethodFactory.getMethod(this.getTestDouble(), methodName);\n\t}\n\n\t/**\n\t * Return specific information called method.\n\t * @memberof Mock\n\t * @instance\n\t * @function verify\n\t * @example\nmock(\"obj\").should_receive(\"something\");\nobj.something();\nmock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\n\t **/\n\tverify(methodName) {\n\t\tconst methodInfo = MockMethodFactory.getData(this.getTestDouble()).get(methodName);\n\t\tif (methodInfo) {\n\t\t\tif (methodInfo.record.total === 0) {\n\t\t\t\tthrow new Error(`${methodName} isn't called.`);\n\t\t\t} else {\n\t\t\t\treturn methodInfo.record;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`${methodName} isn't method.`);\n\t\t}\n\t}\n\n\t/**\n\t * Return all information called methods.\n\t * @memberof Mock\n\t * @instance\n\t * @function verify_all\n\t * @example\nmock(\"obj\").should_receive(\"something\");\nmock(\"obj\").should_receive(\"something2\");\nobj.something();\nobj.something2();\n\nmock(\"obj\").verify_all();\n//{\n//\t\"something\": {total\" : 1, param : {}}\n//\t\"something2\": {total\" : 1, param : {}}\n//}\n\t **/\n\tverify_all() {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tconst returnValue = {};\n\n\t\tobj.forEach((v, i) => {\n\t\t\tif (i !== 'current_obj') returnValue[i] = this.verify(i);\n\t\t});\n\n\t\treturn returnValue;\n\t}\n\n\t/**\n\t * Resets specific information called method.\n\t * @memberof Mock\n\t * @instance\n\t * @function reset\n\t * @example\nmock(\"obj\").should_receive(\"something\");\nmock(\"obj\").should_receive(\"something2\");\nobj.something();\nobj.something2();\n\nmock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\nmock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\nmock(\"obj\").reset(\"something\");\nmock(\"obj\").verify(\"something\"); // throw new Error(`something isn't called.`);\nmock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\t **/\n\treset(methodName) {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tobj.get(methodName).record = { total: 0, param: {} };\n\t}\n\n\t/**\n\t * Resets all information called methods.\n\t * @memberof Mock\n\t * @instance\n\t * @function reset_all\n\t * @example\nmock(\"obj\").should_receive(\"something\");\nmock(\"obj\").should_receive(\"something2\");\nobj.something();\nobj.something2();\nmock(\"obj\").verify(\"something\"); // {\"total\" : 1, param : {}}\nmock(\"obj\").verify(\"something2\"); // {\"total\" : 1, param : {}}\n\nmock(\"obj\").reset_all();\nmock(\"obj\").verify(\"something\"); // throw new Error(`something isn't called.`);\nmock(\"obj\").verify(\"something2\"); // throw new Error(`something2 isn't called.`);\n\t **/\n\treset_all() {\n\t\tfor (const [key, value] of MockMethodFactory.getData(this.getTestDouble())) {\n\t\t\tif (key !== 'current_obj') {\n\t\t\t\tvalue.record = { total: 0, param: {} };\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\n/**\n * @desc create mock in global.\n * @param {string|object|function|class} name - Mock object of name, object, function or class.\n * @param {string} type - Mock object of type. - mock.INSTANCE, mock.OBJECT(defalut)\n * @function mock\n * @returns {Mock}\n * @example\n// If `name` is string and `global` not found `name` object that mock create object in global.\nmock(\"obj\").should_receive(\"something\");\nmock(\"Sample\",mock.INSTANCE).should_receive(\"something\");\n\n// If `name` is object that mock don`t create object.\nmock(obj).should_receive(\"something\");\nmock(zlass).should_receive(\"something\");\n **/\nexport default function mockWrap(name, type) {\n\tif (this instanceof Mock) {\n\t\tthis.createTestDouble(name, type);\n\t} else {\n\t\treturn new Mock(name, type);\n\t}\n}\n\n/**\n * object string\n * @name mock.OBJECT\n * @global\n * @example\nmock(\"obj\", mock.OBJECT);\n **/\nmockWrap.OBJECT = 'object';\n\n/**\n * instance string\n * @name mock.INSTANCE\n * @global\n * @example\nmock(\"obj\", mock.INSTANCE);\n **/\nmockWrap.INSTANCE = 'instance';\n\n/**\n * `anything` return special string.\n * If you use `anything` in `with_param` that\n * `should_receive` execute method regardless of parameter value.\n * @name mock.anything\n * @global\n * @function anything\n * @returns {String} - '_js_mock_anything_param'\n * @example\nmock(\"obj\").should_receive(\"something\").with_param(1,mock.anything()).and_return(\"1\");\n **/\nmockWrap.anything = () => '_js_mock_anything_param';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmock.js\n **/","\n/** @class MockMethod */\nexport default class MockMethod {\n\t/**\n\t * @access private\n\t **/\n\tconstructor(obj, methodName) {\n\t\tthis.excuteObjs = new Map();\n\t\t// {\n\t\t//      key:{\n\t\t//          arg:[],\n\t\t//          type:'function',\n\t\t//          excute : function(){}\n\t\t//      }\n\t\t// };\n\t\tthis.record = { total: 0, param: {} };\n\t\tthis.currentParam = this.transformParamToString([]);\n\t\tthis.excuteObjs.set(this.currentParam, new Map());\n\t\tthis.setup(obj, methodName);\n\t}\n\n\t/**\n\t * @access private\n\t **/\n\ttransformParamToString(obj) {\n\t\treturn JSON.stringify(obj);\n\t}\n\n\t/**\n\t * @access private\n\t **/\n\tsetup(obj, methodName) {\n\t\tconst that = this;\n\t\tconst target = obj;\n\t\ttarget[methodName] = (...params) => {\n\t\t\tthat.record.total++;\n\t\t\tconst argString = that.transformParamToString(params);\n\n\t\t\tif (that.record.param[argString]) {\n\t\t\t\tthat.record.param[argString] += 1;\n\t\t\t} else {\n\t\t\t\tthat.record.param[argString] = 1;\n\t\t\t}\n\n\t\t\tconst dataObj = that.excuteObjs.get(argString);\n\n\t\t\tif (dataObj) {\n\t\t\t\tconst type = dataObj.get('type');\n\t\t\t\tconst excute = dataObj.get('excute');\n\t\t\t\tif (type === 'function') {\n\t\t\t\t\treturn excute.apply(dataObj, params);\n\t\t\t\t} else if (type === 'exception') {\n\t\t\t\t\tthrow excute;\n\t\t\t\t} else if (type === 'return') {\n\t\t\t\t\treturn excute;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const [, info] of that.excuteObjs) {\n\t\t\t\t\tconst arg = info.get('arg');\n\t\t\t\t\tif (\n\t\t\t\t\t\targ && (arg.length === params.length) &&\n\t\t\t\t\t\t!arg.find((v, i) => (v !== params[i] && v !== '_js_mock_anything_param'))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\treturn info.get('excute');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t/**\n\t * set parameters of should_receive.\n\t * If you use `with_param` that `and_xxx` method execute matching param.\n\t * @instance\n\t * @memberof MockMethod\n\t * @param {...anything} params - list up parameters.\n\t * @function with_param\n\t * @returns {MockMethod}\n\t * @example\nmock(\"obj\").should_receive(\"something\").with_param(1,2).and_return(\"1\");\n// obj.something(1); => not return anything\n// obj.something(1, 2); => \"1\"\n\n// You can use `mock.anything`.\nmock(\"obj\").should_receive(\"something\").with_param(1,mock.anything()).and_return(\"1\");\n// obj.something(1, 1); => \"1\"\n// obj.something(1, 2); => \"1\"\n// obj.something(1, 3); => \"1\"\n\t **/\n\twith_param(...params) {\n\t\tthis.currentParam = this.transformParamToString(params);\n\t\tthis.excuteObjs.set(this.currentParam, (new Map()).set('arg', params));\n\t\treturn this;\n\t}\n\n\t/**\n\t * @access private\n\t **/\n\tand_template(type, excute) {\n\t\tthis.excuteObjs\n\t\t\t.get(this.currentParam)\n\t\t\t.set('type', type)\n\t\t\t.set('excute', excute);\n\n\t\tthis.currentParam = this.transformParamToString([]);\n\t}\n\t/**\n\t * set return value when should_receive called.\n\t * @instance\n\t * @memberof MockMethod\n\t * @param {Object} returnVal - return value\n\t * @function and_return\n\t * @example\nmock(\"obj\").should_receive(\"something\").and_return(\"1\");\n// obj.something(1); => \"1\"\n// obj.something(1, 2); => \"1\"\n\t **/\n\tand_return(returnVal) {\n\t\tthis.and_template('return', returnVal);\n\t}\n\t/**\n\t * Set execution function when should_receive called.\n\t * @instance\n\t * @memberof MockMethod\n\t * @param {Function} returnFunction - execute function\n\t * @function and_function\n\t * @example\nmock(\"obj\").should_receive(\"something\").and_function(function(){\n\treturn \"1\";\n});\n// obj.something(1); => \"1\"\n// obj.something(1, 2); => \"1\"\n\t **/\n\tand_function(returnFunction) {\n\t\tthis.and_template('function', returnFunction);\n\t}\n\t/**\n\t * Set exception error when should_receive called.\n\t * @instance\n\t * @memberof MockMethod\n\t * @param {String} returnException - exception message\n\t * @function and_throw\n\t * @example\nmock(\"obj\").should_receive(\"something\").and_throw(\"error\");\n// obj.something(1); => new Error(\"error\")\n// obj.something(1, 2); => new Error(\"error\")\n\t **/\n\tand_throw(returnException) {\n\t\tthis.and_template('exception', returnException);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmockMethod.js\n **/","import MockMethod from './jsmockMethod';\n/**\n * @access private\n **/\nexport default {\n\tstorage: [\n\t\t//      {\n\t\t//          current_obj : {}, object\n\t\t//          current_functions : {} mock method\n\t\t//      }\n\t],\n\tcreateData(obj) {\n\t\tconst dataObj = (new Map()).set('current_obj', obj);\n\t\tthis.storage.push(dataObj);\n\n\t\treturn dataObj;\n\t},\n\tcreateMethod(obj, methodName) {\n\t\treturn new MockMethod(obj, methodName);\n\t},\n\tgetData(obj) {\n\t\tconst data = this.storage.find(value => value.get('current_obj') === obj);\n\t\treturn data || this.createData(obj);\n\t},\n\tgetMethod(obj, methodName) {\n\t\tconst dataObj = this.getData(obj);\n\t\tlet methodObj = dataObj.get(methodName);\n\t\tif (!methodObj) {\n\t\t\tmethodObj = this.createMethod(obj, methodName);\n\t\t\tdataObj.set(methodName, methodObj);\n\t\t}\n\t\treturn methodObj;\n\t},\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmockMethodFactory.js\n **/","import StubMethod from './jsstubMethod';\r\nimport TestDouble from '../testDouble';\r\nimport global from '../global';\r\n\r\n/**\r\n * @access private\r\n **/\r\nfunction warn(msg) {\r\n\tif (global.console && console.warn) {\r\n\t\tconsole.warn(msg);\r\n\t}\r\n}\r\n\r\n/**\r\n * @access private\r\n **/\r\nclass Stub extends TestDouble {\r\n\tconstructor(name, type = 'object') {\r\n\t\tsuper(name, type);\r\n\t\tthis.type = 'Stub';\r\n\t\twarn('[WARN] : Deprecated Stub. You should be change to Mock.');\r\n\t}\r\n\tshould_receive(functionName) {\r\n\t\tthis.getTestDouble()[functionName] = () => {\r\n\t\t\tif (this.returnValue !== '_js_stub_none') {\r\n\t\t\t\treturn this.returnValue;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new StubMethod(this);\r\n\t}\r\n}\r\n\r\n/**\r\n * @access private\r\n **/\r\nexport default function stubWrap(name, type) {\r\n\tif (this instanceof Stub) {\r\n\t\tthis.createTestDouble(name, type);\r\n\t} else {\r\n\t\treturn new Stub(name, type);\r\n\t}\r\n}\r\n\r\n/**\r\n * @access private\r\n **/\r\nstubWrap.OBJECT = 'object';\r\n/**\r\n * @access private\r\n **/\r\nstubWrap.INSTANCE = 'instance';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stub/jsstub.js\n **/","/**\n * @access private\n **/\nexport default class StubMethod {\n\tconstructor(stub) {\n\t\tthis.stub = stub;\n\t}\n\n\tand_return(returnValue) {\n\t\tthis.stub.returnValue = returnValue;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stub/jsstubMethod.js\n **/","/*!\n * QUnit 2.0.0-rc1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-19T16:15Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar autorun = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\tdelete a[ prop ];\n\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn't support IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"2.0.0-rc1\";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\tconsole.warn(\n\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tmoduleFns = {\n\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\tafter: setHook( module, \"after\" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\ttestsRun: 0\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\tparentModule.childModule = module;\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing( test ) {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\ttest.semaphore = 0;\n\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\tresumeProcessing( test );\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing( test ) {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tvar current = test || config.current;\n\t\t\tif ( current && current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tautorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar unitSampler,\n\tfocused = false,\n\tpriorityCount = 0;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\tthis.expected = null;\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.before;\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\tdelete this.module.testEnvironment.after;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tinternalStop( this );\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tinternalStart( this );\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t}\n\n\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\tnotifyTestsRan( this.module );\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack\n\t\t} );\n\n\t\tinternalReset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tpreserveTestEnvironment: function() {\n\t\tif ( this.preserveEnvironment ) {\n\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t}\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"before\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tinternalStop( test );\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { internalStart( test ); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tinternalStart( test );\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the fixture DOM element if available.\nfunction internalReset() {\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n}\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, callback ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, callback ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction internalStop( test ) {\n\n\t// If a test is running, adjust its semaphore\n\ttest.semaphore += 1;\n\n\tpauseProcessing( test );\n}\n\nfunction internalStart( test ) {\n\n\t// If a test is running, adjust its semaphore\n\ttest.semaphore -= 1;\n\n\t// If semaphore is non-numeric, throw error\n\tif ( isNaN( test.semaphore ) ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Invalid value on test.semaphore\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Don't start until equal number of stop-calls\n\tif ( test.semaphore > 0 ) {\n\t\treturn;\n\t}\n\n\t// Throw an Error if start is called more often than stop\n\tif ( test.semaphore < 0 ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\tresumeProcessing( test );\n}\n\nfunction numberOfTests( module ) {\n\tvar count = module.tests.length;\n\twhile ( module = module.childModule ) {\n\t\tcount += module.tests.length;\n\t}\n\treturn count;\n}\n\nfunction notifyTestsRan( module ) {\n\tmodule.testsRun++;\n\twhile ( module = module.parentModule ) {\n\t\tmodule.testsRun++;\n\t}\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing( test );\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\tif ( message == null ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rath <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === \"object\" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === \"object\" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\t\t\"date\": useStrictEquality,\n\n\t\t\"nan\": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We're done when there's nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"(\";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\n\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: \"  \",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\nfunction applyDeprecated( name ) {\n\treturn function() {\n\t\tthrow new Error(\n\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n}\n\nObject.keys( Assert.prototype ).forEach( function( key ) {\n\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n} );\n\nQUnit.asyncTest = function() {\n\tthrow new Error(\n\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.stop = function() {\n\tthrow new Error(\n\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.reset = function() {\n\tthrow new Error(\n\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nif ( defined.document ) {\n\t[\n\t\t\"test\",\n\t\t\"module\",\n\t\t\"expect\",\n\t\t\"start\",\n\t\t\"ok\",\n\t\t\"notOk\",\n\t\t\"equal\",\n\t\t\"notEqual\",\n\t\t\"propEqual\",\n\t\t\"notPropEqual\",\n\t\t\"deepEqual\",\n\t\t\"notDeepEqual\",\n\t\t\"strictEqual\",\n\t\t\"notStrictEqual\",\n\t\t\"throws\",\n\t\t\"raises\"\n\t].forEach( function( key ) {\n\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t} );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== \"undefined\" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: \"hidepassed\",\n\t\tlabel: \"Hide passed tests\",\n\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"noglobals\",\n\t\tlabel: \"Check for Globals\",\n\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"notrycatch\",\n\t\tlabel: \"No try-catch\",\n\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== \"string\" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don't load the HTML Reporter on non-browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nQUnit.init = function() {\n\tthrow new Error(\n\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n// Escape text for attribute or text content.\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t} );\n}\n\nfunction addEvent( elem, type, fn ) {\n\telem.addEventListener( type, fn, false );\n}\n\nfunction removeEvent( elem, type, fn ) {\n\telem.removeEventListener( type, fn, false );\n}\n\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = \"?\",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar i,\n\t\tselectedModules = [],\n\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\tif ( modulesList[ i ].checked ) {\n\t\t\tselectedModules.push( modulesList[ i ].getAttribute( \"module-id\" ) );\n\t\t}\n\t}\n\n\twindow.location = setUrl( {\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\n\t\t// Remove module and testId filter\n\t\tmodule: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction moduleDropDownHtml () {\n\tvar i,\n\t\tdropDownHtml = \"\";\n\n\tif ( !config.modules.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\tdropDownHtml += \"<li><label><input type='checkbox' \" +\n\t\t\t\"module-id='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t( config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1 ? \" checked\" : \"\" ) +\n\t\t\t\">\" + escapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t}\n\t}\n\treturn dropDownHtml;\n}\n\nfunction toolbarModuleFilter () {\n\tvar dropDownHtml = moduleDropDownHtml(),\n\t\ttoolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterComponent = document.createElement( \"div\" ),\n\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\tdropDownContainer = document.createElement( \"div\" ),\n\t\tdropDownList = document.createElement( \"ul\" ),\n\t\tclearFilter = document.createElement( \"span\" );\n\n\tif ( !toolbar || !dropDownHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleSearch.placeholder = \"Select modules\";\n\n\tlabel.innerHTML = \"Module: \";\n\n\tclearFilter.id = \"clear-module-filter\";\n\tclearFilter.innerHTML = \"<span id='clear-module-filter-text'>All modules</span><hr/>\";\n\n\tclearFilter.onclick = function() {\n\t\tvar i,\n\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" );\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\tmodulesList[ i ].checked = false;\n\t\t}\n\t\tapplyUrlParams();\n\t};\n\n\tmoduleFilter.id = \"qunit-modulefilter-container\";\n\tmoduleFilterComponent.id = \"qunit-modulefilter-component\";\n\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\tdropDownContainer.id = \"qunit-modulefilter-dropdown-container\";\n\n\tdropDownContainer.style.display = \"none\";\n\n\tdropDownContainer.appendChild( clearFilter );\n\tmoduleFilter.appendChild( label );\n\tmoduleFilter.appendChild( moduleFilterComponent );\n\tmoduleFilterComponent.appendChild( moduleSearch );\n\tmoduleFilterComponent.appendChild( dropDownContainer ) ;\n\n\t// Enables show/hide for the dropdown\n\taddEvent( moduleSearch, \"focus\", function() {\n\t\tvar dropDownList = id( \"qunit-modulefilter-dropdown-container\" );\n\t\tif ( dropDownList.style.display === \"none\" ) {\n\t\t\taddEvent( document, \"click\", function hideHandler( e )  {\n\t\t\t\tif ( !id( \"qunit-modulefilter-container\" ).contains( e.target ) ) {\n\t\t\t\t\tid( \"qunit-modulefilter-dropdown-container\" ).style.display = \"none\";\n\t\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tdropDownList.style.display = \"block\";\n\t\t}\n\t} );\n\n\t// Enables search to the module filter\n\taddEvent( moduleSearch, \"input\", function() {\n\t\tvar i,\n\t\tmoduleText,\n\t\tsearchText = this.value.toLowerCase(),\n\t\tlistItems = id( \"qunit-modulefilter-dropdown-list\" ).children;\n\n\t\tif ( !searchText ) {\n\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\tmoduleText = listItems[ i ].textContent.toLowerCase();\n\t\t\t\tif ( moduleText.indexOf( searchText ) > -1 ) {\n\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tlistItems[ i ].style.display = \"none\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\tdropDownList.innerHTML = dropDownHtml;\n\tdropDownContainer.appendChild( dropDownList );\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t\"'>Run all tests</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( \"qunit-tests\" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, \"hidepass\" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show  for good,  for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// The pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\tescapeText( expected ) +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t} else {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\" serialization</td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t} );\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === \"complete\" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qunitjs/qunit/qunit.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * @author mixed\n */\n\n import { mock } from '../src/jsmocktool';\n import { module, test } from 'qunitjs/qunit/qunit';\n\n var global = window;\n\n module('jsmock - Object type', {\n   'beforeEach': function () {\n     this.mock = mock('RECEIVE');\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     RECEIVE = undefined;\n   },\n });\n\n test('Must be first prameter is string or object', function (assert) {\n    // Given\n    // When\n   mock('FOO');\n    // Then\n   assert.deepEqual(FOO, {});\n\n    // Given\n   var BAR = {};\n    // When\n   mock(BAR);\n    // Then\n   assert.deepEqual(BAR, BAR);\n });\n\n test(\"Must be second parameter is 'instance','object',none.\", function (assert) {\n    // Given\n    // When\n   mock('FOO2');\n    // Then\n   assert.deepEqual(FOO2, {});\n\n    // Given\n    // When\n   mock('FOO3', mock.INSTANCE);\n    // Then\n   assert.equal(FOO3.constructor, Function);\n });\n\n test('The should_receive is set method of mock Object.', function (assert) {\n    // Given\n   var receiveMock = mock('RECEIVE');\n    // Then\n   receiveMock.should_receive('test');\n    // When\n   assert.equal(RECEIVE.test.constructor, Function);\n\n    // Given\n   var receiveMock2 = mock('RECEIVE2', mock.INSTANCE);\n    // Then\n   receiveMock2.should_receive('test');\n    // When\n   assert.equal(RECEIVE2.prototype.test.constructor, Function);\n });\n\n test('Return value of should_receive is MockMethod.', function (assert) {\n    // Given\n   var receive = mock('RECEIVE3');\n    // When\n   var mock_method = receive.should_receive('test');\n    // The MockMethod is private. so I can't test.\n    // Instead, I made a Ducktyping test(?).\n    // I believe correct when The return value of should_receive have and_return function.\n    // ok(stub_obj instanceof MockMethod);\n    // Then\n   assert.equal(mock_method.and_return.constructor, Function);\n });\n\n test('The and_return is  setting value to return.', function (assert) {\n    // Given\n   mock('RECEIVE4').should_receive('test').and_return(3);\n    // When\n   var returnVal = RECEIVE4.test();\n    // Then\n   assert.equal(returnVal, 3);\n });\n\n test('If use with_param, mock will return value when same param.', function (assert) {\n    // Given\n   mock('RECEIVE4').should_receive('test').with_param(1, 2).and_return(4);\n    // When\n   var returnVal = RECEIVE4.test(1, 2);\n    // Then\n   assert.equal(returnVal, 4);\n });\n\n test('The Mock must be work mock before set parameter when add new parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').and_return(3);\n   this.mock.should_receive('test').with_param(1, 2).and_return(4);\n   this.mock.should_receive('test').with_param(1, 2, 3).and_return(5);\n    // When\n   var noneParam = RECEIVE.test();\n   var oneParam = RECEIVE.test(1, 2);\n   var twoParam = RECEIVE.test(1, 2, 3);\n    // Then\n   assert.equal(noneParam, 3);\n   assert.equal(oneParam, 4);\n   assert.equal(twoParam, 5);\n });\n\n test('The Mock must be change return value when add same parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').and_return(3);\n   this.mock.should_receive('test').with_param(1, 2).and_return(4);\n   this.mock.should_receive('test').with_param(1, 2).and_return(5);\n    // When\n   var noneParam = RECEIVE.test();\n   var twoParam = RECEIVE.test(1, 2);\n    // Then\n   assert.equal(noneParam, 3);\n   assert.equal(twoParam, 5);\n });\n\n test('The add_throw is throw exception when match param.', function (assert) {\n    // Given\n   var error_message = '';\n   this.mock.should_receive('test2').and_throw(new Error('and_throw test.'));\n    // When\n   try {\n     RECEIVE.test2();\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test.');\n });\n\n test('If set with_param of and_throw then throw exception when match parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2.'));\n   var error_message = '';\n\n    // When\n   try {\n     RECEIVE.test2(1, 2);\n   } catch (e) {\n     error_message = e.message;\n   }\n\n    // Then\n   assert.equal(error_message, 'and_throw test2.');\n });\n\n test('The and_throw is well work when change parameter', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param().and_throw(new Error('and_throw test'));\n   this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2'));\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test3'));\n   var error_message = '';\n\n    // When\n   try {\n     RECEIVE.test2();\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test');\n\n    // When\n   try {\n     RECEIVE.test2(1, 2);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test2');\n\n    // When\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test3');\n });\n test('The and_throw throw new exception when some function, same parameter, change exception.', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test'));\n   var error_message = '';\n    // When\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test');\n\n    // Then\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('change throw'));\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // When\n   assert.equal(error_message, 'change throw');\n });\n\n test('The and_function run function when set new function', function (assert) {\n\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').and_function(() => {\n     that.mock_test1 = 'first';\n   });\n    // Then\n   RECEIVE.test3();\n    // When\n   assert.equal(that.mock_test1, 'first');\n });\n\n test('If set a with_param then the and_functon run function when only match parameter.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param(1, 2).and_function(() => {\n     that.mock_test2 = 'second';\n   });\n    // Then\n   RECEIVE.test3(1, 2);\n    // When\n   assert.equal(that.mock_test2, 'second');\n });\n\n test('Then and_function is well work when same function change parameter.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param().and_function(() => {\n     that.mock_test1 = 'first';\n   });\n   this.mock.should_receive('test3').with_param(1, 2).and_function(() => {\n     that.mock_test2 = 'second';\n   });\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'third';\n   });\n    // When\n   RECEIVE.test3();\n    // Then\n   assert.equal(that.mock_test1, 'first');\n\n    // When\n   RECEIVE.test3(1, 2);\n    // Then\n   assert.equal(that.mock_test2, 'second');\n\n    // When\n   RECEIVE.test3(1, 2, 3);\n    // Then\n   assert.equal(that.mock_test3, 'third');\n });\n test('The and_function run new function when some function, same parameter, change and_function.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'third';\n   });\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'change third';\n   });\n    // When\n   RECEIVE.test3(1, 2, 3);\n    // Then\n   assert.equal(that.mock_test3, 'change third');\n });\n test('If use Mock.anything when run function without reference to parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').with_param(1, 2).and_return('1');\n   this.mock.should_receive('test').with_param(1, 2, mock.anything()).and_return('2');\n   this.mock.should_receive('test').with_param(1, 2, mock.anything(), mock.anything()).and_return('3');\n\n    // When, Then\n   assert.equal(RECEIVE.test(1, 2), '1');\n   assert.equal(RECEIVE.test(1, 2, 3), '2');\n   assert.equal(RECEIVE.test(1, 2, 1), '2');\n   assert.equal(RECEIVE.test(1, 2, 4), '2');\n   assert.equal(RECEIVE.test(1, 2, 4, 5), '3');\n   assert.equal(RECEIVE.test(1, 2, 4, 6), '3');\n });\n\n  //    'param anything           .':function(){\n  //      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"5\");\n  //      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"5\");\n\n  //      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"6\");\n  //      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"6\");\n\n  //    },\n\n module('jsmock - other type', {\n   'beforeEach': function () {\n\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     global.MockInstance = undefined;\n   },\n });\n\n test('The instance type is well work too.', function (assert) {\n    // Given\n   var that = this;\n   var receive = mock('MockInstance', mock.INSTANCE);\n   receive.should_receive('test').with_param(1).and_return('1');\n   receive.should_receive('test').with_param(2).and_throw(new Error('test'));\n   receive.should_receive('test').with_param(3).and_function(() => {\n     that.mock_test1 = 'test';\n   });\n   var errormessage = '';\n\n    // When\n   var mockInstance = new MockInstance();\n    // Then\n   assert.equal(mockInstance.test(1), '1');\n\n    // When\n   try {\n     mockInstance.test(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, 'test');\n\n    // When\n   mockInstance.test(3);\n    // Then\n   assert.equal(that.mock_test1, 'test');\n });\n\n test('The normal functon is well work too.', function (assert) {\n    // Given\n   var that = this;\n   var receive = mock(global);\n   receive.should_receive('commonfunc').with_param(1).and_return('1');\n   receive.should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n   receive.should_receive('commonfunc').with_param(3).and_function(() => {\n     that.mock_test1 = 'commonfunc';\n   });\n   var errormessage = '';\n\n    // When\n   var returnVal = commonfunc(1);\n    // Then\n   assert.equal(returnVal, '1');\n\n\n    // When\n   try {\n     commonfunc(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, 'test2');\n\n    // When\n   commonfunc(3);\n    // Then\n   assert.equal(that.mock_test1, 'commonfunc');\n });\n\n test('The namespace type is well work too.', function (assert) {\n    // Given\n   mock('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\n    // Given\n   mock('aaaa.bbbb.cccc', mock.INSTANCE).should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\n    // Given\n   global['aaaaa'] = {};\n   aaaaa.bbbbb = {};\n   mock('aaaaa.bbbbb').should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(aaaaa.bbbbb.test(), 'test');\n\n    // Given\n   mock('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n    // When,Then\n   assert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n });\n\n test('The with_param well work when use namespace.', function (assert) {\n    // Given\n   var that = this;\n   mock('param.test').should_receive('commonfunc').with_param(1).and_return('1');\n   mock('param.test').should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n   mock('param.test').should_receive('commonfunc').with_param(3).and_function(() => {\n     that.mock_test1 = 'commonfunc';\n   });\n\n    // When, Then\n   assert.equal(param.test.commonfunc(1), '1');\n\n    // Given\n   var errormessage = '';\n   try {\n     param.test.commonfunc(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // When, Then\n   assert.equal(errormessage, 'test2');\n\n    // When\n   param.test.commonfunc(3);\n    // Then\n   assert.equal(that.mock_test1, 'commonfunc');\n });\n\n module('jsmock - verify', {\n   'beforeEach': function () {\n     this.mock = mock('Verify');\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     Verify = undefined;\n   },\n });\n\n test('The verify is well work.', function (assert) {\n    // Given\n   this.mock.should_receive('kall').with_param(1, 2).and_return('1');\n   this.mock.should_receive('kall2').and_return('1');\n   Verify.kall(1, 2);\n   var errormessage = '';\n    // When\n   var result = this.mock.verify('kall');\n    // Then\n   assert.deepEqual(result, { 'total': 1, 'param': { '[1,2]': 1 } });\n\n    // When\n   try {\n     mock('Verify').verify('kall2');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall2 isn't called.\");\n\n    // When\n   try {\n     mock('Verify').verify('kall3');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall3 isn't method.\");\n });\n test('The verify_all is check all method.', function (assert) {\n\n    // Given\n   mock('Verify2').should_receive('kall').with_param(1, 2).and_return('1');\n   mock('Verify2').should_receive('kall2').and_return('1');\n   Verify2.kall(1, 2);\n   Verify2.kall2();\n   var returnVal;\n    // When\n   returnVal = mock('Verify2').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\n\n    // Given\n   mock('Verify3').should_receive('kall').with_param(1, 2).and_return('1');\n   var errormessage;\n    // When\n   try {\n     mock('Verify3').verify_all();\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n test('The reset is remove info of function call.', function (assert) {\n    // Given\n   mock('Verify4').should_receive('kall').with_param(1, 2).and_return('1');\n   Verify4.kall(1, 2);\n    // When\n   var returnVal = mock('Verify4').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } } });\n\n    // Given\n   var errormessage;\n    // When\n   mock('Verify4').reset('kall');\n   try {\n     mock('Verify4').verify('kall');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n\n test('The reset_all is remove all info of function call.', function (assert) {\n    // Given\n   mock('Verify5').should_receive('kall').with_param(1, 2).and_return('1');\n   mock('Verify5').should_receive('kall2').and_return('1');\n   Verify5.kall(1, 2);\n   Verify5.kall2();\n    // When\n   var returnVal = mock('Verify5').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\n    // Given\n   var errormessage;\n    // When\n   mock('Verify5').reset_all();\n   try {\n     mock('Verify5').verify_all();\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n\n module('jsmock - Support Class');\n\n test('Add method to Class', function (assert) {\n    // Given\n   class Test {\n\n    }\n\n    // When\n   mock(Test, mock.INSTANCE).should_receive('kall').and_return('1');\n\n    // Then\n   let test = new Test();\n   assert.equal(test.kall(), '1');\n });\n\n test('Add method to Class instance', function (assert) {\n    // Given\n   class Test {\n\n    }\n   let test = new Test();\n\n    // When\n   mock(test).should_receive('kall').and_return('1');\n\n    // Then\n   assert.equal(test.kall(), '1');\n });\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/jsmock.js\n **/","/**\n * @author mixed\n */\n\nimport { stub } from '../src/jsmocktool';\nimport { module, test } from 'qunitjs/qunit/qunit';\n\nvar global = window;\n\nmodule('jsstub', {\n\t'beforeEach': function () {\n\t\t\n\t\tthis.originConsole = global.console;\n\t\tglobal.console = {\n\t\t\t'warn': function (msg) {\n\t\t\t},\n\t\t};\n\t\tthis.stub = stub('STUB');\n\t},\n\t'afterEach': function () {\n\t\tthis.stub = undefined;\n\t\tSTUB = undefined;\n\t\tglobal.console = this.originConsole;\n\t},\n});\n\ntest('The first parameter of stub is must be string,object.', function (assert) {\n\t// Given, When\n\tstub('FOO');\n\t// Then\n\tassert.deepEqual(FOO, {});\n\n\t// Given\n\tlet BAR = {};\n\t// When\n\tstub(BAR);\n\t// Then\n\t                                                                                                                                                                                                                                                assert.deepEqual(BAR, BAR);\n});\n\ntest('The Stub is only add function when already made object.', function (assert) {\n\t// Given\n\tlet Obj = { test: () => {} };\n\t// When\n\tstub('Obj');\n\t// Then\n\tassert.equal(Obj, Obj);\n\n\t// When\n\tstub(Obj);\n\t// Then\n                                                                                                                                                                                                                                        assert.equal(Obj, Obj);\n});\n\ntest(\"The second parameter of stub is must be none, 'instance' or 'object'\", function (assert) {\n\t// Given\n\t// When\n\tstub('FOO2');\n\t// Then\n\tassert.deepEqual(FOO2, {});\n\n\t// when\n\tstub('FOO3', stub.INSTANCE);\n\t// Then\n                                                                                                                                                                                                                                    assert.equal(FOO3.constructor, Function);\n});\n\ntest('The should_receive is set empty function', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test');\n\t// Then\n\tassert.equal(STUB.test.constructor, Function);\n\n\t// Given\n\t// When\n\tstub('STUB2', stub.INSTANCE).should_receive('test');\n\t// Then\n                                                                                                                                                                                                                                        assert.equal(STUB2.prototype.test.constructor, Function);\n});\n\ntest('The should_receive is change function when already function.', function (assert) {\n\t// Given\n\tlet funcObj = { test: () => false };\n\t// When\n\tstub('funcObj').should_receive('test');\n\t// Then\n                                                                                                                                                                                                                                    assert.equal(funcObj.test(), '');\n});\n\ntest('Return value of should_receive is StubMethod.', function (assert) {\n\t// Given\n\t// When\n\tlet stub_obj = this.stub.should_receive('test');\n\t// Then\n\t// The StubMethod is private. so I can't test.\n\t// Instead, I made a Ducktyping test(?).\n\t// I believe correct when The return value of should_receive have and_return function.\n\t// ok(stub_obj instanceof StubMethod);\n\tassert.equal(stub_obj.and_return.constructor, Function);\n});\n\ntest('The and_return is return value when and_return set value.', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(STUB.test(), 'test');\n});\n\ntest('The namespace type is well work too.', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(STUB.test(), 'test');\n\n\t// Given\n\t// When\n\tstub('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\n\t// Given\n\t// When\n\tstub('aaaa.bbbb.cccc', stub.INSTANCE).should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\n\t// Given\n\tglobal['aaaaa'] = {};\n\taaaaa.bbbbb = {};\n\n\t// When\n\tstub('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaaaa.bbbbb.test(), 'test');\n\n\t// When\n\tstub('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n});\n\n\ntest('deprecated stub.', function (assert) {\n\t// Given\n\tlet message = '';\n\tglobal.console = {\n\t\t'warn': function (msg) {\n\t\t\tmessage = msg;\n\t\t},\n\t};\n\t// When\n\tstub('FOO');\n\n\t// Then\n\tassert.equal(message, '[WARN] : Deprecated Stub. You should be change to Mock.');\n});\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/jsstub.js\n **/","import { start } from 'qunitjs/qunit/qunit';\n\nstart();\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/start.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 13\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 14\n ** module chunks = 0\n **/"],"sourceRoot":""}