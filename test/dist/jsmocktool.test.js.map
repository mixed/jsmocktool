{"version":3,"sources":["webpack:///test/dist/jsmocktool.test.js","webpack:///webpack/bootstrap 6df608e0d1c1c969df9c","webpack:///./src/testDouble.js","webpack:///./src/jsmocktool.js","webpack:///./src/mock/jsmock.js","webpack:///./src/mock/jsmockMethod.js","webpack:///./src/mock/jsmockMethodFactory.js","webpack:///./src/stub/jsstub.js","webpack:///./src/stub/jsstubMethod.js","webpack:///./~/qunitjs/qunit/qunit.js","webpack:///./test/jsmock.js","webpack:///./test/jsstub.js","webpack:///./test/start.js","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","global","window","TestDouble","name","type","this","createTestDouble","returnValue","testDoubleType","makeEnableObj","Error","testDoubleObj","depth","split","objectName","splice","forEach","v","returnObj","_interopRequireDefault","__esModule","default","mock","stub","undefined","_jsstub","_jsstub2","_jsmock","_jsmock2","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","mockWrap","Mock","_jsmockMethodFactory","_jsmockMethodFactory2","_testDouble","_testDouble2","_TestDouble","arguments","_this","getPrototypeOf","methodName","getMethod","getTestDouble","getData","record","total","param","verify","OBJECT","INSTANCE","anything","argumentsToArray","arg","returnVal","l","MockMethod","excuteObjs","currentParam","JSON","stringify","setup","that","_len","params","Array","_key","argString","dataObj","excute","apply","paramMatch","j","_len2","_key2","and_template","returnFunction","returnException","_jsmockMethod","_jsmockMethod2","MockMethodFactory","storage","createData","current_obj","push","createMethod","warn","msg","console","stubWrap","Stub","_jsstubMethod","_jsstubMethod2","functionName","_this2","StubMethod","__WEBPACK_AMD_DEFINE_RESULT__","process","diff","a","b","result","slice","inArray","elem","array","indexOf","objectValues","val","vals","QUnit","is","hasOwn","extend","undefOnly","prop","objectType","match","toString","isNaN","toLowerCase","extractStacktrace","e","offset","stack","include","test","shift","fileName","join","sourceFromStacktrace","error","err","registerLoggingCallbacks","registerLoggingCallback","loggingCallback","callback","config","callbacks","callbackNames","runLoggingCallbacks","args","begin","modulesLog","started","now","tests","totalTests","Test","count","blocking","last","next","start","queue","defined","setTimeout","updateRate","current","usedAsync","done","pauseProcessing","testTimeout","clearTimeout","timeout","semaphore","pushFailure","resumeProcessing","runStarted","runtime","passed","autorun","previousModule","failed","moduleStats","bad","all","stats","setHook","hookName","testEnvironment","settings","expected","assertions","currentModule","testName","testId","generateHash","skip","async","assert","Assert","internalReset","fixture","document","getElementById","innerHTML","hex","hash","str","len","charCodeAt","synchronize","priority","seed","index","priorityCount","unitSampler","unitSamplerGenerator","Math","floor","sample","parseInt","saveGlobal","pollution","noglobals","checkPollution","newGlobals","deletedGlobals","old","focused","newTest","only","internalStop","internalStart","numberOfTests","childModule","notifyTestsRan","testsRun","parentModule","testContext","errorString","message","resultErrorString","substring","applyDeprecated","Date","getTime","sessionStorage","x","setItem","removeItem","replace","globalStartCalled","hasOwnProperty","reorder","altertitle","collapse","scrolltop","maxDepth","requireExpects","urlConfig","moduleStack","onErrorFnPrev","onerror","filePath","linerNr","ret","ignoreGlobalErrors","validTest","isLocal","location","protocol","version","executeNow","createModule","moduleName","env","beforeEach","afterEach","setCurrentModule","moduleFns","teardown","before","after","pop","globalStartAlreadyCalled","autostart","pageLoaded","load","filter","run","runTest","promise","resolvePromise","callbackStarted","notrycatch","queueHook","hook","hookOwner","callHook","preserveEnvironment","hooks","handler","processHooks","finish","skipped","source","preserveTestEnvironment","reverse","valid","getItem","pushResult","resultInfo","details","actual","negative","phase","then","moduleChainNameMatch","testModule","testModuleName","moduleChainIdMatch","regexFilter","exec","fullName","stringFilter","exclude","pattern","flags","regex","RegExp","charAt","currentTest","expect","asserts","popped","acceptCallCount","currentAssert","ok","dump","parse","notOk","equal","notEqual","propEqual","equiv","notPropEqual","deepEqual","notDeepEqual","strictEqual","notStrictEqual","throws","block","expectedType","expectedOutput","raises","useStrictEquality","valueOf","compareConstructors","protoA","getProto","protoB","getRegExpFlags","regexp","typeEquiv","innerEquiv","callers","parents","parentsB","string","boolean","number","null","symbol","date","nan","function","caller","loop","aCircular","bCircular","set","innerEq","outerEq","size","aVal","bVal","map","aKey","bKey","object","eq","aProperties","bProperties","sort","quote","literal","o","pre","arr","post","s","separator","base","indent","inner","up","down","reName","objType","res","parser","parserType","inStack","typeOf","parsers","setInterval","nodeType","item","multiline","HTML","extra","chr","indentChar","setParser","unknown","fn","nodelist","keys","nonEnumerableProperties","node","open","close","tag","nodeName","attrs","attributes","nodeValue","functionArgs","String","fromCharCode","functionCode","attribute","jsDump","asyncTest","stop","reset","getUrlParams","urlParams","search","decodeURIComponent","concat","escapeText","addEvent","addEventListener","removeEvent","removeEventListener","addEvents","elems","hasClass","className","addClass","toggleClass","force","removeClass","trim","getUrlConfigHtml","escaped","escapedTooltip","selection","urlConfigHtml","label","tooltip","toolbarChanged","updatedUrl","field","options","selectedIndex","checked","defaultValue","setUrl","history","replaceState","arrValue","querystring","encodeURIComponent","host","pathname","applyUrlParams","selectedModules","modulesList","getElementsByTagName","getAttribute","toolbarUrlConfigContainer","urlConfigContainer","createElement","toolbarLooseFilter","input","button","appendChild","ev","preventDefault","moduleDropDownHtml","dropDownHtml","toolbarModuleFilter","toolbar","moduleFilter","moduleFilterComponent","moduleSearch","dropDownContainer","dropDownList","clearFilter","placeholder","onclick","style","display","hideHandler","contains","moduleText","searchText","listItems","children","textContent","appendToolbar","appendHeader","header","unfilteredUrl","appendBanner","banner","appendTestResults","parentNode","removeChild","insertBefore","storeFixture","appendFilteredTest","appendUserAgent","userAgent","createTextNode","navigator","appendInterface","qunit","title","appendTestsList","z","moduleObj","appendTest","rerunTrigger","testBlock","assertList","getNameHtml","href","nameHtml","stripHtml","random","option","init","collapseNext","localeCompare","hidepassed","html","scrollTo","testStart","running","log","assertLi","showDiff","testItem","testDone","testTitle","time","good","testCounts","sourceName","firstChild","notPhantom","major","phantom","readyState","DiffMatchPatch","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","DiffMain","text1","text2","optChecklines","deadline","checklines","commonlength","commonprefix","commonsuffix","diffs","diffCommonPrefix","diffCommonSuffix","diffCompute","unshift","diffCleanupMerge","diffCleanupEfficiency","changes","equalities","equalitiesLength","lastequality","pointer","preIns","preDel","postIns","postDel","diffPrettyHtml","op","data","pointermid","pointermax","pointermin","pointerstart","min","pointerend","longtext","shorttext","hm","text1A","text2A","text1B","text2B","midCommon","diffsA","diffsB","diffHalfMatch","diffLineMode","diffBisect","diffHalfMatchI","bestCommon","prefixLength","suffixLength","bestLongtextA","bestLongtextB","bestShorttextA","bestShorttextB","dmp","hm1","hm2","ceil","linearray","countInsert","countDelete","textInsert","textDelete","diffLinesToChars","chars1","chars2","lineArray","diffCharsToLines","diffCleanupSemantic","text1Length","text2Length","maxD","vOffset","vLength","v1","v2","delta","front","k1start","k1end","k2start","k2end","k2Offset","k1Offset","x1","x2","y1","y2","d","k1","k2","diffBisectSplit","y","text1a","text1b","text2a","text2b","diffsb","lengthInsertions2","lengthDeletions2","lengthInsertions1","lengthDeletions1","deletion","insertion","overlapLength1","overlapLength2","max","diffCommonOverlap","textLength","best","found","diffLinesToCharsMunge","text","chars","lineStart","lineEnd","lineArrayLength","line","lineHash","diffPointer","position","n","output","_jsmocktool","_qunit","mock_test1","mock_test2","mock_test3","RECEIVE","FOO","BAR","FOO2","FOO3","Function","receiveMock","should_receive","receiveMock2","RECEIVE2","receive","mock_method","and_return","RECEIVE4","with_param","noneParam","oneParam","twoParam","error_message","and_throw","test2","and_function","test3","MockInstance","errormessage","mockInstance","commonfunc","aaa","bbb","ccc","ddd","aaaa","bbbb","cccc","aaaaa","bbbbb","ccccc","Verify","kall","[1,2]","Verify2","kall2","verify_all","[]","Verify4","Verify5","reset_all","originConsole","STUB","Obj","STUB2","funcObj","stub_obj","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","Item","fun","noop","nextTick","browser","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths"],"mappings":"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","file":"test/dist/jsmocktool.test.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(9);\n\t__webpack_require__(10);\n\tmodule.exports = __webpack_require__(11);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar global = window;\n\t\n\tvar TestDouble = function () {\n\t\tfunction TestDouble(name, type) {\n\t\t\t_classCallCheck(this, TestDouble);\n\t\n\t\t\tthis.createTestDouble(name, type);\n\t\t}\n\t\n\t\t_createClass(TestDouble, [{\n\t\t\tkey: 'createTestDouble',\n\t\t\tvalue: function createTestDouble(name, type) {\n\t\t\t\tthis.returnValue = '_js_testDouble_none';\n\t\t\t\tthis.testDoubleType = type;\n\t\n\t\t\t\tif (typeof name === 'string') {\n\t\t\t\t\tthis.makeEnableObj(name, type);\n\t\t\t\t} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' || typeof name === 'function') {\n\t\t\t\t\tthis.testDoubleObj = name;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Name of ' + this.type + ' is incorrect.\\n\\t\\t\\tThe Type only have String or Object or Function.');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTestDouble',\n\t\t\tvalue: function getTestDouble() {\n\t\t\t\tif (this.testDoubleType === 'object') {\n\t\t\t\t\treturn this.testDoubleObj;\n\t\t\t\t}\n\t\t\t\treturn this.testDoubleObj.prototype;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'makeEnableObj',\n\t\t\tvalue: function makeEnableObj(name, type) {\n\t\t\t\tvar depth = name.split('.');\n\t\t\t\tvar objectName = depth[0];\n\t\t\t\tvar obj = global;\n\t\t\t\tif (depth.length > 1) {\n\t\t\t\t\tdepth.splice(0, depth.length - 1).forEach(function (v) {\n\t\t\t\t\t\tif (typeof obj[v] === 'undefined') {\n\t\t\t\t\t\t\tobj[v] = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj = obj[v];\n\t\t\t\t\t});\n\t\t\t\t\tobjectName = depth[depth.length - 1];\n\t\t\t\t}\n\t\n\t\t\t\tvar returnObj = obj[objectName];\n\t\t\t\tthis.testDoubleObj = returnObj;\n\t\t\t\tif (type === 'object' && !returnObj) {\n\t\t\t\t\tthis.testDoubleObj = obj[objectName] = {};\n\t\t\t\t} else if (type === 'instance' && !returnObj) {\n\t\t\t\t\tthis.testDoubleObj = obj[objectName] = function () {};\n\t\t\t\t\tthis.testDoubleObj.prototype = obj[objectName].prototype = {};\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn TestDouble;\n\t}();\n\t\n\texports.default = TestDouble;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.mock = exports.stub = undefined;\n\t\n\tvar _jsstub = __webpack_require__(6);\n\t\n\tvar _jsstub2 = _interopRequireDefault(_jsstub);\n\t\n\tvar _jsmock = __webpack_require__(3);\n\t\n\tvar _jsmock2 = _interopRequireDefault(_jsmock);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.stub = _jsstub2.default;\n\texports.mock = _jsmock2.default;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jsmockMethodFactory = __webpack_require__(5);\n\t\n\tvar _jsmockMethodFactory2 = _interopRequireDefault(_jsmockMethodFactory);\n\t\n\tvar _testDouble = __webpack_require__(1);\n\t\n\tvar _testDouble2 = _interopRequireDefault(_testDouble);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Mock = function (_TestDouble) {\n\t\t_inherits(Mock, _TestDouble);\n\t\n\t\tfunction Mock(name) {\n\t\t\tvar type = arguments.length <= 1 || arguments[1] === undefined ? 'object' : arguments[1];\n\t\n\t\t\t_classCallCheck(this, Mock);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Mock).call(this, name, type));\n\t\n\t\t\t_this.type = 'Mock';\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t_createClass(Mock, [{\n\t\t\tkey: 'should_receive',\n\t\t\tvalue: function should_receive(methodName) {\n\t\t\t\treturn _jsmockMethodFactory2.default.getMethod(this.getTestDouble(), methodName);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'reset_all',\n\t\t\tvalue: function reset_all() {\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tfor (var i in obj) {\n\t\t\t\t\tif (i !== 'current_obj') {\n\t\t\t\t\t\tobj[i].record = { total: 0, param: {} };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'reset',\n\t\t\tvalue: function reset(methodName) {\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tobj[methodName].record = { total: 0, param: {} };\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'verify',\n\t\t\tvalue: function verify(methodName) {\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tif (obj[methodName]) {\n\t\t\t\t\tif (obj[methodName].record.total === 0) {\n\t\t\t\t\t\tthrow new Error(methodName + ' isn\\'t called.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn obj[methodName].record;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(methodName + ' isn\\'t method.');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'verify_all',\n\t\t\tvalue: function verify_all() {\n\t\t\t\tvar obj = _jsmockMethodFactory2.default.getData(this.getTestDouble());\n\t\t\t\tvar returnValue = {};\n\t\t\t\tfor (var i in obj) {\n\t\t\t\t\tif (i !== 'current_obj') returnValue[i] = this.verify(i);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Mock;\n\t}(_testDouble2.default);\n\t\n\tfunction mockWrap(name, type) {\n\t\tif (this instanceof Mock) {\n\t\t\tthis.createTestDouble(name, type);\n\t\t} else {\n\t\t\treturn new Mock(name, type);\n\t\t}\n\t}\n\t\n\tmockWrap.OBJECT = 'object';\n\tmockWrap.INSTANCE = 'instance';\n\tmockWrap.anything = function () {\n\t\treturn '_js_mock_anything_param';\n\t};\n\t\n\texports.default = mockWrap;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction argumentsToArray(arg) {\n\t\tvar returnVal = [];\n\t\tif (!!arg.length) {\n\t\t\tfor (var i = 0, l = arg.length; i < l; i++) {\n\t\t\t\treturnVal[i] = arg[i];\n\t\t\t}\n\t\t}\n\t\treturn returnVal;\n\t}\n\t\n\tvar MockMethod = function () {\n\t\tfunction MockMethod(obj, methodName) {\n\t\t\t_classCallCheck(this, MockMethod);\n\t\n\t\t\tthis.excuteObjs = {\n\t\t\t\t//      key:{\n\t\t\t\t//          arg:[],\n\t\t\t\t//          type:\"function\",\n\t\t\t\t//          excute : function(){}\n\t\t\t\t//      }\n\t\t\t};\n\t\t\tthis.record = { total: 0, param: {} };\n\t\t\tthis.currentParam = JSON.stringify([]);\n\t\t\tthis.excuteObjs[this.currentParam] = {};\n\t\t\tthis.setup(obj, methodName);\n\t\t}\n\t\n\t\t_createClass(MockMethod, [{\n\t\t\tkey: 'setup',\n\t\t\tvalue: function setup(obj, methodName) {\n\t\t\t\tvar that = this;\n\t\t\t\tvar target = obj;\n\t\t\t\ttarget[methodName] = function addFunc() {\n\t\t\t\t\tthat.record.total++;\n\t\n\t\t\t\t\tfor (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\t\tparams[_key] = arguments[_key];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar argString = JSON.stringify(argumentsToArray(params));\n\t\n\t\t\t\t\tif (that.record.param[argString]) {\n\t\t\t\t\t\tthat.record.param[argString] += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthat.record.param[argString] = 1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar dataObj = that.excuteObjs[argString];\n\t\n\t\t\t\t\tif (dataObj) {\n\t\t\t\t\t\tif (dataObj.type === 'function') {\n\t\t\t\t\t\t\treturn dataObj.excute.apply(dataObj, argumentsToArray(params));\n\t\t\t\t\t\t} else if (dataObj.type === 'exception') {\n\t\t\t\t\t\t\tthrow dataObj.excute;\n\t\t\t\t\t\t} else if (dataObj.type === 'return') {\n\t\t\t\t\t\t\treturn dataObj.excute;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var i in that.excuteObjs) {\n\t\t\t\t\t\t\tvar currentParam = argumentsToArray(params);\n\t\t\t\t\t\t\tvar arg = that.excuteObjs[i].arg;\n\t\n\t\t\t\t\t\t\tif (arg && arg.length === currentParam.length) {\n\t\t\t\t\t\t\t\tvar paramMatch = true;\n\t\t\t\t\t\t\t\tfor (var j = 0, l = arg.length; j < l; j++) {\n\t\t\t\t\t\t\t\t\tif (arg[j] !== currentParam[j] && arg[j] !== '_js_mock_anything_param') {\n\t\t\t\t\t\t\t\t\t\tparamMatch = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (paramMatch) {\n\t\t\t\t\t\t\t\t\treturn that.excuteObjs[i].excute;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'with_param',\n\t\t\tvalue: function with_param() {\n\t\t\t\tfor (var _len2 = arguments.length, params = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\tparams[_key2] = arguments[_key2];\n\t\t\t\t}\n\t\n\t\t\t\tvar arg = argumentsToArray(params);\n\t\t\t\tthis.currentParam = JSON.stringify(arg);\n\t\t\t\tthis.excuteObjs[this.currentParam] = { arg: arg };\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'and_template',\n\t\t\tvalue: function and_template(type, excute) {\n\t\t\t\tthis.excuteObjs[this.currentParam].type = type;\n\t\t\t\tthis.excuteObjs[this.currentParam].excute = excute;\n\t\t\t\tthis.currentParam = JSON.stringify([]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'and_return',\n\t\t\tvalue: function and_return(returnVal) {\n\t\t\t\tthis.and_template('return', returnVal);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'and_function',\n\t\t\tvalue: function and_function(returnFunction) {\n\t\t\t\tthis.and_template('function', returnFunction);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'and_throw',\n\t\t\tvalue: function and_throw(returnException) {\n\t\t\t\tthis.and_template('exception', returnException);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn MockMethod;\n\t}();\n\t\n\texports.default = MockMethod;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _jsmockMethod = __webpack_require__(4);\n\t\n\tvar _jsmockMethod2 = _interopRequireDefault(_jsmockMethod);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar MockMethodFactory = {\n\t\tstorage: [\n\t\t\t//      {\n\t\t\t//          current_obj : {}, object\n\t\t\t//          current_functions : {} mock method\n\t\t\t//      }\n\t\t],\n\t\tcreateData: function createData(obj) {\n\t\t\tvar dataObj = { current_obj: obj };\n\t\t\tthis.storage.push(dataObj);\n\t\n\t\t\treturn dataObj;\n\t\t},\n\t\tcreateMethod: function createMethod(obj, methodName) {\n\t\t\tvar dataObj = this.getData(obj);\n\t\t\tdataObj[methodName] = new _jsmockMethod2.default(obj, methodName);\n\t\n\t\t\treturn dataObj[methodName];\n\t\t},\n\t\tgetData: function getData(obj) {\n\t\t\tfor (var i = 0, l = this.storage.length; i < l; i++) {\n\t\t\t\tif (this.storage[i].current_obj === obj) {\n\t\t\t\t\treturn this.storage[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.createData(obj);\n\t\t},\n\t\tgetMethod: function getMethod(obj, methodName) {\n\t\t\tvar dataObj = this.getData(obj);\n\t\t\tif (!dataObj[methodName]) {\n\t\t\t\tdataObj[methodName] = this.createMethod(obj, methodName);\n\t\t\t}\n\t\t\treturn dataObj[methodName];\n\t\t}\n\t};\n\t\n\texports.default = MockMethodFactory;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jsstubMethod = __webpack_require__(7);\n\t\n\tvar _jsstubMethod2 = _interopRequireDefault(_jsstubMethod);\n\t\n\tvar _testDouble = __webpack_require__(1);\n\t\n\tvar _testDouble2 = _interopRequireDefault(_testDouble);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar global = window;\n\t\n\tfunction warn(msg) {\n\t\tif (global.console && console.warn) {\n\t\t\tconsole.warn(msg);\n\t\t}\n\t}\n\t\n\tvar Stub = function (_TestDouble) {\n\t\t_inherits(Stub, _TestDouble);\n\t\n\t\tfunction Stub(name) {\n\t\t\tvar type = arguments.length <= 1 || arguments[1] === undefined ? 'object' : arguments[1];\n\t\n\t\t\t_classCallCheck(this, Stub);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Stub).call(this, name, type));\n\t\n\t\t\t_this.type = 'Stub';\n\t\t\twarn('[WARN] : Deprecated Stub. You should be change to Mock.');\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t_createClass(Stub, [{\n\t\t\tkey: 'should_receive',\n\t\t\tvalue: function should_receive(functionName) {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\tthis.getTestDouble()[functionName] = function () {\n\t\t\t\t\tif (_this2.returnValue !== '_js_stub_none') {\n\t\t\t\t\t\treturn _this2.returnValue;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn new _jsstubMethod2.default(this);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Stub;\n\t}(_testDouble2.default);\n\t\n\tfunction stubWrap(name, type) {\n\t\tif (this instanceof Stub) {\n\t\t\tthis.createTestDouble(name, type);\n\t\t} else {\n\t\t\treturn new Stub(name, type);\n\t\t}\n\t}\n\t\n\tstubWrap.OBJECT = 'object';\n\tstubWrap.INSTANCE = 'instance';\n\t\n\texports.default = stubWrap;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar StubMethod = function () {\n\t\tfunction StubMethod(stub) {\n\t\t\t_classCallCheck(this, StubMethod);\n\t\n\t\t\tthis.stub = stub;\n\t\t}\n\t\n\t\t_createClass(StubMethod, [{\n\t\t\tkey: \"and_return\",\n\t\t\tvalue: function and_return(returnValue) {\n\t\t\t\tthis.stub.returnValue = returnValue;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn StubMethod;\n\t}();\n\t\n\texports.default = StubMethod;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, module) {/*!\n\t * QUnit 2.0.0-rc1\n\t * https://qunitjs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-04-19T16:15Z\n\t */\n\t\n\t( function( global ) {\n\t\n\tvar QUnit = {};\n\t\n\tvar Date = global.Date;\n\tvar now = Date.now || function() {\n\t\treturn new Date().getTime();\n\t};\n\t\n\tvar setTimeout = global.setTimeout;\n\tvar clearTimeout = global.clearTimeout;\n\t\n\t// Store a local window from the global to allow direct references.\n\tvar window = global.window;\n\t\n\tvar defined = {\n\t\tdocument: window && window.document !== undefined,\n\t\tsetTimeout: setTimeout !== undefined,\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t};\n\t\n\tvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\n\tvar globalStartCalled = false;\n\tvar runStarted = false;\n\t\n\tvar autorun = false;\n\t\n\tvar toString = Object.prototype.toString,\n\t\thasOwn = Object.prototype.hasOwnProperty;\n\t\n\t// Returns a new Array with the elements that are in a but not in b\n\tfunction diff( a, b ) {\n\t\tvar i, j,\n\t\t\tresult = a.slice();\n\t\n\t\tfor ( i = 0; i < result.length; i++ ) {\n\t\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\t\tresult.splice( i, 1 );\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// From jquery.js\n\tfunction inArray( elem, array ) {\n\t\tif ( array.indexOf ) {\n\t\t\treturn array.indexOf( elem );\n\t\t}\n\t\n\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\tif ( array[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Makes a clone of an object using only Array or Object as base,\n\t * and copies over the own enumerable properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object} New object with only the own properties (recursively).\n\t */\n\tfunction objectValues ( obj ) {\n\t\tvar key, val,\n\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\tfor ( key in obj ) {\n\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\tval = obj[ key ];\n\t\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t}\n\t\n\tfunction extend( a, b, undefOnly ) {\n\t\tfor ( var prop in b ) {\n\t\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a;\n\t}\n\t\n\tfunction objectType( obj ) {\n\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\n\t\t// Consider: typeof null === object\n\t\tif ( obj === null ) {\n\t\t\treturn \"null\";\n\t\t}\n\t\n\t\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\t\ttype = match && match[ 1 ];\n\t\n\t\tswitch ( type ) {\n\t\t\tcase \"Number\":\n\t\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Set\":\n\t\t\tcase \"Map\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"Symbol\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ( typeof obj === \"object\" ) {\n\t\t\treturn \"object\";\n\t\t}\n\t}\n\t\n\t// Safe object type checking\n\tfunction is( type, obj ) {\n\t\treturn QUnit.objectType( obj ) === type;\n\t}\n\t\n\t// Doesn't support IE9, it will return undefined on these browsers\n\t// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\tfunction extractStacktrace( e, offset ) {\n\t\toffset = offset === undefined ? 4 : offset;\n\t\n\t\tvar stack, include, i;\n\t\n\t\tif ( e.stack ) {\n\t\t\tstack = e.stack.split( \"\\n\" );\n\t\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\t\tstack.shift();\n\t\t\t}\n\t\t\tif ( fileName ) {\n\t\t\t\tinclude = [];\n\t\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t\t}\n\t\t\t\tif ( include.length ) {\n\t\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stack[ offset ];\n\t\t}\n\t}\n\t\n\tfunction sourceFromStacktrace( offset ) {\n\t\tvar error = new Error();\n\t\n\t\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\t\tif ( !error.stack ) {\n\t\t\ttry {\n\t\t\t\tthrow error;\n\t\t\t} catch ( err ) {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t}\n\t\n\t\treturn extractStacktrace( error, offset );\n\t}\n\t\n\t/**\n\t * Config object: Maintain internal state\n\t * Later exposed as QUnit.config\n\t * `config` initialized at top of scope\n\t */\n\tvar config = {\n\t\n\t\t// The queue of tests to run\n\t\tqueue: [],\n\t\n\t\t// Block until document ready\n\t\tblocking: true,\n\t\n\t\t// By default, run previously failed tests first\n\t\t// very useful in combination with \"Hide passed tests\" checked\n\t\treorder: true,\n\t\n\t\t// By default, modify document.title when suite is done\n\t\taltertitle: true,\n\t\n\t\t// HTML Reporter: collapse every test except the first failing test\n\t\t// If false, all failing tests will be expanded\n\t\tcollapse: true,\n\t\n\t\t// By default, scroll to top of the page when suite is done\n\t\tscrolltop: true,\n\t\n\t\t// Depth up-to which object will be dumped\n\t\tmaxDepth: 5,\n\t\n\t\t// When enabled, all tests must call expect()\n\t\trequireExpects: false,\n\t\n\t\t// Placeholder for user-configurable form-exposed URL parameters\n\t\turlConfig: [],\n\t\n\t\t// Set of all modules.\n\t\tmodules: [],\n\t\n\t\t// Stack of nested modules\n\t\tmoduleStack: [],\n\t\n\t\t// The first unnamed module\n\t\tcurrentModule: {\n\t\t\tname: \"\",\n\t\t\ttests: []\n\t\t},\n\t\n\t\tcallbacks: {}\n\t};\n\t\n\t// Push a loose unnamed module to the modules collection\n\tconfig.modules.push( config.currentModule );\n\t\n\t// Register logging callbacks\n\tfunction registerLoggingCallbacks( obj ) {\n\t\tvar i, l, key,\n\t\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\t\"moduleStart\", \"moduleDone\" ];\n\t\n\t\tfunction registerLoggingCallback( key ) {\n\t\t\tvar loggingCallback = function( callback ) {\n\t\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t\t};\n\t\n\t\t\treturn loggingCallback;\n\t\t}\n\t\n\t\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\t\tkey = callbackNames[ i ];\n\t\n\t\t\t// Initialize key collection of logging callback\n\t\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\t\tconfig.callbacks[ key ] = [];\n\t\t\t}\n\t\n\t\t\tobj[ key ] = registerLoggingCallback( key );\n\t\t}\n\t}\n\t\n\tfunction runLoggingCallbacks( key, args ) {\n\t\tvar i, l, callbacks;\n\t\n\t\tcallbacks = config.callbacks[ key ];\n\t\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\t\tcallbacks[ i ]( args );\n\t\t}\n\t}\n\t\n\t( function() {\n\t\tif ( !defined.document ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// `onErrorFnPrev` initialized at top of scope\n\t\t// Preserve other handlers\n\t\tvar onErrorFnPrev = window.onerror;\n\t\n\t\t// Cover uncaught exceptions\n\t\t// Returning true will suppress the default browser handler,\n\t\t// returning false will let it run.\n\t\twindow.onerror = function( error, filePath, linerNr ) {\n\t\t\tvar ret = false;\n\t\t\tif ( onErrorFnPrev ) {\n\t\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t\t}\n\t\n\t\t\t// Treat return value as window.onerror itself does,\n\t\t\t// Only do our handling if not suppressed.\n\t\t\tif ( ret !== true ) {\n\t\t\t\tif ( QUnit.config.current ) {\n\t\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t} else {\n\t\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t\t}, { validTest: true } ) );\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t};\n\t}() );\n\t\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\t\n\t// Expose the current QUnit version\n\tQUnit.version = \"2.0.0-rc1\";\n\t\n\textend( QUnit, {\n\t\n\t\t// Call on start of module test to prepend name to all tests\n\t\tmodule: function( name, testEnvironment, executeNow ) {\n\t\t\tvar module, moduleFns;\n\t\t\tvar currentModule = config.currentModule;\n\t\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\t\ttestEnvironment = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tmodule = createModule();\n\t\n\t\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tmoduleFns = {\n\t\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\t\tafter: setHook( module, \"after\" )\n\t\t\t};\n\t\n\t\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\t\tconfig.moduleStack.push( module );\n\t\t\t\tsetCurrentModule( module );\n\t\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\t\tconfig.moduleStack.pop();\n\t\t\t\tmodule = module.parentModule || currentModule;\n\t\t\t}\n\t\n\t\t\tsetCurrentModule( module );\n\t\n\t\t\tfunction createModule() {\n\t\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\t\tvar module = {\n\t\t\t\t\tname: moduleName,\n\t\t\t\t\tparentModule: parentModule,\n\t\t\t\t\ttests: [],\n\t\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\t\ttestsRun: 0\n\t\t\t\t};\n\t\n\t\t\t\tvar env = {};\n\t\t\t\tif ( parentModule ) {\n\t\t\t\t\tparentModule.childModule = module;\n\t\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\t\tdelete env.beforeEach;\n\t\t\t\t\tdelete env.afterEach;\n\t\t\t\t}\n\t\t\t\textend( env, testEnvironment );\n\t\t\t\tmodule.testEnvironment = env;\n\t\n\t\t\t\tconfig.modules.push( module );\n\t\t\t\treturn module;\n\t\t\t}\n\t\n\t\t\tfunction setCurrentModule( module ) {\n\t\t\t\tconfig.currentModule = module;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttest: test,\n\t\n\t\tskip: skip,\n\t\n\t\tonly: only,\n\t\n\t\tstart: function( count ) {\n\t\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\t\n\t\t\tif ( !config.current ) {\n\t\t\t\tglobalStartCalled = true;\n\t\n\t\t\t\tif ( runStarted ) {\n\t\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t\t} else if ( config.autostart ) {\n\t\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t\t} else if ( !config.pageLoaded ) {\n\t\n\t\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\t\tconfig.autostart = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tresumeProcessing();\n\t\t},\n\t\n\t\tconfig: config,\n\t\n\t\tis: is,\n\t\n\t\tobjectType: objectType,\n\t\n\t\textend: extend,\n\t\n\t\tload: function() {\n\t\t\tconfig.pageLoaded = true;\n\t\n\t\t\t// Initialize the configuration options\n\t\t\textend( config, {\n\t\t\t\tstats: { all: 0, bad: 0 },\n\t\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\t\tstarted: 0,\n\t\t\t\tupdateRate: 1000,\n\t\t\t\tautostart: true,\n\t\t\t\tfilter: \"\"\n\t\t\t}, true );\n\t\n\t\t\tconfig.blocking = false;\n\t\n\t\t\tif ( config.autostart ) {\n\t\t\t\tresumeProcessing();\n\t\t\t}\n\t\t},\n\t\n\t\tstack: function( offset ) {\n\t\t\toffset = ( offset || 0 ) + 2;\n\t\t\treturn sourceFromStacktrace( offset );\n\t\t}\n\t} );\n\t\n\tregisterLoggingCallbacks( QUnit );\n\t\n\tfunction begin() {\n\t\tvar i, l,\n\t\t\tmodulesLog = [];\n\t\n\t\t// If the test run hasn't officially begun yet\n\t\tif ( !config.started ) {\n\t\n\t\t\t// Record the time of the test run's beginning\n\t\t\tconfig.started = now();\n\t\n\t\t\t// Delete the loose unnamed module if unused.\n\t\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\t\tconfig.modules.shift();\n\t\t\t}\n\t\n\t\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\t\tmodulesLog.push( {\n\t\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// The test run is officially beginning now\n\t\t\trunLoggingCallbacks( \"begin\", {\n\t\t\t\ttotalTests: Test.count,\n\t\t\t\tmodules: modulesLog\n\t\t\t} );\n\t\t}\n\t\n\t\tconfig.blocking = false;\n\t\tprocess( true );\n\t}\n\t\n\tfunction process( last ) {\n\t\tfunction next() {\n\t\t\tprocess( last );\n\t\t}\n\t\tvar start = now();\n\t\tconfig.depth = ( config.depth || 0 ) + 1;\n\t\n\t\twhile ( config.queue.length && !config.blocking ) {\n\t\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\t\tif ( config.current ) {\n\t\n\t\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t\t}\n\t\t\t\tconfig.queue.shift()();\n\t\t\t} else {\n\t\t\t\tsetTimeout( next, 13 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig.depth--;\n\t\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\t\tdone();\n\t\t}\n\t}\n\t\n\tfunction pauseProcessing( test ) {\n\t\tconfig.blocking = true;\n\t\n\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t\tconfig.timeout = setTimeout( function() {\n\t\t\t\ttest.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t\tresumeProcessing( test );\n\t\t\t}, config.testTimeout );\n\t\t}\n\t}\n\t\n\tfunction resumeProcessing( test ) {\n\t\trunStarted = true;\n\t\n\t\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\t\tif ( defined.setTimeout ) {\n\t\t\tsetTimeout( function() {\n\t\t\t\tvar current = test || config.current;\n\t\t\t\tif ( current && current.semaphore > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t}\n\t\n\t\t\t\tbegin();\n\t\t\t}, 13 );\n\t\t} else {\n\t\t\tbegin();\n\t\t}\n\t}\n\t\n\tfunction done() {\n\t\tvar runtime, passed;\n\t\n\t\tautorun = true;\n\t\n\t\t// Log the last module results\n\t\tif ( config.previousModule ) {\n\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\tname: config.previousModule.name,\n\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t} );\n\t\t}\n\t\tdelete config.previousModule;\n\t\n\t\truntime = now() - config.started;\n\t\tpassed = config.stats.all - config.stats.bad;\n\t\n\t\trunLoggingCallbacks( \"done\", {\n\t\t\tfailed: config.stats.bad,\n\t\t\tpassed: passed,\n\t\t\ttotal: config.stats.all,\n\t\t\truntime: runtime\n\t\t} );\n\t}\n\t\n\tfunction setHook( module, hookName ) {\n\t\tif ( module.testEnvironment === undefined ) {\n\t\t\tmodule.testEnvironment = {};\n\t\t}\n\t\n\t\treturn function( callback ) {\n\t\t\tmodule.testEnvironment[ hookName ] = callback;\n\t\t};\n\t}\n\t\n\tvar unitSampler,\n\t\tfocused = false,\n\t\tpriorityCount = 0;\n\t\n\tfunction Test( settings ) {\n\t\tvar i, l;\n\t\n\t\t++Test.count;\n\t\n\t\tthis.expected = null;\n\t\textend( this, settings );\n\t\tthis.assertions = [];\n\t\tthis.semaphore = 0;\n\t\tthis.usedAsync = false;\n\t\tthis.module = config.currentModule;\n\t\tthis.stack = sourceFromStacktrace( 3 );\n\t\n\t\t// Register unique strings\n\t\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\t\tthis.testName += \" \";\n\t\t\t}\n\t\t}\n\t\n\t\tthis.testId = generateHash( this.module.name, this.testName );\n\t\n\t\tthis.module.tests.push( {\n\t\t\tname: this.testName,\n\t\t\ttestId: this.testId\n\t\t} );\n\t\n\t\tif ( settings.skip ) {\n\t\n\t\t\t// Skipped tests will fully ignore any sent callback\n\t\t\tthis.callback = function() {};\n\t\t\tthis.async = false;\n\t\t\tthis.expected = 0;\n\t\t} else {\n\t\t\tthis.assert = new Assert( this );\n\t\t}\n\t}\n\t\n\tTest.count = 0;\n\t\n\tTest.prototype = {\n\t\tbefore: function() {\n\t\t\tif (\n\t\n\t\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\t\tthis.module !== config.previousModule ||\n\t\n\t\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t\t) {\n\t\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tconfig.previousModule = this.module;\n\t\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\t\tname: this.module.name,\n\t\t\t\t\ttests: this.module.tests\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tif ( this.module.testEnvironment ) {\n\t\t\t\tdelete this.module.testEnvironment.before;\n\t\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\t\tdelete this.module.testEnvironment.after;\n\t\t\t}\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\n\t\t\tthis.started = now();\n\t\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module.name,\n\t\t\t\ttestId: this.testId\n\t\t\t} );\n\t\n\t\t\tif ( !config.pollution ) {\n\t\t\t\tsaveGlobal();\n\t\t\t}\n\t\t},\n\t\n\t\trun: function() {\n\t\t\tvar promise;\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tif ( this.async ) {\n\t\t\t\tinternalStop( this );\n\t\t\t}\n\t\n\t\t\tthis.callbackStarted = now();\n\t\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\trunTest( this );\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttry {\n\t\t\t\trunTest( this );\n\t\t\t} catch ( e ) {\n\t\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\n\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t// Restart the tests if they're blocking\n\t\t\t\tif ( config.blocking ) {\n\t\t\t\t\tinternalStart( this );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction runTest( test ) {\n\t\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise );\n\t\t\t}\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\tcheckPollution();\n\t\t},\n\t\n\t\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\t\tvar promise,\n\t\t\t\ttest = this;\n\t\t\treturn function runHook() {\n\t\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tconfig.current = test;\n\t\t\t\tif ( config.notrycatch ) {\n\t\t\t\t\tcallHook();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tcallHook();\n\t\t\t\t} catch ( error ) {\n\t\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t\t}\n\t\n\t\t\t\tfunction callHook() {\n\t\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\n\t\t// Currently only used for module level hooks, can be used to add global level ones\n\t\thooks: function( handler ) {\n\t\t\tvar hooks = [];\n\t\n\t\t\tfunction processHooks( test, module ) {\n\t\t\t\tif ( module.parentModule ) {\n\t\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t\t}\n\t\t\t\tif ( module.testEnvironment &&\n\t\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Hooks are ignored on skipped tests\n\t\t\tif ( !this.skip ) {\n\t\t\t\tprocessHooks( this, this.module );\n\t\t\t}\n\t\t\treturn hooks;\n\t\t},\n\t\n\t\tfinish: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\t\"not called.\", this.stack );\n\t\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t\t}\n\t\n\t\t\tvar i,\n\t\t\t\tbad = 0;\n\t\n\t\t\tthis.runtime = now() - this.started;\n\t\t\tconfig.stats.all += this.assertions.length;\n\t\t\tconfig.moduleStats.all += this.assertions.length;\n\t\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tnotifyTestsRan( this.module );\n\t\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tskipped: !!this.skip,\n\t\t\t\tfailed: bad,\n\t\t\t\tpassed: this.assertions.length - bad,\n\t\t\t\ttotal: this.assertions.length,\n\t\t\t\truntime: this.runtime,\n\t\n\t\t\t\t// HTML Reporter use\n\t\t\t\tassertions: this.assertions,\n\t\t\t\ttestId: this.testId,\n\t\n\t\t\t\t// Source of Test\n\t\t\t\tsource: this.stack\n\t\t\t} );\n\t\n\t\t\tinternalReset();\n\t\n\t\t\tconfig.current = undefined;\n\t\t},\n\t\n\t\tpreserveTestEnvironment: function() {\n\t\t\tif ( this.preserveEnvironment ) {\n\t\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t\t}\n\t\t},\n\t\n\t\tqueue: function() {\n\t\t\tvar priority,\n\t\t\t\ttest = this;\n\t\n\t\t\tif ( !this.valid() ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tfunction run() {\n\t\n\t\t\t\t// Each of these can by async\n\t\t\t\tsynchronize( [\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.before();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"before\" ),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"beforeEach\" ),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.run();\n\t\t\t\t\t},\n\t\n\t\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.after();\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\ttest.finish();\n\t\t\t\t\t}\n\t\t\t\t] );\n\t\t\t}\n\t\n\t\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\t\n\t\t\treturn synchronize( run, priority, config.seed );\n\t\t},\n\t\n\t\tpushResult: function( resultInfo ) {\n\t\n\t\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\tvar source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: resultInfo.result,\n\t\t\t\t\tmessage: resultInfo.message,\n\t\t\t\t\tactual: resultInfo.actual,\n\t\t\t\t\texpected: resultInfo.expected,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\t\n\t\t\tif ( !resultInfo.result ) {\n\t\t\t\tsource = sourceFromStacktrace();\n\t\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", details );\n\t\n\t\t\tthis.assertions.push( {\n\t\t\t\tresult: !!resultInfo.result,\n\t\t\t\tmessage: resultInfo.message\n\t\t\t} );\n\t\t},\n\t\n\t\tpushFailure: function( message, source, actual ) {\n\t\t\tif ( !( this instanceof Test ) ) {\n\t\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t}\n\t\n\t\t\tvar details = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message || \"error\",\n\t\t\t\t\tactual: actual || null,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\t\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", details );\n\t\n\t\t\tthis.assertions.push( {\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tresolvePromise: function( promise, phase ) {\n\t\t\tvar then, message,\n\t\t\t\ttest = this;\n\t\t\tif ( promise != null ) {\n\t\t\t\tthen = promise.then;\n\t\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\t\tinternalStop( test );\n\t\t\t\t\tthen.call(\n\t\t\t\t\t\tpromise,\n\t\t\t\t\t\tfunction() { internalStart( test ); },\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\t\n\t\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\t\tinternalStart( test );\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tvalid: function() {\n\t\t\tvar filter = config.filter,\n\t\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\t\n\t\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\t\tif ( testModuleName === module ) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t\t}\n\t\n\t\t\t// Internally-generated tests are always valid\n\t\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t\t!moduleChainIdMatch( this.module ) ) {\n\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif ( !filter ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn regexFilter ?\n\t\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\t\tthis.stringFilter( filter, fullName );\n\t\t},\n\t\n\t\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\t\tvar regex = new RegExp( pattern, flags );\n\t\t\tvar match = regex.test( fullName );\n\t\n\t\t\treturn match !== exclude;\n\t\t},\n\t\n\t\tstringFilter: function( filter, fullName ) {\n\t\t\tfilter = filter.toLowerCase();\n\t\t\tfullName = fullName.toLowerCase();\n\t\n\t\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\t\tif ( !include ) {\n\t\t\t\tfilter = filter.slice( 1 );\n\t\t\t}\n\t\n\t\t\t// If the filter matches, we need to honour include\n\t\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\t\treturn include;\n\t\t\t}\n\t\n\t\t\t// Otherwise, do the opposite\n\t\t\treturn !include;\n\t\t}\n\t};\n\t\n\t// Resets the fixture DOM element if available.\n\tfunction internalReset() {\n\t\tvar fixture = defined.document && document.getElementById &&\n\t\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\t\n\t\tif ( fixture ) {\n\t\t\tfixture.innerHTML = config.fixture;\n\t\t}\n\t}\n\t\n\tQUnit.pushFailure = function() {\n\t\tif ( !QUnit.config.current ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\t\n\t\t// Gets current test obj\n\t\tvar currentTest = QUnit.config.current;\n\t\n\t\treturn currentTest.pushFailure.apply( currentTest, arguments );\n\t};\n\t\n\t// Based on Java's String.hashCode, a simple but not\n\t// rigorously collision resistant hashing function\n\tfunction generateHash( module, testName ) {\n\t\tvar hex,\n\t\t\ti = 0,\n\t\t\thash = 0,\n\t\t\tstr = module + \"\\x1C\" + testName,\n\t\t\tlen = str.length;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\t\thash |= 0;\n\t\t}\n\t\n\t\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\t\thex = ( 0x100000000 + hash ).toString( 16 );\n\t\tif ( hex.length < 8 ) {\n\t\t\thex = \"0000000\" + hex;\n\t\t}\n\t\n\t\treturn hex.slice( -8 );\n\t}\n\t\n\tfunction synchronize( callback, priority, seed ) {\n\t\tvar last = !priority,\n\t\t\tindex;\n\t\n\t\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\t\twhile ( callback.length ) {\n\t\t\t\tsynchronize( callback.shift() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\n\t\tif ( priority ) {\n\t\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t\t} else if ( seed ) {\n\t\t\tif ( !unitSampler ) {\n\t\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t\t}\n\t\n\t\t\t// Insert into a random position after all priority items\n\t\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t\t} else {\n\t\t\tconfig.queue.push( callback );\n\t\t}\n\t\n\t\tif ( autorun && !config.blocking ) {\n\t\t\tprocess( last );\n\t\t}\n\t}\n\t\n\tfunction unitSamplerGenerator( seed ) {\n\t\n\t\t// 32-bit xorshift, requires only a nonzero seed\n\t\t// http://excamera.com/sphinx/article-xorshift.html\n\t\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\t\treturn function() {\n\t\t\tsample ^= sample << 13;\n\t\t\tsample ^= sample >>> 17;\n\t\t\tsample ^= sample << 5;\n\t\n\t\t\t// ECMAScript has no unsigned number type\n\t\t\tif ( sample < 0 ) {\n\t\t\t\tsample += 0x100000000;\n\t\t\t}\n\t\n\t\t\treturn sample / 0x100000000;\n\t\t};\n\t}\n\t\n\tfunction saveGlobal() {\n\t\tconfig.pollution = [];\n\t\n\t\tif ( config.noglobals ) {\n\t\t\tfor ( var key in global ) {\n\t\t\t\tif ( hasOwn.call( global, key ) ) {\n\t\n\t\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconfig.pollution.push( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction checkPollution() {\n\t\tvar newGlobals,\n\t\t\tdeletedGlobals,\n\t\t\told = config.pollution;\n\t\n\t\tsaveGlobal();\n\t\n\t\tnewGlobals = diff( config.pollution, old );\n\t\tif ( newGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t\t}\n\t\n\t\tdeletedGlobals = diff( old, config.pollution );\n\t\tif ( deletedGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t\t}\n\t}\n\t\n\t// Will be exposed as QUnit.test\n\tfunction test( testName, callback ) {\n\t\tif ( focused )  { return; }\n\t\n\t\tvar newTest;\n\t\n\t\tnewTest = new Test( {\n\t\t\ttestName: testName,\n\t\t\tcallback: callback\n\t\t} );\n\t\n\t\tnewTest.queue();\n\t}\n\t\n\t// Will be exposed as QUnit.skip\n\tfunction skip( testName ) {\n\t\tif ( focused )  { return; }\n\t\n\t\tvar test = new Test( {\n\t\t\ttestName: testName,\n\t\t\tskip: true\n\t\t} );\n\t\n\t\ttest.queue();\n\t}\n\t\n\t// Will be exposed as QUnit.only\n\tfunction only( testName, callback ) {\n\t\tvar newTest;\n\t\n\t\tif ( focused )  { return; }\n\t\n\t\tQUnit.config.queue.length = 0;\n\t\tfocused = true;\n\t\n\t\tnewTest = new Test( {\n\t\t\ttestName: testName,\n\t\t\tcallback: callback\n\t\t} );\n\t\n\t\tnewTest.queue();\n\t}\n\t\n\tfunction internalStop( test ) {\n\t\n\t\t// If a test is running, adjust its semaphore\n\t\ttest.semaphore += 1;\n\t\n\t\tpauseProcessing( test );\n\t}\n\t\n\tfunction internalStart( test ) {\n\t\n\t\t// If a test is running, adjust its semaphore\n\t\ttest.semaphore -= 1;\n\t\n\t\t// If semaphore is non-numeric, throw error\n\t\tif ( isNaN( test.semaphore ) ) {\n\t\t\ttest.semaphore = 0;\n\t\n\t\t\tQUnit.pushFailure(\n\t\t\t\t\"Invalid value on test.semaphore\",\n\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Don't start until equal number of stop-calls\n\t\tif ( test.semaphore > 0 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Throw an Error if start is called more often than stop\n\t\tif ( test.semaphore < 0 ) {\n\t\t\ttest.semaphore = 0;\n\t\n\t\t\tQUnit.pushFailure(\n\t\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\n\t\tresumeProcessing( test );\n\t}\n\t\n\tfunction numberOfTests( module ) {\n\t\tvar count = module.tests.length;\n\t\twhile ( module = module.childModule ) {\n\t\t\tcount += module.tests.length;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tfunction notifyTestsRan( module ) {\n\t\tmodule.testsRun++;\n\t\twhile ( module = module.parentModule ) {\n\t\t\tmodule.testsRun++;\n\t\t}\n\t}\n\t\n\tfunction Assert( testContext ) {\n\t\tthis.test = testContext;\n\t}\n\t\n\t// Assert helpers\n\tQUnit.assert = Assert.prototype = {\n\t\n\t\t// Specify the number of expected assertions to guarantee that failed test\n\t\t// (no assertions are run at all) don't slip through.\n\t\texpect: function( asserts ) {\n\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\tthis.test.expected = asserts;\n\t\t\t} else {\n\t\t\t\treturn this.test.expected;\n\t\t\t}\n\t\t},\n\t\n\t\t// Increment this Test's semaphore counter, then return a function that\n\t\t// decrements that counter a maximum of once.\n\t\tasync: function( count ) {\n\t\t\tvar test = this.test,\n\t\t\t\tpopped = false,\n\t\t\t\tacceptCallCount = count;\n\t\n\t\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\t\tacceptCallCount = 1;\n\t\t\t}\n\t\n\t\t\ttest.semaphore += 1;\n\t\t\ttest.usedAsync = true;\n\t\t\tpauseProcessing( test );\n\t\n\t\t\treturn function done() {\n\t\n\t\t\t\tif ( popped ) {\n\t\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tacceptCallCount -= 1;\n\t\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\ttest.semaphore -= 1;\n\t\t\t\tpopped = true;\n\t\t\t\tresumeProcessing();\n\t\t\t};\n\t\t},\n\t\n\t\t// Exports test.push() to the user API\n\t\t// Alias of pushResult.\n\t\tpush: function( result, actual, expected, message, negative ) {\n\t\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\t\treturn currentAssert.pushResult( {\n\t\t\t\tresult: result,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: negative\n\t\t\t} );\n\t\t},\n\t\n\t\tpushResult: function( resultInfo ) {\n\t\n\t\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\tvar assert = this,\n\t\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\t\n\t\t\t// Backwards compatibility fix.\n\t\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t\t// not exactly the test where assertion were intended to be called.\n\t\t\tif ( !currentTest ) {\n\t\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t\t}\n\t\n\t\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\n\t\t\t\t// Allow this assertion to continue running anyway...\n\t\t\t}\n\t\n\t\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\t\tassert = currentTest.assert;\n\t\t\t}\n\t\n\t\t\treturn assert.test.pushResult( resultInfo );\n\t\t},\n\t\n\t\tok: function( result, message ) {\n\t\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\t\tQUnit.dump.parse( result ) );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !!result,\n\t\t\t\tactual: result,\n\t\t\t\texpected: true,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotOk: function( result, message ) {\n\t\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\t\tQUnit.dump.parse( result ) );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !result,\n\t\t\t\tactual: result,\n\t\t\t\texpected: false,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tequal: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected == actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotEqual: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected != actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tpropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues( actual );\n\t\t\texpected = objectValues( expected );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotPropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues( actual );\n\t\t\texpected = objectValues( expected );\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tdeepEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotDeepEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\tstrictEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected === actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t},\n\t\n\t\tnotStrictEqual: function( actual, expected, message ) {\n\t\t\tthis.pushResult( {\n\t\t\t\tresult: expected !== actual,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\tmessage: message,\n\t\t\t\tnegative: true\n\t\t\t} );\n\t\t},\n\t\n\t\t\"throws\": function( block, expected, message ) {\n\t\t\tvar actual, expectedType,\n\t\t\t\texpectedOutput = expected,\n\t\t\t\tok = false,\n\t\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\t\n\t\t\t// 'expected' is optional unless doing string comparison\n\t\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\tif ( message == null ) {\n\t\t\t\t\tmessage = expected;\n\t\t\t\t\texpected = null;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\t\ttry {\n\t\t\t\tblock.call( currentTest.testEnvironment );\n\t\t\t} catch ( e ) {\n\t\t\t\tactual = e;\n\t\t\t}\n\t\t\tcurrentTest.ignoreGlobalErrors = false;\n\t\n\t\t\tif ( actual ) {\n\t\t\t\texpectedType = QUnit.objectType( expected );\n\t\n\t\t\t\t// We don't want to validate thrown error\n\t\t\t\tif ( !expected ) {\n\t\t\t\t\tok = true;\n\t\t\t\t\texpectedOutput = null;\n\t\n\t\t\t\t// Expected is a regexp\n\t\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\t\tok = expected.test( errorString( actual ) );\n\t\n\t\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\t\tok = true;\n\t\n\t\t\t\t// Expected is an Error object\n\t\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\t\tactual.message === expected.message;\n\t\n\t\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcurrentTest.assert.pushResult( {\n\t\t\t\tresult: ok,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expectedOutput,\n\t\t\t\tmessage: message\n\t\t\t} );\n\t\t}\n\t};\n\t\n\t// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n\t// Known to us are: Closure Compiler, Narwhal\n\t( function() {\n\t\t/*jshint sub:true */\n\t\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n\t}() );\n\t\n\tfunction errorString( error ) {\n\t\tvar name, message,\n\t\t\tresultErrorString = error.toString();\n\t\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif ( name && message ) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if ( name ) {\n\t\t\t\treturn name;\n\t\t\t} else if ( message ) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn resultErrorString;\n\t\t}\n\t}\n\t\n\t// Test for equality any JavaScript type.\n\t// Author: Philippe Rathé <prathe@gmail.com>\n\tQUnit.equiv = ( function() {\n\t\n\t\t// Stack to decide between skip/abort functions\n\t\tvar callers = [];\n\t\n\t\t// Stack to avoiding loops from circular referencing\n\t\tvar parents = [];\n\t\tvar parentsB = [];\n\t\n\t\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\t\n\t\t\t/*jshint proto: true */\n\t\t\treturn obj.__proto__;\n\t\t};\n\t\n\t\tfunction useStrictEquality( b, a ) {\n\t\n\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t// `var i = 1;`\n\t\t\t// `var j = new Number(1);`\n\t\t\tif ( typeof a === \"object\" ) {\n\t\t\t\ta = a.valueOf();\n\t\t\t}\n\t\t\tif ( typeof b === \"object\" ) {\n\t\t\t\tb = b.valueOf();\n\t\t\t}\n\t\n\t\t\treturn a === b;\n\t\t}\n\t\n\t\tfunction compareConstructors( a, b ) {\n\t\t\tvar protoA = getProto( a );\n\t\t\tvar protoB = getProto( b );\n\t\n\t\t\t// Comparing constructors is more strict than using `instanceof`\n\t\t\tif ( a.constructor === b.constructor ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Ref #851\n\t\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t\t// as a null prototype.\n\t\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\t\tprotoA = null;\n\t\t\t}\n\t\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\t\tprotoB = null;\n\t\t\t}\n\t\n\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t// objects with Object as their constructor.\n\t\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction getRegExpFlags( regexp ) {\n\t\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t\t}\n\t\n\t\tvar callbacks = {\n\t\t\t\"string\": useStrictEquality,\n\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\"number\": useStrictEquality,\n\t\t\t\"null\": useStrictEquality,\n\t\t\t\"undefined\": useStrictEquality,\n\t\t\t\"symbol\": useStrictEquality,\n\t\t\t\"date\": useStrictEquality,\n\t\n\t\t\t\"nan\": function() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\treturn a.source === b.source &&\n\t\n\t\t\t\t\t// Include flags in the comparison\n\t\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t\t},\n\t\n\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t// - abort otherwise,\n\t\t\t// initial === would have catch identical references anyway\n\t\t\t\"function\": function() {\n\t\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t},\n\t\n\t\t\t\"array\": function( b, a ) {\n\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\t\n\t\t\t\tlen = a.length;\n\t\t\t\tif ( len !== b.length ) {\n\t\n\t\t\t\t\t// Safe and faster\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\t// Track reference to avoid circular references\n\t\t\t\tparents.push( a );\n\t\t\t\tparentsB.push( b );\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tloop = false;\n\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparents.pop();\n\t\t\t\tparentsB.pop();\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"set\": function( b, a ) {\n\t\t\t\tvar innerEq,\n\t\t\t\t\touterEq = true;\n\t\n\t\t\t\tif ( a.size !== b.size ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\ta.forEach( function( aVal ) {\n\t\t\t\t\tinnerEq = false;\n\t\n\t\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\t\touterEq = false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\n\t\t\t\treturn outerEq;\n\t\t\t},\n\t\n\t\t\t\"map\": function( b, a ) {\n\t\t\t\tvar innerEq,\n\t\t\t\t\touterEq = true;\n\t\n\t\t\t\tif ( a.size !== b.size ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\t\tinnerEq = false;\n\t\n\t\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\t\touterEq = false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\n\t\t\t\treturn outerEq;\n\t\t\t},\n\t\n\t\t\t\"object\": function( b, a ) {\n\t\t\t\tvar i, j, loop, aCircular, bCircular;\n\t\n\t\t\t\t// Default to true\n\t\t\t\tvar eq = true;\n\t\t\t\tvar aProperties = [];\n\t\t\t\tvar bProperties = [];\n\t\n\t\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\t// Stack constructor before traversing properties\n\t\t\t\tcallers.push( a.constructor );\n\t\n\t\t\t\t// Track reference to avoid circular references\n\t\t\t\tparents.push( a );\n\t\t\t\tparentsB.push( b );\n\t\n\t\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\tfor ( i in a ) {\n\t\t\t\t\tloop = false;\n\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taProperties.push( i );\n\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\teq = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tparents.pop();\n\t\t\t\tparentsB.pop();\n\t\n\t\t\t\t// Unstack, we are done\n\t\t\t\tcallers.pop();\n\t\n\t\t\t\tfor ( i in b ) {\n\t\n\t\t\t\t\t// Collect b's properties\n\t\t\t\t\tbProperties.push( i );\n\t\t\t\t}\n\t\n\t\t\t\t// Ensures identical properties name\n\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t}\n\t\t};\n\t\n\t\tfunction typeEquiv( a, b ) {\n\t\t\tvar type = QUnit.objectType( a );\n\t\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t\t}\n\t\n\t\t// The real equiv function\n\t\tfunction innerEquiv( a, b ) {\n\t\n\t\t\t// We're done when there's nothing more to compare\n\t\t\tif ( arguments.length < 2 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Require type-specific equality\n\t\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\t\n\t\t\t\t// ...across all consecutive argument pairs\n\t\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t\t}\n\t\n\t\treturn innerEquiv;\n\t}() );\n\t\n\t// Based on jsDump by Ariel Flesler\n\t// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\n\tQUnit.dump = ( function() {\n\t\tfunction quote( str ) {\n\t\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t\t}\n\t\tfunction literal( o ) {\n\t\t\treturn o + \"\";\n\t\t}\n\t\tfunction join( pre, arr, post ) {\n\t\t\tvar s = dump.separator(),\n\t\t\t\tbase = dump.indent(),\n\t\t\t\tinner = dump.indent( 1 );\n\t\t\tif ( arr.join ) {\n\t\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t\t}\n\t\t\tif ( !arr ) {\n\t\t\t\treturn pre + post;\n\t\t\t}\n\t\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t\t}\n\t\tfunction array( arr, stack ) {\n\t\t\tvar i = arr.length,\n\t\t\t\tret = new Array( i );\n\t\n\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\treturn \"[object Array]\";\n\t\t\t}\n\t\n\t\t\tthis.up();\n\t\t\twhile ( i-- ) {\n\t\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t\t}\n\t\t\tthis.down();\n\t\t\treturn join( \"[\", ret, \"]\" );\n\t\t}\n\t\n\t\tvar reName = /^function (\\w+)/,\n\t\t\tdump = {\n\t\n\t\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\t\tstack = stack || [];\n\t\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\t\tinStack = inArray( obj, stack );\n\t\n\t\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\t\tparserType = typeof parser;\n\t\n\t\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\t\tstack.push( obj );\n\t\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t\t},\n\t\t\t\ttypeOf: function( obj ) {\n\t\t\t\t\tvar type;\n\t\t\t\t\tif ( obj === null ) {\n\t\t\t\t\t\ttype = \"null\";\n\t\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\t\ttype = \"date\";\n\t\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\t\ttype = \"function\";\n\t\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\t\ttype = \"window\";\n\t\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\t\ttype = \"document\";\n\t\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\t\ttype = \"node\";\n\t\t\t\t\t} else if (\n\t\n\t\t\t\t\t\t// Native arrays\n\t\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\n\t\t\t\t\t\t// NodeList objects\n\t\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\ttype = \"array\";\n\t\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\t\ttype = \"error\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = typeof obj;\n\t\t\t\t\t}\n\t\t\t\t\treturn type;\n\t\t\t\t},\n\t\n\t\t\t\tseparator: function() {\n\t\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t\t},\n\t\n\t\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\t\tindent: function( extra ) {\n\t\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tvar chr = this.indentChar;\n\t\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t\t},\n\t\t\t\tup: function( a ) {\n\t\t\t\t\tthis.depth += a || 1;\n\t\t\t\t},\n\t\t\t\tdown: function( a ) {\n\t\t\t\t\tthis.depth -= a || 1;\n\t\t\t\t},\n\t\t\t\tsetParser: function( name, parser ) {\n\t\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t\t},\n\t\n\t\t\t\t// The next 3 are exposed so you can use them\n\t\t\t\tquote: quote,\n\t\t\t\tliteral: literal,\n\t\t\t\tjoin: join,\n\t\t\t\tdepth: 1,\n\t\t\t\tmaxDepth: QUnit.config.maxDepth,\n\t\n\t\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\t\tparsers: {\n\t\t\t\t\twindow: \"[Window]\",\n\t\t\t\t\tdocument: \"[Document]\",\n\t\t\t\t\terror: function( error ) {\n\t\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t\t},\n\t\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\t\"null\": \"null\",\n\t\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\t\tvar ret = \"function\",\n\t\n\t\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\t\n\t\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += \"(\";\n\t\n\t\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnodelist: array,\n\t\t\t\t\t\"arguments\": array,\n\t\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\t\tret = [];\n\t\n\t\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tdump.up();\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.sort();\n\t\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdump.down();\n\t\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tnode: function( node ) {\n\t\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\t\tattrs = node.attributes;\n\t\n\t\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\t\n\t\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += close;\n\t\n\t\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\t\tvar args,\n\t\t\t\t\t\t\tl = fn.length;\n\t\n\t\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\targs = new Array( l );\n\t\t\t\t\t\twhile ( l-- ) {\n\t\n\t\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\t\tkey: quote,\n\t\n\t\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\t\tfunctionCode: \"[code]\",\n\t\n\t\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\t\tattribute: quote,\n\t\t\t\t\tstring: quote,\n\t\t\t\t\tdate: quote,\n\t\t\t\t\tregexp: literal,\n\t\t\t\t\tnumber: literal,\n\t\t\t\t\t\"boolean\": literal\n\t\t\t\t},\n\t\n\t\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\t\tHTML: false,\n\t\n\t\t\t\t// Indentation unit\n\t\t\t\tindentChar: \"  \",\n\t\n\t\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\t\tmultiline: true\n\t\t\t};\n\t\n\t\treturn dump;\n\t}() );\n\t\n\t// Back compat\n\tQUnit.jsDump = QUnit.dump;\n\t\n\tfunction applyDeprecated( name ) {\n\t\treturn function() {\n\t\t\tthrow new Error(\n\t\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t};\n\t}\n\t\n\tObject.keys( Assert.prototype ).forEach( function( key ) {\n\t\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n\t} );\n\t\n\tQUnit.asyncTest = function() {\n\t\tthrow new Error(\n\t\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tQUnit.stop = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tQUnit.reset = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tif ( defined.document ) {\n\t\t[\n\t\t\t\"test\",\n\t\t\t\"module\",\n\t\t\t\"expect\",\n\t\t\t\"start\",\n\t\t\t\"ok\",\n\t\t\t\"notOk\",\n\t\t\t\"equal\",\n\t\t\t\"notEqual\",\n\t\t\t\"propEqual\",\n\t\t\t\"notPropEqual\",\n\t\t\t\"deepEqual\",\n\t\t\t\"notDeepEqual\",\n\t\t\t\"strictEqual\",\n\t\t\t\"notStrictEqual\",\n\t\t\t\"throws\",\n\t\t\t\"raises\"\n\t\t].forEach( function( key ) {\n\t\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t\t} );\n\t\n\t\twindow.QUnit = QUnit;\n\t}\n\t\n\t// For nodejs\n\tif ( typeof module !== \"undefined\" && module && module.exports ) {\n\t\tmodule.exports = QUnit;\n\t\n\t\t// For consistency with CommonJS environments' exports\n\t\tmodule.exports.QUnit = QUnit;\n\t}\n\t\n\t// For CommonJS with exports, but without module.exports, like Rhino\n\tif ( typeof exports !== \"undefined\" && exports ) {\n\t\texports.QUnit = QUnit;\n\t}\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn QUnit;\n\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\tQUnit.config.autostart = false;\n\t}\n\t\n\t// Get a reference to the global object, like window in browsers\n\t}( ( function() {\n\t\treturn this;\n\t}() ) ) );\n\t\n\t( function() {\n\t\n\t// Only interact with URLs via window.location\n\tvar location = typeof window !== \"undefined\" && window.location;\n\tif ( !location ) {\n\t\treturn;\n\t}\n\t\n\tvar urlParams = getUrlParams();\n\t\n\tQUnit.urlParams = urlParams;\n\t\n\t// Match module/test by inclusion in an array\n\tQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\n\tQUnit.config.testId = [].concat( urlParams.testId || [] );\n\t\n\t// Exact case-insensitive match of the module name\n\tQUnit.config.module = urlParams.module;\n\t\n\t// Regular expression or case-insenstive substring match against \"moduleName: testName\"\n\tQUnit.config.filter = urlParams.filter;\n\t\n\t// Test order randomization\n\tif ( urlParams.seed === true ) {\n\t\n\t\t// Generate a random seed if the option is specified without a value\n\t\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n\t} else if ( urlParams.seed ) {\n\t\tQUnit.config.seed = urlParams.seed;\n\t}\n\t\n\t// Add URL-parameter-mapped config values with UI form rendering data\n\tQUnit.config.urlConfig.push(\n\t\t{\n\t\t\tid: \"hidepassed\",\n\t\t\tlabel: \"Hide passed tests\",\n\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t);\n\t\n\tQUnit.begin( function() {\n\t\tvar i, option,\n\t\t\turlConfig = QUnit.config.urlConfig;\n\t\n\t\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\t\n\t\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\t\toption = QUnit.config.urlConfig[ i ];\n\t\t\tif ( typeof option !== \"string\" ) {\n\t\t\t\toption = option.id;\n\t\t\t}\n\t\n\t\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tfunction getUrlParams() {\n\t\tvar i, param, name, value;\n\t\tvar urlParams = {};\n\t\tvar params = location.search.slice( 1 ).split( \"&\" );\n\t\tvar length = params.length;\n\t\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tif ( params[ i ] ) {\n\t\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\t\tname = decodeURIComponent( param[ 0 ] );\n\t\n\t\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t\tvalue = param.length === 1 ||\n\t\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t\t} else {\n\t\t\t\t\turlParams[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn urlParams;\n\t}\n\t\n\t// Don't load the HTML Reporter on non-browser environments\n\tif ( typeof window === \"undefined\" || !window.document ) {\n\t\treturn;\n\t}\n\t\n\tQUnit.init = function() {\n\t\tthrow new Error(\n\t\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n\t\n\tvar config = QUnit.config,\n\t\tdocument = window.document,\n\t\tcollapseNext = false,\n\t\thasOwn = Object.prototype.hasOwnProperty,\n\t\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\t\tmoduleId: undefined, testId: undefined } ),\n\t\tdefined = {\n\t\t\tsessionStorage: ( function() {\n\t\t\t\tvar x = \"qunit-test-string\";\n\t\t\t\ttry {\n\t\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\t\treturn true;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}() )\n\t\t},\n\t\tmodulesList = [];\n\t\n\t// Escape text for attribute or text content.\n\tfunction escapeText( s ) {\n\t\tif ( !s ) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = s + \"\";\n\t\n\t\t// Both single quotes and double quotes (for attributes)\n\t\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\t\tswitch ( s ) {\n\t\t\tcase \"'\":\n\t\t\t\treturn \"&#039;\";\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn \"&quot;\";\n\t\t\tcase \"<\":\n\t\t\t\treturn \"&lt;\";\n\t\t\tcase \">\":\n\t\t\t\treturn \"&gt;\";\n\t\t\tcase \"&\":\n\t\t\t\treturn \"&amp;\";\n\t\t\t}\n\t\t} );\n\t}\n\t\n\tfunction addEvent( elem, type, fn ) {\n\t\telem.addEventListener( type, fn, false );\n\t}\n\t\n\tfunction removeEvent( elem, type, fn ) {\n\t\telem.removeEventListener( type, fn, false );\n\t}\n\t\n\tfunction addEvents( elems, type, fn ) {\n\t\tvar i = elems.length;\n\t\twhile ( i-- ) {\n\t\t\taddEvent( elems[ i ], type, fn );\n\t\t}\n\t}\n\t\n\tfunction hasClass( elem, name ) {\n\t\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n\t}\n\t\n\tfunction addClass( elem, name ) {\n\t\tif ( !hasClass( elem, name ) ) {\n\t\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t\t}\n\t}\n\t\n\tfunction toggleClass( elem, name, force ) {\n\t\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\t\taddClass( elem, name );\n\t\t} else {\n\t\t\tremoveClass( elem, name );\n\t\t}\n\t}\n\t\n\tfunction removeClass( elem, name ) {\n\t\tvar set = \" \" + elem.className + \" \";\n\t\n\t\t// Class name may appear multiple times\n\t\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t\t}\n\t\n\t\t// Trim for prettiness\n\t\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n\t}\n\t\n\tfunction id( name ) {\n\t\treturn document.getElementById && document.getElementById( name );\n\t}\n\t\n\tfunction getUrlConfigHtml() {\n\t\tvar i, j, val,\n\t\t\tescaped, escapedTooltip,\n\t\t\tselection = false,\n\t\t\turlConfig = config.urlConfig,\n\t\t\turlConfigHtml = \"\";\n\t\n\t\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\t\n\t\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\t\tval = config.urlConfig[ i ];\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\tval = {\n\t\t\t\t\tid: val,\n\t\t\t\t\tlabel: val\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tescaped = escapeText( val.id );\n\t\t\tescapedTooltip = escapeText( val.tooltip );\n\t\n\t\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t\t} else {\n\t\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\t\n\t\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t\turlConfigHtml += \"</select>\";\n\t\t\t}\n\t\t}\n\t\n\t\treturn urlConfigHtml;\n\t}\n\t\n\t// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n\t// Updates the URL with the new state of `config.urlConfig` values.\n\tfunction toolbarChanged() {\n\t\tvar updatedUrl, value, tests,\n\t\t\tfield = this,\n\t\t\tparams = {};\n\t\n\t\t// Detect if field is a select menu or a checkbox\n\t\tif ( \"selectedIndex\" in field ) {\n\t\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t\t} else {\n\t\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t\t}\n\t\n\t\tparams[ field.name ] = value;\n\t\tupdatedUrl = setUrl( params );\n\t\n\t\t// Check if we can apply the change without a page refresh\n\t\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\t\tQUnit.urlParams[ field.name ] = value;\n\t\t\tconfig[ field.name ] = value || false;\n\t\t\ttests = id( \"qunit-tests\" );\n\t\t\tif ( tests ) {\n\t\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t\t}\n\t\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t\t} else {\n\t\t\twindow.location = updatedUrl;\n\t\t}\n\t}\n\t\n\tfunction setUrl( params ) {\n\t\tvar key, arrValue, i,\n\t\t\tquerystring = \"?\",\n\t\t\tlocation = window.location;\n\t\n\t\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\t\n\t\tfor ( key in params ) {\n\t\n\t\t\t// Skip inherited or undefined properties\n\t\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\t\n\t\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tquerystring += \"&\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn location.protocol + \"//\" + location.host +\n\t\t\tlocation.pathname + querystring.slice( 0, -1 );\n\t}\n\t\n\tfunction applyUrlParams() {\n\t\tvar i,\n\t\t\tselectedModules = [],\n\t\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\t\tfilter = id( \"qunit-filter-input\" ).value;\n\t\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\tif ( modulesList[ i ].checked ) {\n\t\t\t\tselectedModules.push( modulesList[ i ].getAttribute( \"module-id\" ) );\n\t\t\t}\n\t\t}\n\t\n\t\twindow.location = setUrl( {\n\t\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\t\n\t\t\t// Remove module and testId filter\n\t\t\tmodule: undefined,\n\t\t\ttestId: undefined\n\t\t} );\n\t}\n\t\n\tfunction toolbarUrlConfigContainer() {\n\t\tvar urlConfigContainer = document.createElement( \"span\" );\n\t\n\t\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\t\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\t\n\t\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\t\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\t\n\t\treturn urlConfigContainer;\n\t}\n\t\n\tfunction toolbarLooseFilter() {\n\t\tvar filter = document.createElement( \"form\" ),\n\t\t\tlabel = document.createElement( \"label\" ),\n\t\t\tinput = document.createElement( \"input\" ),\n\t\t\tbutton = document.createElement( \"button\" );\n\t\n\t\taddClass( filter, \"qunit-filter\" );\n\t\n\t\tlabel.innerHTML = \"Filter: \";\n\t\n\t\tinput.type = \"text\";\n\t\tinput.value = config.filter || \"\";\n\t\tinput.name = \"filter\";\n\t\tinput.id = \"qunit-filter-input\";\n\t\n\t\tbutton.innerHTML = \"Go\";\n\t\n\t\tlabel.appendChild( input );\n\t\n\t\tfilter.appendChild( label );\n\t\tfilter.appendChild( button );\n\t\taddEvent( filter, \"submit\", function( ev ) {\n\t\t\tapplyUrlParams();\n\t\n\t\t\tif ( ev && ev.preventDefault ) {\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t} );\n\t\n\t\treturn filter;\n\t}\n\t\n\tfunction moduleDropDownHtml () {\n\t\tvar i,\n\t\t\tdropDownHtml = \"\";\n\t\n\t\tif ( !config.modules.length ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\t\tdropDownHtml += \"<li><label><input type='checkbox' \" +\n\t\t\t\t\"module-id='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t\t( config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1 ? \" checked\" : \"\" ) +\n\t\t\t\t\">\" + escapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t\t}\n\t\t}\n\t\treturn dropDownHtml;\n\t}\n\t\n\tfunction toolbarModuleFilter () {\n\t\tvar dropDownHtml = moduleDropDownHtml(),\n\t\t\ttoolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\t\tlabel = document.createElement( \"label\" ),\n\t\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\t\tmoduleFilterComponent = document.createElement( \"div\" ),\n\t\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\t\tdropDownContainer = document.createElement( \"div\" ),\n\t\t\tdropDownList = document.createElement( \"ul\" ),\n\t\t\tclearFilter = document.createElement( \"span\" );\n\t\n\t\tif ( !toolbar || !dropDownHtml ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tmoduleSearch.placeholder = \"Select modules\";\n\t\n\t\tlabel.innerHTML = \"Module: \";\n\t\n\t\tclearFilter.id = \"clear-module-filter\";\n\t\tclearFilter.innerHTML = \"<span id='clear-module-filter-text'>All modules</span><hr/>\";\n\t\n\t\tclearFilter.onclick = function() {\n\t\t\tvar i,\n\t\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" );\n\t\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\t\tmodulesList[ i ].checked = false;\n\t\t\t}\n\t\t\tapplyUrlParams();\n\t\t};\n\t\n\t\tmoduleFilter.id = \"qunit-modulefilter-container\";\n\t\tmoduleFilterComponent.id = \"qunit-modulefilter-component\";\n\t\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\t\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\t\tdropDownContainer.id = \"qunit-modulefilter-dropdown-container\";\n\t\n\t\tdropDownContainer.style.display = \"none\";\n\t\n\t\tdropDownContainer.appendChild( clearFilter );\n\t\tmoduleFilter.appendChild( label );\n\t\tmoduleFilter.appendChild( moduleFilterComponent );\n\t\tmoduleFilterComponent.appendChild( moduleSearch );\n\t\tmoduleFilterComponent.appendChild( dropDownContainer ) ;\n\t\n\t\t// Enables show/hide for the dropdown\n\t\taddEvent( moduleSearch, \"focus\", function() {\n\t\t\tvar dropDownList = id( \"qunit-modulefilter-dropdown-container\" );\n\t\t\tif ( dropDownList.style.display === \"none\" ) {\n\t\t\t\taddEvent( document, \"click\", function hideHandler( e )  {\n\t\t\t\t\tif ( !id( \"qunit-modulefilter-container\" ).contains( e.target ) ) {\n\t\t\t\t\t\tid( \"qunit-modulefilter-dropdown-container\" ).style.display = \"none\";\n\t\t\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tdropDownList.style.display = \"block\";\n\t\t\t}\n\t\t} );\n\t\n\t\t// Enables search to the module filter\n\t\taddEvent( moduleSearch, \"input\", function() {\n\t\t\tvar i,\n\t\t\tmoduleText,\n\t\t\tsearchText = this.value.toLowerCase(),\n\t\t\tlistItems = id( \"qunit-modulefilter-dropdown-list\" ).children;\n\t\n\t\t\tif ( !searchText ) {\n\t\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\t\tmoduleText = listItems[ i ].textContent.toLowerCase();\n\t\t\t\t\tif ( moduleText.indexOf( searchText ) > -1 ) {\n\t\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistItems[ i ].style.display = \"none\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tdropDownList.innerHTML = dropDownHtml;\n\t\tdropDownContainer.appendChild( dropDownList );\n\t\ttoolbar.appendChild( moduleFilter );\n\t}\n\t\n\tfunction appendToolbar() {\n\t\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\t\n\t\tif ( toolbar ) {\n\t\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\t\ttoolbarModuleFilter();\n\t\t}\n\t}\n\t\n\tfunction appendHeader() {\n\t\tvar header = id( \"qunit-header\" );\n\t\n\t\tif ( header ) {\n\t\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\t\"</a> \";\n\t\t}\n\t}\n\t\n\tfunction appendBanner() {\n\t\tvar banner = id( \"qunit-banner\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\t}\n\t\n\tfunction appendTestResults() {\n\t\tvar tests = id( \"qunit-tests\" ),\n\t\t\tresult = id( \"qunit-testresult\" );\n\t\n\t\tif ( result ) {\n\t\t\tresult.parentNode.removeChild( result );\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\ttests.innerHTML = \"\";\n\t\t\tresult = document.createElement( \"p\" );\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t\t}\n\t}\n\t\n\tfunction storeFixture() {\n\t\tvar fixture = id( \"qunit-fixture\" );\n\t\tif ( fixture ) {\n\t\t\tconfig.fixture = fixture.innerHTML;\n\t\t}\n\t}\n\t\n\tfunction appendFilteredTest() {\n\t\tvar testId = QUnit.config.testId;\n\t\tif ( !testId || testId.length <= 0 ) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\t\tescapeText( unfilteredUrl ) +\n\t\t\t\"'>Run all tests</a></div>\";\n\t}\n\t\n\tfunction appendUserAgent() {\n\t\tvar userAgent = id( \"qunit-userAgent\" );\n\t\n\t\tif ( userAgent ) {\n\t\t\tuserAgent.innerHTML = \"\";\n\t\t\tuserAgent.appendChild(\n\t\t\t\tdocument.createTextNode(\n\t\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\t\n\tfunction appendInterface() {\n\t\tvar qunit = id( \"qunit\" );\n\t\n\t\tif ( qunit ) {\n\t\t\tqunit.innerHTML =\n\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\tappendFilteredTest() +\n\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t}\n\t\n\t\tappendHeader();\n\t\tappendBanner();\n\t\tappendTestResults();\n\t\tappendUserAgent();\n\t\tappendToolbar();\n\t}\n\t\n\tfunction appendTestsList( modules ) {\n\t\tvar i, l, x, z, test, moduleObj;\n\t\n\t\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\t\tmoduleObj = modules[ i ];\n\t\n\t\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\t\ttest = moduleObj.tests[ x ];\n\t\n\t\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction appendTest( name, testId, moduleName ) {\n\t\tvar title, rerunTrigger, testBlock, assertList,\n\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\tif ( !tests ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttitle = document.createElement( \"strong\" );\n\t\ttitle.innerHTML = getNameHtml( name, moduleName );\n\t\n\t\trerunTrigger = document.createElement( \"a\" );\n\t\trerunTrigger.innerHTML = \"Rerun\";\n\t\trerunTrigger.href = setUrl( { testId: testId } );\n\t\n\t\ttestBlock = document.createElement( \"li\" );\n\t\ttestBlock.appendChild( title );\n\t\ttestBlock.appendChild( rerunTrigger );\n\t\ttestBlock.id = \"qunit-test-output-\" + testId;\n\t\n\t\tassertList = document.createElement( \"ol\" );\n\t\tassertList.className = \"qunit-assert-list\";\n\t\n\t\ttestBlock.appendChild( assertList );\n\t\n\t\ttests.appendChild( testBlock );\n\t}\n\t\n\t// HTML Reporter initialization and load\n\tQUnit.begin( function( details ) {\n\t\tvar i, moduleObj, tests;\n\t\n\t\t// Sort modules by name for the picker\n\t\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\t\tmoduleObj = details.modules[ i ];\n\t\t\tif ( moduleObj.name ) {\n\t\t\t\tmodulesList.push( moduleObj.name );\n\t\t\t}\n\t\t}\n\t\tmodulesList.sort( function( a, b ) {\n\t\t\treturn a.localeCompare( b );\n\t\t} );\n\t\n\t\t// Capture fixture HTML from the page\n\t\tstoreFixture();\n\t\n\t\t// Initialize QUnit elements\n\t\tappendInterface();\n\t\tappendTestsList( details.modules );\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests && config.hidepassed ) {\n\t\t\taddClass( tests, \"hidepass\" );\n\t\t}\n\t} );\n\t\n\tQUnit.done( function( details ) {\n\t\tvar i, key,\n\t\t\tbanner = id( \"qunit-banner\" ),\n\t\t\ttests = id( \"qunit-tests\" ),\n\t\t\thtml = [\n\t\t\t\t\"Tests completed in \",\n\t\t\t\tdetails.runtime,\n\t\t\t\t\" milliseconds.<br />\",\n\t\t\t\t\"<span class='passed'>\",\n\t\t\t\tdetails.passed,\n\t\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\t\tdetails.total,\n\t\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\t\tdetails.failed,\n\t\t\t\t\"</span> failed.\"\n\t\t\t].join( \"\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t\t}\n\t\n\t\tif ( config.altertitle && document.title ) {\n\t\n\t\t\t// Show ✖ for good, ✔ for bad suite result in title\n\t\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\t\tdocument.title = [\n\t\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t\t].join( \" \" );\n\t\t}\n\t\n\t\t// Clear own sessionStorage items if all tests passed\n\t\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\t\tkey = sessionStorage.key( i++ );\n\t\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Scroll back to top to show results\n\t\tif ( config.scrolltop && window.scrollTo ) {\n\t\t\twindow.scrollTo( 0, 0 );\n\t\t}\n\t} );\n\t\n\tfunction getNameHtml( name, module ) {\n\t\tvar nameHtml = \"\";\n\t\n\t\tif ( module ) {\n\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t\t}\n\t\n\t\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\t\n\t\treturn nameHtml;\n\t}\n\t\n\tQUnit.testStart( function( details ) {\n\t\tvar running, testBlock, bad;\n\t\n\t\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\t\tif ( testBlock ) {\n\t\t\ttestBlock.className = \"running\";\n\t\t} else {\n\t\n\t\t\t// Report later registered tests\n\t\t\tappendTest( details.name, details.testId, details.module );\n\t\t}\n\t\n\t\trunning = id( \"qunit-testresult\" );\n\t\tif ( running ) {\n\t\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\n\t\t\trunning.innerHTML = ( bad ?\n\t\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\t\"Running: <br />\" ) +\n\t\t\t\tgetNameHtml( details.name, details.module );\n\t\t}\n\t\n\t} );\n\t\n\tfunction stripHtml( string ) {\n\t\n\t\t// Strip tags, html entity and whitespaces\n\t\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n\t}\n\t\n\tQUnit.log( function( details ) {\n\t\tvar assertList, assertLi,\n\t\t\tmessage, expected, actual, diff,\n\t\t\tshowDiff = false,\n\t\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\t\n\t\tif ( !testItem ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\t\n\t\t// The pushFailure doesn't provide details.expected\n\t\t// when it calls, it's implicit to also not show expected and diff stuff\n\t\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\t\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\t\tif ( details.negative ) {\n\t\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t\t} else {\n\t\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t\t}\n\t\n\t\t\tactual = QUnit.dump.parse( details.actual );\n\t\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\t\tescapeText( expected ) +\n\t\t\t\t\"</pre></td></tr>\";\n\t\n\t\t\tif ( actual !== expected ) {\n\t\n\t\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\t\n\t\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t\t}\n\t\n\t\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\t\tif ( showDiff ) {\n\t\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t\t} else {\n\t\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\t\" serialization</td></tr>\";\n\t\t\t}\n\t\n\t\t\tif ( details.source ) {\n\t\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\tmessage += \"</table>\";\n\t\n\t\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t\t} else if ( !details.result && details.source ) {\n\t\t\tmessage += \"<table>\" +\n\t\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\t\"</table>\";\n\t\t}\n\t\n\t\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\t\n\t\tassertLi = document.createElement( \"li\" );\n\t\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\t\tassertLi.innerHTML = message;\n\t\tassertList.appendChild( assertLi );\n\t} );\n\t\n\tQUnit.testDone( function( details ) {\n\t\tvar testTitle, time, testItem, assertList,\n\t\t\tgood, bad, testCounts, skipped, sourceName,\n\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\tif ( !tests ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\t\n\t\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\t\n\t\tgood = details.passed;\n\t\tbad = details.failed;\n\t\n\t\t// Store result when possible\n\t\tif ( config.reorder && defined.sessionStorage ) {\n\t\t\tif ( bad ) {\n\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t\t} else {\n\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( bad === 0 ) {\n\t\n\t\t\t// Collapse the passing tests\n\t\t\taddClass( assertList, \"qunit-collapsed\" );\n\t\t} else if ( bad && config.collapse && !collapseNext ) {\n\t\n\t\t\t// Skip collapsing the first failing test\n\t\t\tcollapseNext = true;\n\t\t} else {\n\t\n\t\t\t// Collapse remaining tests\n\t\t\taddClass( assertList, \"qunit-collapsed\" );\n\t\t}\n\t\n\t\t// The testItem.firstChild is the test name\n\t\ttestTitle = testItem.firstChild;\n\t\n\t\ttestCounts = bad ?\n\t\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\t\"\";\n\t\n\t\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\t\tdetails.assertions.length + \")</b>\";\n\t\n\t\tif ( details.skipped ) {\n\t\t\ttestItem.className = \"skipped\";\n\t\t\tskipped = document.createElement( \"em\" );\n\t\t\tskipped.className = \"qunit-skipped-label\";\n\t\t\tskipped.innerHTML = \"skipped\";\n\t\t\ttestItem.insertBefore( skipped, testTitle );\n\t\t} else {\n\t\t\taddEvent( testTitle, \"click\", function() {\n\t\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t\t} );\n\t\n\t\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\t\n\t\t\ttime = document.createElement( \"span\" );\n\t\t\ttime.className = \"runtime\";\n\t\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\t\ttestItem.insertBefore( time, assertList );\n\t\t}\n\t\n\t\t// Show the source of the test when showing assertions\n\t\tif ( details.source ) {\n\t\t\tsourceName = document.createElement( \"p\" );\n\t\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\t\taddClass( sourceName, \"qunit-source\" );\n\t\t\tif ( bad === 0 ) {\n\t\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t\t}\n\t\t\taddEvent( testTitle, \"click\", function() {\n\t\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t\t} );\n\t\t\ttestItem.appendChild( sourceName );\n\t\t}\n\t} );\n\t\n\t// Avoid readyState issue with phantomjs\n\t// Ref: #818\n\tvar notPhantom = ( function( p ) {\n\t\treturn !( p && p.version && p.version.major > 0 );\n\t} )( window.phantom );\n\t\n\tif ( notPhantom && document.readyState === \"complete\" ) {\n\t\tQUnit.load();\n\t} else {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n\t\n\t/*\n\t * This file is a modified version of google-diff-match-patch's JavaScript implementation\n\t * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n\t * modifications are licensed as more fully set forth in LICENSE.txt.\n\t *\n\t * The original source of google-diff-match-patch is attributable and licensed as follows:\n\t *\n\t * Copyright 2006 Google Inc.\n\t * https://code.google.com/p/google-diff-match-patch/\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * https://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * More Info:\n\t *  https://code.google.com/p/google-diff-match-patch/\n\t *\n\t * Usage: QUnit.diff(expected, actual)\n\t *\n\t */\n\tQUnit.diff = ( function() {\n\t\tfunction DiffMatchPatch() {\n\t\t}\n\t\n\t\t//  DIFF FUNCTIONS\n\t\n\t\t/**\n\t\t * The data structure representing a diff is an array of tuples:\n\t\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t\t */\n\t\tvar DIFF_DELETE = -1,\n\t\t\tDIFF_INSERT = 1,\n\t\t\tDIFF_EQUAL = 0;\n\t\n\t\t/**\n\t\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t\t * any common prefix or suffix off the texts before diffing.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t\t *     then don't run a line-level diff first to identify the changed areas.\n\t\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\t\tvar deadline, checklines, commonlength,\n\t\t\t\tcommonprefix, commonsuffix, diffs;\n\t\n\t\t\t// The diff must be complete in up to 1 second.\n\t\t\tdeadline = ( new Date() ).getTime() + 1000;\n\t\n\t\t\t// Check for null inputs.\n\t\t\tif ( text1 === null || text2 === null ) {\n\t\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t\t}\n\t\n\t\t\t// Check for equality (speedup).\n\t\t\tif ( text1 === text2 ) {\n\t\t\t\tif ( text1 ) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\t\toptChecklines = true;\n\t\t\t}\n\t\n\t\t\tchecklines = optChecklines;\n\t\n\t\t\t// Trim off common prefix (speedup).\n\t\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\t\ttext1 = text1.substring( commonlength );\n\t\t\ttext2 = text2.substring( commonlength );\n\t\n\t\t\t// Trim off common suffix (speedup).\n\t\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\t\n\t\t\t// Compute the diff on the middle block.\n\t\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\t\n\t\t\t// Restore the prefix and suffix.\n\t\t\tif ( commonprefix ) {\n\t\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t\t}\n\t\t\tif ( commonsuffix ) {\n\t\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t\t}\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\treturn diffs;\n\t\t};\n\t\n\t\t/**\n\t\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\n\t\t\t// Is there an insertion operation before the last equality.\n\t\t\tpreIns = false;\n\t\n\t\t\t// Is there a deletion operation before the last equality.\n\t\t\tpreDel = false;\n\t\n\t\t\t// Is there an insertion operation after the last equality.\n\t\t\tpostIns = false;\n\t\n\t\t\t// Is there a deletion operation after the last equality.\n\t\t\tpostDel = false;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\n\t\t\t\t// Equality found.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\t\n\t\t\t\t\t\t// Candidate found.\n\t\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t}\n\t\t\t\t\tpostIns = postDel = false;\n\t\n\t\t\t\t// An insertion or deletion.\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\t\tpostDel = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostIns = true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * Five types to be split:\n\t\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t\t */\n\t\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\t\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tif ( preIns && preDel ) {\n\t\n\t\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Convert a diff array into a pretty HTML report.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t * @param {integer} string to be beautified.\n\t\t * @return {string} HTML representation.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\t\tvar op, data, x,\n\t\t\t\thtml = [];\n\t\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\t\tswitch ( op ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn html.join( \"\" );\n\t\t};\n\t\n\t\t/**\n\t\t * Determine the common prefix of two strings.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the start of each\n\t\t *     string.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\n\t\t\t// Quick check for common null cases.\n\t\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min( text1.length, text2.length );\n\t\t\tpointermid = pointermax;\n\t\t\tpointerstart = 0;\n\t\t\twhile ( pointermin < pointermid ) {\n\t\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerstart = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\t\n\t\t/**\n\t\t * Determine the common suffix of two strings.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the end of each string.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\n\t\t\t// Quick check for common null cases.\n\t\t\tif ( !text1 ||\n\t\t\t\t\t!text2 ||\n\t\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min( text1.length, text2.length );\n\t\t\tpointermid = pointermax;\n\t\t\tpointerend = 0;\n\t\t\twhile ( pointermin < pointermid ) {\n\t\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerend = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\t\n\t\t/**\n\t\t * Find the differences between two texts.  Assumes that the texts do not\n\t\t * have any common prefix or suffix.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t\t *     line-level diff first to identify the changed areas.\n\t\t *     If true, then run a faster, slightly less optimal diff.\n\t\t * @param {number} deadline Time when the diff should be complete by.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\t\tmidCommon, diffsA, diffsB;\n\t\n\t\t\tif ( !text1 ) {\n\t\n\t\t\t\t// Just add some text (speedup).\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\tif ( !text2 ) {\n\t\n\t\t\t\t// Just delete some text (speedup).\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\ti = longtext.indexOf( shorttext );\n\t\t\tif ( i !== -1 ) {\n\t\n\t\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\t\tdiffs = [\n\t\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t\t];\n\t\n\t\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t}\n\t\t\t\treturn diffs;\n\t\t\t}\n\t\n\t\t\tif ( shorttext.length === 1 ) {\n\t\n\t\t\t\t// Single character string.\n\t\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t\t];\n\t\t\t}\n\t\n\t\t\t// Check to see if the problem can be split in two.\n\t\t\thm = this.diffHalfMatch( text1, text2 );\n\t\t\tif ( hm ) {\n\t\n\t\t\t\t// A half-match was found, sort out the return data.\n\t\t\t\ttext1A = hm[ 0 ];\n\t\t\t\ttext1B = hm[ 1 ];\n\t\t\t\ttext2A = hm[ 2 ];\n\t\t\t\ttext2B = hm[ 3 ];\n\t\t\t\tmidCommon = hm[ 4 ];\n\t\n\t\t\t\t// Send both pairs off for separate processing.\n\t\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\t\n\t\t\t\t// Merge the results.\n\t\t\t\treturn diffsA.concat( [\n\t\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t\t], diffsB );\n\t\t\t}\n\t\n\t\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t\t}\n\t\n\t\t\treturn this.diffBisect( text1, text2, deadline );\n\t\t};\n\t\n\t\t/**\n\t\t * Do the two texts share a substring which is at least half the length of the\n\t\t * longer text?\n\t\t * This speedup can produce non-minimal diffs.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t\t *     text2 and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\t\tvar longtext, shorttext, dmp,\n\t\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\t\thm1, hm2, hm;\n\t\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\t\treturn null; // Pointless.\n\t\t\t}\n\t\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\t\n\t\t\t/**\n\t\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t\t * is at least half the length of longtext?\n\t\t\t * Closure, but does not reference any external variables.\n\t\t\t * @param {string} longtext Longer string.\n\t\t\t * @param {string} shorttext Shorter string.\n\t\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t\t * @private\n\t\t\t */\n\t\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\n\t\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\t\tj = -1;\n\t\t\t\tbestCommon = \"\";\n\t\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// First check if the second quarter is the seed for a half-match.\n\t\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\t\tMath.ceil( longtext.length / 4 ) );\n\t\n\t\t\t// Check again based on the third quarter.\n\t\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\t\tif ( !hm1 && !hm2 ) {\n\t\t\t\treturn null;\n\t\t\t} else if ( !hm2 ) {\n\t\t\t\thm = hm1;\n\t\t\t} else if ( !hm1 ) {\n\t\t\t\thm = hm2;\n\t\t\t} else {\n\t\n\t\t\t\t// Both matched.  Select the longest.\n\t\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t\t}\n\t\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A, text1B, text2A, text2B;\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\ttext1A = hm[ 0 ];\n\t\t\t\ttext1B = hm[ 1 ];\n\t\t\t\ttext2A = hm[ 2 ];\n\t\t\t\ttext2B = hm[ 3 ];\n\t\t\t} else {\n\t\t\t\ttext2A = hm[ 0 ];\n\t\t\t\ttext2B = hm[ 1 ];\n\t\t\t\ttext1A = hm[ 2 ];\n\t\t\t\ttext1B = hm[ 3 ];\n\t\t\t}\n\t\t\tmidCommon = hm[ 4 ];\n\t\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t\t};\n\t\n\t\t/**\n\t\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t\t * greater accuracy.\n\t\t * This speedup can produce non-minimal diffs.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} deadline Time when the diff should be complete by.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\t\tcountDelete, textInsert, textDelete, j;\n\t\n\t\t\t// Scan the text on a line-by-line basis first.\n\t\t\ta = this.diffLinesToChars( text1, text2 );\n\t\t\ttext1 = a.chars1;\n\t\t\ttext2 = a.chars2;\n\t\t\tlinearray = a.lineArray;\n\t\n\t\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\t\n\t\t\t// Convert the diff back to original text.\n\t\t\tthis.diffCharsToLines( diffs, linearray );\n\t\n\t\t\t// Eliminate freak matches (e.g. blank lines)\n\t\t\tthis.diffCleanupSemantic( diffs );\n\t\n\t\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t\t// Add a dummy entry at the end.\n\t\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\t\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\n\t\t\treturn diffs;\n\t\t};\n\t\n\t\t/**\n\t\t * Find the 'middle snake' of a diff, split the problem in two\n\t\t * and return the recursively constructed diff.\n\t\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} deadline Time at which to bail if not yet complete.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\t\tvOffset = maxD;\n\t\t\tvLength = 2 * maxD;\n\t\t\tv1 = new Array( vLength );\n\t\t\tv2 = new Array( vLength );\n\t\n\t\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t\t// integers and undefined.\n\t\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\t\tv1[ x ] = -1;\n\t\t\t\tv2[ x ] = -1;\n\t\t\t}\n\t\t\tv1[ vOffset + 1 ] = 0;\n\t\t\tv2[ vOffset + 1 ] = 0;\n\t\t\tdelta = text1Length - text2Length;\n\t\n\t\t\t// If the total number of characters is odd, then the front path will collide\n\t\t\t// with the reverse path.\n\t\t\tfront = ( delta % 2 !== 0 );\n\t\n\t\t\t// Offsets for start and end of k loop.\n\t\t\t// Prevents mapping of space beyond the grid.\n\t\t\tk1start = 0;\n\t\t\tk1end = 0;\n\t\t\tk2start = 0;\n\t\t\tk2end = 0;\n\t\t\tfor ( d = 0; d < maxD; d++ ) {\n\t\n\t\t\t\t// Bail out if deadline is reached.\n\t\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\t\t\t// Walk the front path one step.\n\t\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty1 = x1 - k1;\n\t\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\t\tx1++;\n\t\t\t\t\t\ty1++;\n\t\t\t\t\t}\n\t\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\t\tif ( x1 > text1Length ) {\n\t\n\t\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\t\tk1end += 2;\n\t\t\t\t\t} else if ( y1 > text2Length ) {\n\t\n\t\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\t\tk1start += 2;\n\t\t\t\t\t} else if ( front ) {\n\t\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\t\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Walk the reverse path one step.\n\t\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty2 = x2 - k2;\n\t\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\t\tx2++;\n\t\t\t\t\t\ty2++;\n\t\t\t\t\t}\n\t\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\t\tif ( x2 > text1Length ) {\n\t\n\t\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\t\tk2end += 2;\n\t\t\t\t\t} else if ( y2 > text2Length ) {\n\t\n\t\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\t\tk2start += 2;\n\t\t\t\t\t} else if ( !front ) {\n\t\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Diff took too long and hit the deadline or\n\t\t\t// number of diffs equals number of characters, no commonality at all.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t};\n\t\n\t\t/**\n\t\t * Given the location of the 'middle snake', split the diff in two parts\n\t\t * and recurse.\n\t\t * @param {string} text1 Old string to be diffed.\n\t\t * @param {string} text2 New string to be diffed.\n\t\t * @param {number} x Index of split point in text1.\n\t\t * @param {number} y Index of split point in text2.\n\t\t * @param {number} deadline Time at which to bail if not yet complete.\n\t\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\t\ttext1a = text1.substring( 0, x );\n\t\t\ttext2a = text2.substring( 0, y );\n\t\t\ttext1b = text1.substring( x );\n\t\t\ttext2b = text2.substring( y );\n\t\n\t\t\t// Compute both diffs serially.\n\t\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\t\n\t\t\treturn diffs.concat( diffsb );\n\t\t};\n\t\n\t\t/**\n\t\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\n\t\t\t// Number of characters that changed prior to the equality.\n\t\t\tlengthInsertions1 = 0;\n\t\t\tlengthDeletions1 = 0;\n\t\n\t\t\t// Number of characters that changed after the equality.\n\t\t\tlengthInsertions2 = 0;\n\t\t\tlengthDeletions2 = 0;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else { // An insertion or deletion.\n\t\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t\t// sides of it.\n\t\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\t\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\n\t\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\t\tequalitiesLength--;\n\t\n\t\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\n\t\t\t\t\t\t// Reset the counters.\n\t\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\t// Normalize the diff.\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\n\t\t\t// Find any overlaps between deletions and insertions.\n\t\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\t\tpointer = 1;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\t\n\t\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\t\n\t\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Determine if the suffix of one string is the prefix of another.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {number} The number of characters common to the end of the first\n\t\t *     string and the start of the second string.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\t\tvar text1Length, text2Length, textLength,\n\t\t\t\tbest, length, pattern, found;\n\t\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\n\t\t\t// Eliminate the null case.\n\t\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Truncate the longer string.\n\t\t\tif ( text1Length > text2Length ) {\n\t\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t\t} else if ( text1Length < text2Length ) {\n\t\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t\t}\n\t\t\ttextLength = Math.min( text1Length, text2Length );\n\t\n\t\t\t// Quick check for the worst case.\n\t\t\tif ( text1 === text2 ) {\n\t\t\t\treturn textLength;\n\t\t\t}\n\t\n\t\t\t// Start by looking for a single character match\n\t\t\t// and increase length until no match is found.\n\t\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\t\tbest = 0;\n\t\t\tlength = 1;\n\t\t\twhile ( true ) {\n\t\t\t\tpattern = text1.substring( textLength - length );\n\t\t\t\tfound = text2.indexOf( pattern );\n\t\t\t\tif ( found === -1 ) {\n\t\t\t\t\treturn best;\n\t\t\t\t}\n\t\t\t\tlength += found;\n\t\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\t\tbest = length;\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * @param {string} text1 First string.\n\t\t * @param {string} text2 Second string.\n\t\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t\t *     An object containing the encoded text1, the encoded text2 and\n\t\t *     the array of unique strings.\n\t\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\t\tvar lineArray, lineHash, chars1, chars2;\n\t\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\t\n\t\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\t\tlineArray[ 0 ] = \"\";\n\t\n\t\t\t/**\n\t\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t\t * hashes where each Unicode character represents one line.\n\t\t\t * Modifies linearray and linehash through being a closure.\n\t\t\t * @param {string} text String to encode.\n\t\t\t * @return {string} Encoded string.\n\t\t\t * @private\n\t\t\t */\n\t\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\t\tchars = \"\";\n\t\n\t\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\t\tlineStart = 0;\n\t\t\t\tlineEnd = -1;\n\t\n\t\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\t\tlineArrayLength = lineArray.length;\n\t\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t\t}\n\t\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\t\tlineStart = lineEnd + 1;\n\t\n\t\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn chars;\n\t\t\t}\n\t\n\t\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\t\treturn {\n\t\t\t\tchars1: chars1,\n\t\t\t\tchars2: chars2,\n\t\t\t\tlineArray: lineArray\n\t\t\t};\n\t\t};\n\t\n\t\t/**\n\t\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t\t * text.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t\t * @private\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\t\tvar x, chars, text, y;\n\t\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\t\ttext = [];\n\t\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t\t}\n\t\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Reorder and merge like edit sections.  Merge equalities.\n\t\t * Any edit section can move as long as it doesn't cross an equality.\n\t\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t */\n\t\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\t\tcommonlength, changes, diffPointer, position;\n\t\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\tcommonlength;\n\t\t\twhile ( pointer < diffs.length ) {\n\t\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\t\n\t\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\t\n\t\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t\t}\n\t\n\t\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t\t// which can be shifted sideways to eliminate an equality.\n\t\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\t\tchanges = false;\n\t\t\tpointer = 1;\n\t\n\t\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\t\n\t\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\t\n\t\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\t\n\t\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\n\t\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\t\tif ( changes ) {\n\t\t\t\tthis.diffCleanupMerge( diffs );\n\t\t\t}\n\t\t};\n\t\n\t\treturn function( o, n ) {\n\t\t\tvar diff, output, text;\n\t\t\tdiff = new DiffMatchPatch();\n\t\t\toutput = diff.DiffMain( o, n );\n\t\t\tdiff.diffCleanupEfficiency( output );\n\t\t\ttext = diff.diffPrettyHtml( output );\n\t\n\t\t\treturn text;\n\t\t};\n\t}() );\n\t\n\t}() );\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(13)(module)))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _jsmocktool = __webpack_require__(2);\n\t\n\tvar _qunit = __webpack_require__(8);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n\t                                                                                                                                                           * @author mixed\n\t                                                                                                                                                           */\n\t\n\tvar global = window;\n\t\n\t(0, _qunit.module)('jsmock - Object type', {\n\t  'beforeEach': function beforeEach() {\n\t    this.mock = (0, _jsmocktool.mock)('RECEIVE');\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    RECEIVE = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('Must be first prameter is string or object', function (assert) {\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO');\n\t  // Then\n\t  assert.deepEqual(FOO, {});\n\t\n\t  // Given\n\t  var BAR = {};\n\t  // When\n\t  (0, _jsmocktool.mock)(BAR);\n\t  // Then\n\t  assert.deepEqual(BAR, BAR);\n\t});\n\t\n\t(0, _qunit.test)(\"Must be second parameter is 'instance','object',none.\", function (assert) {\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO2');\n\t  // Then\n\t  assert.deepEqual(FOO2, {});\n\t\n\t  // Given\n\t  // When\n\t  (0, _jsmocktool.mock)('FOO3', _jsmocktool.mock.INSTANCE);\n\t  // Then\n\t  assert.equal(FOO3.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is set method of mock Object.', function (assert) {\n\t  // Given\n\t  var receiveMock = (0, _jsmocktool.mock)('RECEIVE');\n\t  // Then\n\t  receiveMock.should_receive('test');\n\t  // When\n\t  assert.equal(RECEIVE.test.constructor, Function);\n\t\n\t  // Given\n\t  var receiveMock2 = (0, _jsmocktool.mock)('RECEIVE2', _jsmocktool.mock.INSTANCE);\n\t  // Then\n\t  receiveMock2.should_receive('test');\n\t  // When\n\t  assert.equal(RECEIVE2.prototype.test.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('Return value of should_receive is MockMethod.', function (assert) {\n\t  // Given\n\t  var receive = (0, _jsmocktool.mock)('RECEIVE3');\n\t  // When\n\t  var mock_method = receive.should_receive('test');\n\t  // The MockMethod is private. so I can't test.\n\t  // Instead, I made a Ducktyping test(?).\n\t  // I believe correct when The return value of should_receive have and_return function.\n\t  // ok(stub_obj instanceof MockMethod);\n\t  // Then\n\t  assert.equal(mock_method.and_return.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The and_return is  setting value to return.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('RECEIVE4').should_receive('test').and_return(3);\n\t  // When\n\t  var returnVal = RECEIVE4.test();\n\t  // Then\n\t  assert.equal(returnVal, 3);\n\t});\n\t\n\t(0, _qunit.test)('If use with_param, mock will return value when same param.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('RECEIVE4').should_receive('test').with_param(1, 2).and_return(4);\n\t  // When\n\t  var returnVal = RECEIVE4.test(1, 2);\n\t  // Then\n\t  assert.equal(returnVal, 4);\n\t});\n\t\n\t(0, _qunit.test)('The Mock must be work mock before set parameter when add new parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').and_return(3);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(4);\n\t  this.mock.should_receive('test').with_param(1, 2, 3).and_return(5);\n\t  // When\n\t  var noneParam = RECEIVE.test();\n\t  var oneParam = RECEIVE.test(1, 2);\n\t  var twoParam = RECEIVE.test(1, 2, 3);\n\t  // Then\n\t  assert.equal(noneParam, 3);\n\t  assert.equal(oneParam, 4);\n\t  assert.equal(twoParam, 5);\n\t});\n\t\n\t(0, _qunit.test)('The Mock must be change return value when add same parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').and_return(3);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(4);\n\t  this.mock.should_receive('test').with_param(1, 2).and_return(5);\n\t  // When\n\t  var noneParam = RECEIVE.test();\n\t  var twoParam = RECEIVE.test(1, 2);\n\t  // Then\n\t  assert.equal(noneParam, 3);\n\t  assert.equal(twoParam, 5);\n\t});\n\t\n\t(0, _qunit.test)('The add_throw is throw exception when match param.', function (assert) {\n\t  // Given\n\t  var error_message = '';\n\t  this.mock.should_receive('test2').and_throw(new Error('and_throw test.'));\n\t  // When\n\t  try {\n\t    RECEIVE.test2();\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test.');\n\t});\n\t\n\t(0, _qunit.test)('If set with_param of and_throw then throw exception when match parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2.'));\n\t  var error_message = '';\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test2.');\n\t});\n\t\n\t(0, _qunit.test)('The and_throw is well work when change parameter', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param().and_throw(new Error('and_throw test'));\n\t  this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2'));\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test3'));\n\t  var error_message = '';\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2();\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test');\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test2');\n\t\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test3');\n\t});\n\t(0, _qunit.test)('The and_throw throw new exception when some function, same parameter, change exception.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test'));\n\t  var error_message = '';\n\t  // When\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(error_message, 'and_throw test');\n\t\n\t  // Then\n\t  this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('change throw'));\n\t  try {\n\t    RECEIVE.test2(1, 2, 3);\n\t  } catch (e) {\n\t    error_message = e.message;\n\t  }\n\t  // When\n\t  assert.equal(error_message, 'change throw');\n\t});\n\t\n\t(0, _qunit.test)('The and_function run function when set new function', function (assert) {\n\t\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').and_function(function () {\n\t    that.mock_test1 = 'first';\n\t  });\n\t  // Then\n\t  RECEIVE.test3();\n\t  // When\n\t  assert.equal(that.mock_test1, 'first');\n\t});\n\t\n\t(0, _qunit.test)('If set a with_param then the and_functon run function when only match parameter.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param(1, 2).and_function(function () {\n\t    that.mock_test2 = 'second';\n\t  });\n\t  // Then\n\t  RECEIVE.test3(1, 2);\n\t  // When\n\t  assert.equal(that.mock_test2, 'second');\n\t});\n\t\n\t(0, _qunit.test)('Then and_function is well work when same function change parameter.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param().and_function(function () {\n\t    that.mock_test1 = 'first';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2).and_function(function () {\n\t    that.mock_test2 = 'second';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'third';\n\t  });\n\t  // When\n\t  RECEIVE.test3();\n\t  // Then\n\t  assert.equal(that.mock_test1, 'first');\n\t\n\t  // When\n\t  RECEIVE.test3(1, 2);\n\t  // Then\n\t  assert.equal(that.mock_test2, 'second');\n\t\n\t  // When\n\t  RECEIVE.test3(1, 2, 3);\n\t  // Then\n\t  assert.equal(that.mock_test3, 'third');\n\t});\n\t(0, _qunit.test)('The and_function run new function when some function, same parameter, change and_function.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'third';\n\t  });\n\t  this.mock.should_receive('test3').with_param(1, 2, 3).and_function(function () {\n\t    that.mock_test3 = 'change third';\n\t  });\n\t  // When\n\t  RECEIVE.test3(1, 2, 3);\n\t  // Then\n\t  assert.equal(that.mock_test3, 'change third');\n\t});\n\t(0, _qunit.test)('If use Mock.anything when run function without reference to parameter.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('test').with_param(1, 2).and_return('1');\n\t  this.mock.should_receive('test').with_param(1, 2, _jsmocktool.mock.anything()).and_return('2');\n\t  this.mock.should_receive('test').with_param(1, 2, _jsmocktool.mock.anything(), _jsmocktool.mock.anything()).and_return('3');\n\t\n\t  // When, Then\n\t  assert.equal(RECEIVE.test(1, 2), '1');\n\t  assert.equal(RECEIVE.test(1, 2, 3), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 1), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 4), '2');\n\t  assert.equal(RECEIVE.test(1, 2, 4, 5), '3');\n\t  assert.equal(RECEIVE.test(1, 2, 4, 6), '3');\n\t});\n\t\n\t//    'param에 anything이 들어간 파라메터에서 다시 설정한 경우에 다시 설정한 값으로 반환 해야 한다.':function(){\n\t//      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"5\");\n\t//      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"5\");\n\t\n\t//      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"6\");\n\t//      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"6\");\n\t\n\t//    },\n\t\n\t(0, _qunit.module)('jsmock - other type', {\n\t  'beforeEach': function beforeEach() {\n\t\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    global.MockInstance = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('The instance type is well work too.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  var receive = (0, _jsmocktool.mock)('MockInstance', _jsmocktool.mock.INSTANCE);\n\t  receive.should_receive('test').with_param(1).and_return('1');\n\t  receive.should_receive('test').with_param(2).and_throw(new Error('test'));\n\t  receive.should_receive('test').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'test';\n\t  });\n\t  var errormessage = '';\n\t\n\t  // When\n\t  var mockInstance = new MockInstance();\n\t  // Then\n\t  assert.equal(mockInstance.test(1), '1');\n\t\n\t  // When\n\t  try {\n\t    mockInstance.test(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, 'test');\n\t\n\t  // When\n\t  mockInstance.test(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'test');\n\t});\n\t\n\t(0, _qunit.test)('The normal functon is well work too.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  var receive = (0, _jsmocktool.mock)(global);\n\t  receive.should_receive('commonfunc').with_param(1).and_return('1');\n\t  receive.should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n\t  receive.should_receive('commonfunc').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'commonfunc';\n\t  });\n\t  var errormessage = '';\n\t\n\t  // When\n\t  var returnVal = commonfunc(1);\n\t  // Then\n\t  assert.equal(returnVal, '1');\n\t\n\t  // When\n\t  try {\n\t    commonfunc(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, 'test2');\n\t\n\t  // When\n\t  commonfunc(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'commonfunc');\n\t});\n\t\n\t(0, _qunit.test)('The namespace type is well work too.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaaa.bbbb.cccc', _jsmocktool.mock.INSTANCE).should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\t\n\t  // Given\n\t  global['aaaaa'] = {};\n\t  aaaaa.bbbbb = {};\n\t  (0, _jsmocktool.mock)('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t  // When, Then\n\t  assert.equal(aaaaa.bbbbb.test(), 'test');\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t  // When,Then\n\t  assert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('The with_param well work when use namespace.', function (assert) {\n\t  // Given\n\t  var that = this;\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(1).and_return('1');\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n\t  (0, _jsmocktool.mock)('param.test').should_receive('commonfunc').with_param(3).and_function(function () {\n\t    that.mock_test1 = 'commonfunc';\n\t  });\n\t\n\t  // When, Then\n\t  assert.equal(param.test.commonfunc(1), '1');\n\t\n\t  // Given\n\t  var errormessage = '';\n\t  try {\n\t    param.test.commonfunc(2);\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // When, Then\n\t  assert.equal(errormessage, 'test2');\n\t\n\t  // When\n\t  param.test.commonfunc(3);\n\t  // Then\n\t  assert.equal(that.mock_test1, 'commonfunc');\n\t});\n\t\n\t(0, _qunit.module)('jsmock - verify', {\n\t  'beforeEach': function beforeEach() {\n\t    this.mock = (0, _jsmocktool.mock)('Verify');\n\t    this.mock_test1 = '';\n\t    this.mock_test2 = '';\n\t    this.mock_test3 = '';\n\t  },\n\t  'afterEach': function afterEach() {\n\t    this.mock = undefined;\n\t    Verify = undefined;\n\t  }\n\t});\n\t\n\t(0, _qunit.test)('The verify is well work.', function (assert) {\n\t  // Given\n\t  this.mock.should_receive('kall').with_param(1, 2).and_return('1');\n\t  this.mock.should_receive('kall2').and_return('1');\n\t  Verify.kall(1, 2);\n\t  var errormessage = '';\n\t  // When\n\t  var result = this.mock.verify('kall');\n\t  // Then\n\t  assert.deepEqual(result, { 'total': 1, 'param': { '[1,2]': 1 } });\n\t\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify').verify('kall2');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall2 isn't called.\");\n\t\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify').verify('kall3');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall3 isn't method.\");\n\t});\n\t(0, _qunit.test)('The verify_all is check all method.', function (assert) {\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify2').should_receive('kall').with_param(1, 2).and_return('1');\n\t  (0, _jsmocktool.mock)('Verify2').should_receive('kall2').and_return('1');\n\t  Verify2.kall(1, 2);\n\t  Verify2.kall2();\n\t  var returnVal;\n\t  // When\n\t  returnVal = (0, _jsmocktool.mock)('Verify2').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\t\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify3').should_receive('kall').with_param(1, 2).and_return('1');\n\t  var errormessage;\n\t  // When\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify3').verify_all();\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t(0, _qunit.test)('The reset is remove info of function call.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify4').should_receive('kall').with_param(1, 2).and_return('1');\n\t  Verify4.kall(1, 2);\n\t  // When\n\t  var returnVal = (0, _jsmocktool.mock)('Verify4').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } } });\n\t\n\t  // Given\n\t  var errormessage;\n\t  // When\n\t  (0, _jsmocktool.mock)('Verify4').reset('kall');\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify4').verify('kall');\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t\n\t(0, _qunit.test)('The reset_all is remove all info of function call.', function (assert) {\n\t  // Given\n\t  (0, _jsmocktool.mock)('Verify5').should_receive('kall').with_param(1, 2).and_return('1');\n\t  (0, _jsmocktool.mock)('Verify5').should_receive('kall2').and_return('1');\n\t  Verify5.kall(1, 2);\n\t  Verify5.kall2();\n\t  // When\n\t  var returnVal = (0, _jsmocktool.mock)('Verify5').verify_all();\n\t  // Then\n\t  assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\t\n\t  // Given\n\t  var errormessage;\n\t  // When\n\t  (0, _jsmocktool.mock)('Verify5').reset_all();\n\t  try {\n\t    (0, _jsmocktool.mock)('Verify5').verify_all();\n\t  } catch (e) {\n\t    errormessage = e.message;\n\t  }\n\t  // Then\n\t  assert.equal(errormessage, \"kall isn't called.\");\n\t});\n\t\n\t(0, _qunit.module)('jsmock - Support Class');\n\t\n\t(0, _qunit.test)('Add method to Class', function (assert) {\n\t  // Given\n\t\n\t  var Test = function Test() {\n\t    _classCallCheck(this, Test);\n\t  };\n\t\n\t  // When\n\t\n\t\n\t  (0, _jsmocktool.mock)(Test, _jsmocktool.mock.INSTANCE).should_receive('kall').and_return('1');\n\t\n\t  // Then\n\t  var test = new Test();\n\t  assert.equal(test.kall(), '1');\n\t});\n\t\n\t(0, _qunit.test)('Add method to Class instance', function (assert) {\n\t  // Given\n\t\n\t  var Test = function Test() {\n\t    _classCallCheck(this, Test);\n\t  };\n\t\n\t  var test = new Test();\n\t\n\t  // When\n\t  (0, _jsmocktool.mock)(test).should_receive('kall').and_return('1');\n\t\n\t  // Then\n\t  assert.equal(test.kall(), '1');\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _jsmocktool = __webpack_require__(2);\n\t\n\tvar _qunit = __webpack_require__(8);\n\t\n\t/**\n\t * @author mixed\n\t */\n\t\n\tvar global = window;\n\t\n\t(0, _qunit.module)('jsstub', {\n\t\t'beforeEach': function beforeEach() {\n\t\n\t\t\tthis.originConsole = global.console;\n\t\t\tglobal.console = {\n\t\t\t\t'warn': function warn(msg) {}\n\t\t\t};\n\t\t\tthis.stub = (0, _jsmocktool.stub)('STUB');\n\t\t},\n\t\t'afterEach': function afterEach() {\n\t\t\tthis.stub = undefined;\n\t\t\tSTUB = undefined;\n\t\t\tglobal.console = this.originConsole;\n\t\t}\n\t});\n\t\n\t(0, _qunit.test)('The first parameter of stub is must be string,object.', function (assert) {\n\t\t// Given, When\n\t\t(0, _jsmocktool.stub)('FOO');\n\t\t// Then\n\t\tassert.deepEqual(FOO, {});\n\t\n\t\t// Given\n\t\tvar BAR = {};\n\t\t// When\n\t\t(0, _jsmocktool.stub)(BAR);\n\t\t// Then\n\t\tassert.deepEqual(BAR, BAR);\n\t});\n\t\n\t(0, _qunit.test)('The Stub is only add function when already made object.', function (assert) {\n\t\t// Given\n\t\tvar Obj = { test: function test() {} };\n\t\t// When\n\t\t(0, _jsmocktool.stub)('Obj');\n\t\t// Then\n\t\tassert.equal(Obj, Obj);\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)(Obj);\n\t\t// Then\n\t\tassert.equal(Obj, Obj);\n\t});\n\t\n\t(0, _qunit.test)(\"The second parameter of stub is must be none, 'instance' or 'object'\", function (assert) {\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('FOO2');\n\t\t// Then\n\t\tassert.deepEqual(FOO2, {});\n\t\n\t\t// when\n\t\t(0, _jsmocktool.stub)('FOO3', _jsmocktool.stub.INSTANCE);\n\t\t// Then\n\t\tassert.equal(FOO3.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is set empty function', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test');\n\t\t// Then\n\t\tassert.equal(STUB.test.constructor, Function);\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('STUB2', _jsmocktool.stub.INSTANCE).should_receive('test');\n\t\t// Then\n\t\tassert.equal(STUB2.prototype.test.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The should_receive is change function when already function.', function (assert) {\n\t\t// Given\n\t\tvar funcObj = { test: function test() {\n\t\t\t\treturn false;\n\t\t\t} };\n\t\t// When\n\t\t(0, _jsmocktool.stub)('funcObj').should_receive('test');\n\t\t// Then\n\t\tassert.equal(funcObj.test(), '');\n\t});\n\t\n\t(0, _qunit.test)('Return value of should_receive is StubMethod.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tvar stub_obj = this.stub.should_receive('test');\n\t\t// Then\n\t\t// The StubMethod is private. so I can't test.\n\t\t// Instead, I made a Ducktyping test(?).\n\t\t// I believe correct when The return value of should_receive have and_return function.\n\t\t// ok(stub_obj instanceof StubMethod);\n\t\tassert.equal(stub_obj.and_return.constructor, Function);\n\t});\n\t\n\t(0, _qunit.test)('The and_return is return value when and_return set value.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(STUB.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('The namespace type is well work too.', function (assert) {\n\t\t// Given\n\t\t// When\n\t\tthis.stub.should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(STUB.test(), 'test');\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\t\n\t\t// Given\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaa.bbbb.cccc', _jsmocktool.stub.INSTANCE).should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\t\n\t\t// Given\n\t\tglobal['aaaaa'] = {};\n\t\taaaaa.bbbbb = {};\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaaaa.bbbbb.test(), 'test');\n\t\n\t\t// When\n\t\t(0, _jsmocktool.stub)('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t\t// Then\n\t\tassert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n\t});\n\t\n\t(0, _qunit.test)('deprecated stub.', function (assert) {\n\t\t// Given\n\t\tvar message = '';\n\t\tglobal.console = {\n\t\t\t'warn': function warn(msg) {\n\t\t\t\tmessage = msg;\n\t\t\t}\n\t\t};\n\t\t// When\n\t\t(0, _jsmocktool.stub)('FOO');\n\t\n\t\t// Then\n\t\tassert.equal(message, '[WARN] : Deprecated Stub. You should be change to Mock.');\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _qunit = __webpack_require__(8);\n\t\n\t(0, _qunit.start)();\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** test/dist/jsmocktool.test.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6df608e0d1c1c969df9c\n **/","const global = window;\n\nclass TestDouble {\n\tconstructor(name, type) {\n\t\tthis.createTestDouble(name, type);\n\t}\n\n\tcreateTestDouble(name, type) {\n\t\tthis.returnValue = '_js_testDouble_none';\n\t\tthis.testDoubleType = type;\n\n\t\tif (typeof name === 'string') {\n\t\t\tthis.makeEnableObj(name, type);\n\t\t} else if (typeof name === 'object' || typeof name === 'function') {\n\t\t\tthis.testDoubleObj = name;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t`Name of ${this.type} is incorrect.\n\t\t\tThe Type only have String or Object or Function.`);\n\t\t}\n\t}\n\n\tgetTestDouble() {\n\t\tif (this.testDoubleType === 'object') {\n\t\t\treturn this.testDoubleObj;\n\t\t}\n\t\treturn this.testDoubleObj.prototype;\n\t}\n\n\tmakeEnableObj(name, type) {\n\t\tconst depth = name.split('.');\n\t\tlet objectName = depth[0];\n\t\tlet obj = global;\n\t\tif (depth.length > 1) {\n\t\t\tdepth.splice(0, depth.length - 1).forEach((v) => {\n\t\t\t\tif (typeof obj[v] === 'undefined') {\n\t\t\t\t\tobj[v] = {};\n\t\t\t\t}\n\t\t\t\tobj = obj[v];\n\t\t\t});\n\t\t\tobjectName = depth[depth.length - 1];\n\t\t}\n\n\t\tconst returnObj = obj[objectName];\n\t\tthis.testDoubleObj = returnObj;\n\t\tif (type === 'object' && !returnObj) {\n\t\t\tthis.testDoubleObj = obj[objectName] = {};\n\t\t} else if (type === 'instance' && !returnObj) {\n\t\t\tthis.testDoubleObj = obj[objectName] = () => {};\n\t\t\tthis.testDoubleObj.prototype = obj[objectName].prototype = {};\n\t\t}\n\t}\n}\n\nexport default TestDouble;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/testDouble.js\n **/","import stub from './stub/jsstub';\nimport mock from './mock/jsmock';\n\nexport { stub, mock };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/jsmocktool.js\n **/","import MockMethodFactory from './jsmockMethodFactory';\nimport TestDouble from '../testDouble';\n\nclass Mock extends TestDouble {\n\tconstructor(name, type = 'object') {\n\t\tsuper(name, type);\n\t\tthis.type = 'Mock';\n\t}\n\n\tshould_receive(methodName) {\n\t\treturn MockMethodFactory.getMethod(this.getTestDouble(), methodName);\n\t}\n\n\treset_all() {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tfor (const i in obj) {\n\t\t\tif (i !== 'current_obj') {\n\t\t\t\tobj[i].record = { total: 0, param: {} };\n\t\t\t}\n\t\t}\n\t}\n\n\treset(methodName) {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tobj[methodName].record = { total: 0, param: {} };\n\t}\n\n\tverify(methodName) {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tif (obj[methodName]) {\n\t\t\tif (obj[methodName].record.total === 0) {\n\t\t\t\tthrow new Error(`${methodName} isn't called.`);\n\t\t\t} else {\n\t\t\t\treturn obj[methodName].record;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`${methodName} isn't method.`);\n\t\t}\n\t}\n\n\tverify_all() {\n\t\tconst obj = MockMethodFactory.getData(this.getTestDouble());\n\t\tconst returnValue = {};\n\t\tfor (const i in obj) {\n\t\t\tif (i !== 'current_obj') returnValue[i] = this.verify(i);\n\t\t}\n\t\treturn returnValue;\n\t}\n\n}\n\nfunction mockWrap(name, type) {\n\tif (this instanceof Mock) {\n\t\tthis.createTestDouble(name, type);\n\t} else {\n\t\treturn new Mock(name, type);\n\t}\n}\n\nmockWrap.OBJECT = 'object';\nmockWrap.INSTANCE = 'instance';\nmockWrap.anything = () => '_js_mock_anything_param';\n\nexport default mockWrap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmock.js\n **/","\n\nfunction argumentsToArray(arg) {\n\tconst returnVal = [];\n\tif (!!arg.length) {\n\t\tfor (let i = 0, l = arg.length; i < l; i++) {\n\t\t\treturnVal[i] = arg[i];\n\t\t}\n\t}\n\treturn returnVal;\n}\n\nclass MockMethod {\n\n\tconstructor(obj, methodName) {\n\t\tthis.excuteObjs = {\n\t\t//      key:{\n\t\t//          arg:[],\n\t\t//          type:\"function\",\n\t\t//          excute : function(){}\n\t\t//      }\n\t\t};\n\t\tthis.record = { total: 0, param: {} };\n\t\tthis.currentParam = JSON.stringify([]);\n\t\tthis.excuteObjs[this.currentParam] = {};\n\t\tthis.setup(obj, methodName);\n\t}\n\n\tsetup(obj, methodName) {\n\t\tconst that = this;\n\t\tconst target = obj;\n\t\ttarget[methodName] = function addFunc(...params) {\n\t\t\tthat.record.total++;\n\t\t\tconst argString = JSON.stringify(argumentsToArray(params));\n\n\t\t\tif (that.record.param[argString]) {\n\t\t\t\tthat.record.param[argString] += 1;\n\t\t\t} else {\n\t\t\t\tthat.record.param[argString] = 1;\n\t\t\t}\n\n\t\t\tconst dataObj = that.excuteObjs[argString];\n\n\t\t\tif (dataObj) {\n\t\t\t\tif (dataObj.type === 'function') {\n\t\t\t\t\treturn dataObj.excute.apply(dataObj, argumentsToArray(params));\n\t\t\t\t} else if (dataObj.type === 'exception') {\n\t\t\t\t\tthrow dataObj.excute;\n\t\t\t\t} else if (dataObj.type === 'return') {\n\t\t\t\t\treturn dataObj.excute;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const i in that.excuteObjs) {\n\t\t\t\t\tconst currentParam = argumentsToArray(params);\n\t\t\t\t\tconst arg = that.excuteObjs[i].arg;\n\n\t\t\t\t\tif (arg && (arg.length === currentParam.length)) {\n\t\t\t\t\t\tlet paramMatch = true;\n\t\t\t\t\t\tfor (let j = 0, l = arg.length; j < l; j++) {\n\t\t\t\t\t\t\tif (arg[j] !== currentParam[j] && arg[j] !== '_js_mock_anything_param') {\n\t\t\t\t\t\t\t\tparamMatch = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (paramMatch) {\n\t\t\t\t\t\t\treturn that.excuteObjs[i].excute;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\twith_param(...params) {\n\t\tconst arg = argumentsToArray(params);\n\t\tthis.currentParam = JSON.stringify(arg);\n\t\tthis.excuteObjs[this.currentParam] = { arg };\n\t\treturn this;\n\t}\n\n\tand_template(type, excute) {\n\t\tthis.excuteObjs[this.currentParam].type = type;\n\t\tthis.excuteObjs[this.currentParam].excute = excute;\n\t\tthis.currentParam = JSON.stringify([]);\n\t}\n\n\tand_return(returnVal) {\n\t\tthis.and_template('return', returnVal);\n\t}\n\n\tand_function(returnFunction) {\n\t\tthis.and_template('function', returnFunction);\n\t}\n\n\tand_throw(returnException) {\n\t\tthis.and_template('exception', returnException);\n\t}\n\n}\n\nexport default MockMethod;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmockMethod.js\n **/","import MockMethod from './jsmockMethod';\n\nconst MockMethodFactory = {\n\tstorage: [\n\t\t//      {\n\t\t//          current_obj : {}, object\n\t\t//          current_functions : {} mock method\n\t\t//      }\n\t],\n\tcreateData(obj) {\n\t\tconst dataObj = { current_obj: obj };\n\t\tthis.storage.push(dataObj);\n\n\t\treturn dataObj;\n\t},\n\tcreateMethod(obj, methodName) {\n\t\tconst dataObj = this.getData(obj);\n\t\tdataObj[methodName] = new MockMethod(obj, methodName);\n\n\t\treturn dataObj[methodName];\n\t},\n\tgetData(obj) {\n\t\tfor (let i = 0, l = this.storage.length; i < l; i++) {\n\t\t\tif (this.storage[i].current_obj === obj) {\n\t\t\t\treturn this.storage[i];\n\t\t\t}\n\t\t}\n\t\treturn this.createData(obj);\n\t},\n\tgetMethod(obj, methodName) {\n\t\tconst dataObj = this.getData(obj);\n\t\tif (!dataObj[methodName]) {\n\t\t\tdataObj[methodName] = this.createMethod(obj, methodName);\n\t\t}\n\t\treturn dataObj[methodName];\n\t},\n};\n\nexport default MockMethodFactory;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mock/jsmockMethodFactory.js\n **/","import StubMethod from './jsstubMethod';\r\nimport TestDouble from '../testDouble';\r\n\r\nconst global = window;\r\n\r\nfunction warn(msg) {\r\n\tif (global.console && console.warn) {\r\n\t\tconsole.warn(msg);\r\n\t}\r\n}\r\n\r\nclass Stub extends TestDouble {\r\n\tconstructor(name, type = 'object') {\r\n\t\tsuper(name, type);\r\n\t\tthis.type = 'Stub';\r\n\t\twarn('[WARN] : Deprecated Stub. You should be change to Mock.');\r\n\t}\r\n\tshould_receive(functionName) {\r\n\t\tthis.getTestDouble()[functionName] = () => {\r\n\t\t\tif (this.returnValue !== '_js_stub_none') {\r\n\t\t\t\treturn this.returnValue;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn new StubMethod(this);\r\n\t}\r\n}\r\n\r\nfunction stubWrap(name, type) {\r\n\tif (this instanceof Stub) {\r\n\t\tthis.createTestDouble(name, type);\r\n\t} else {\r\n\t\treturn new Stub(name, type);\r\n\t}\r\n}\r\n\r\nstubWrap.OBJECT = 'object';\r\nstubWrap.INSTANCE = 'instance';\r\n\r\nexport default stubWrap;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stub/jsstub.js\n **/","class StubMethod {\n\tconstructor(stub) {\n\t\tthis.stub = stub;\n\t}\n\n\tand_return(returnValue) {\n\t\tthis.stub.returnValue = returnValue;\n\t}\n}\n\nexport default StubMethod;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stub/jsstubMethod.js\n **/","/*!\n * QUnit 2.0.0-rc1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-19T16:15Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar autorun = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\tdelete a[ prop ];\n\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn't support IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"2.0.0-rc1\";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\tconsole.warn(\n\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tmoduleFns = {\n\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\tafter: setHook( module, \"after\" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\ttestsRun: 0\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\tparentModule.childModule = module;\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing( test ) {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\ttest.semaphore = 0;\n\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\tresumeProcessing( test );\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing( test ) {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tvar current = test || config.current;\n\t\t\tif ( current && current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tautorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar unitSampler,\n\tfocused = false,\n\tpriorityCount = 0;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\tthis.expected = null;\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.before;\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\tdelete this.module.testEnvironment.after;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tinternalStop( this );\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tinternalStart( this );\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t}\n\n\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\tnotifyTestsRan( this.module );\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack\n\t\t} );\n\n\t\tinternalReset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tpreserveTestEnvironment: function() {\n\t\tif ( this.preserveEnvironment ) {\n\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t}\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"before\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tinternalStop( test );\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { internalStart( test ); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tinternalStart( test );\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the fixture DOM element if available.\nfunction internalReset() {\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n}\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, callback ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, callback ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction internalStop( test ) {\n\n\t// If a test is running, adjust its semaphore\n\ttest.semaphore += 1;\n\n\tpauseProcessing( test );\n}\n\nfunction internalStart( test ) {\n\n\t// If a test is running, adjust its semaphore\n\ttest.semaphore -= 1;\n\n\t// If semaphore is non-numeric, throw error\n\tif ( isNaN( test.semaphore ) ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Invalid value on test.semaphore\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Don't start until equal number of stop-calls\n\tif ( test.semaphore > 0 ) {\n\t\treturn;\n\t}\n\n\t// Throw an Error if start is called more often than stop\n\tif ( test.semaphore < 0 ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\tresumeProcessing( test );\n}\n\nfunction numberOfTests( module ) {\n\tvar count = module.tests.length;\n\twhile ( module = module.childModule ) {\n\t\tcount += module.tests.length;\n\t}\n\treturn count;\n}\n\nfunction notifyTestsRan( module ) {\n\tmodule.testsRun++;\n\twhile ( module = module.parentModule ) {\n\t\tmodule.testsRun++;\n\t}\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing( test );\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\tif ( message == null ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === \"object\" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === \"object\" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\t\t\"date\": useStrictEquality,\n\n\t\t\"nan\": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We're done when there's nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"(\";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\n\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: \"  \",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\nfunction applyDeprecated( name ) {\n\treturn function() {\n\t\tthrow new Error(\n\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n}\n\nObject.keys( Assert.prototype ).forEach( function( key ) {\n\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n} );\n\nQUnit.asyncTest = function() {\n\tthrow new Error(\n\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.stop = function() {\n\tthrow new Error(\n\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.reset = function() {\n\tthrow new Error(\n\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nif ( defined.document ) {\n\t[\n\t\t\"test\",\n\t\t\"module\",\n\t\t\"expect\",\n\t\t\"start\",\n\t\t\"ok\",\n\t\t\"notOk\",\n\t\t\"equal\",\n\t\t\"notEqual\",\n\t\t\"propEqual\",\n\t\t\"notPropEqual\",\n\t\t\"deepEqual\",\n\t\t\"notDeepEqual\",\n\t\t\"strictEqual\",\n\t\t\"notStrictEqual\",\n\t\t\"throws\",\n\t\t\"raises\"\n\t].forEach( function( key ) {\n\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t} );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== \"undefined\" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: \"hidepassed\",\n\t\tlabel: \"Hide passed tests\",\n\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"noglobals\",\n\t\tlabel: \"Check for Globals\",\n\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"notrycatch\",\n\t\tlabel: \"No try-catch\",\n\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== \"string\" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don't load the HTML Reporter on non-browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nQUnit.init = function() {\n\tthrow new Error(\n\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n// Escape text for attribute or text content.\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t} );\n}\n\nfunction addEvent( elem, type, fn ) {\n\telem.addEventListener( type, fn, false );\n}\n\nfunction removeEvent( elem, type, fn ) {\n\telem.removeEventListener( type, fn, false );\n}\n\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = \"?\",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar i,\n\t\tselectedModules = [],\n\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\tif ( modulesList[ i ].checked ) {\n\t\t\tselectedModules.push( modulesList[ i ].getAttribute( \"module-id\" ) );\n\t\t}\n\t}\n\n\twindow.location = setUrl( {\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\n\t\t// Remove module and testId filter\n\t\tmodule: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction moduleDropDownHtml () {\n\tvar i,\n\t\tdropDownHtml = \"\";\n\n\tif ( !config.modules.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\tdropDownHtml += \"<li><label><input type='checkbox' \" +\n\t\t\t\"module-id='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t( config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1 ? \" checked\" : \"\" ) +\n\t\t\t\">\" + escapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t}\n\t}\n\treturn dropDownHtml;\n}\n\nfunction toolbarModuleFilter () {\n\tvar dropDownHtml = moduleDropDownHtml(),\n\t\ttoolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterComponent = document.createElement( \"div\" ),\n\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\tdropDownContainer = document.createElement( \"div\" ),\n\t\tdropDownList = document.createElement( \"ul\" ),\n\t\tclearFilter = document.createElement( \"span\" );\n\n\tif ( !toolbar || !dropDownHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleSearch.placeholder = \"Select modules\";\n\n\tlabel.innerHTML = \"Module: \";\n\n\tclearFilter.id = \"clear-module-filter\";\n\tclearFilter.innerHTML = \"<span id='clear-module-filter-text'>All modules</span><hr/>\";\n\n\tclearFilter.onclick = function() {\n\t\tvar i,\n\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" );\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\tmodulesList[ i ].checked = false;\n\t\t}\n\t\tapplyUrlParams();\n\t};\n\n\tmoduleFilter.id = \"qunit-modulefilter-container\";\n\tmoduleFilterComponent.id = \"qunit-modulefilter-component\";\n\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\tdropDownContainer.id = \"qunit-modulefilter-dropdown-container\";\n\n\tdropDownContainer.style.display = \"none\";\n\n\tdropDownContainer.appendChild( clearFilter );\n\tmoduleFilter.appendChild( label );\n\tmoduleFilter.appendChild( moduleFilterComponent );\n\tmoduleFilterComponent.appendChild( moduleSearch );\n\tmoduleFilterComponent.appendChild( dropDownContainer ) ;\n\n\t// Enables show/hide for the dropdown\n\taddEvent( moduleSearch, \"focus\", function() {\n\t\tvar dropDownList = id( \"qunit-modulefilter-dropdown-container\" );\n\t\tif ( dropDownList.style.display === \"none\" ) {\n\t\t\taddEvent( document, \"click\", function hideHandler( e )  {\n\t\t\t\tif ( !id( \"qunit-modulefilter-container\" ).contains( e.target ) ) {\n\t\t\t\t\tid( \"qunit-modulefilter-dropdown-container\" ).style.display = \"none\";\n\t\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tdropDownList.style.display = \"block\";\n\t\t}\n\t} );\n\n\t// Enables search to the module filter\n\taddEvent( moduleSearch, \"input\", function() {\n\t\tvar i,\n\t\tmoduleText,\n\t\tsearchText = this.value.toLowerCase(),\n\t\tlistItems = id( \"qunit-modulefilter-dropdown-list\" ).children;\n\n\t\tif ( !searchText ) {\n\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\t\tmoduleText = listItems[ i ].textContent.toLowerCase();\n\t\t\t\tif ( moduleText.indexOf( searchText ) > -1 ) {\n\t\t\t\t\tlistItems[ i ].style.display = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tlistItems[ i ].style.display = \"none\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\tdropDownList.innerHTML = dropDownHtml;\n\tdropDownContainer.appendChild( dropDownList );\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t\"'>Run all tests</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( \"qunit-tests\" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, \"hidepass\" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// The pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\tescapeText( expected ) +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t} else {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\" serialization</td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t} );\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === \"complete\" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qunitjs/qunit/qunit.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * @author mixed\n */\n\n import { mock } from '../src/jsmocktool';\n import { module, test } from '../node_modules/qunitjs/qunit/qunit';\n\n var global = window;\n\n module('jsmock - Object type', {\n   'beforeEach': function () {\n     this.mock = mock('RECEIVE');\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     RECEIVE = undefined;\n   },\n });\n\n test('Must be first prameter is string or object', function (assert) {\n    // Given\n    // When\n   mock('FOO');\n    // Then\n   assert.deepEqual(FOO, {});\n\n    // Given\n   var BAR = {};\n    // When\n   mock(BAR);\n    // Then\n   assert.deepEqual(BAR, BAR);\n });\n\n test(\"Must be second parameter is 'instance','object',none.\", function (assert) {\n    // Given\n    // When\n   mock('FOO2');\n    // Then\n   assert.deepEqual(FOO2, {});\n\n    // Given\n    // When\n   mock('FOO3', mock.INSTANCE);\n    // Then\n   assert.equal(FOO3.constructor, Function);\n });\n\n test('The should_receive is set method of mock Object.', function (assert) {\n    // Given\n   var receiveMock = mock('RECEIVE');\n    // Then\n   receiveMock.should_receive('test');\n    // When\n   assert.equal(RECEIVE.test.constructor, Function);\n\n    // Given\n   var receiveMock2 = mock('RECEIVE2', mock.INSTANCE);\n    // Then\n   receiveMock2.should_receive('test');\n    // When\n   assert.equal(RECEIVE2.prototype.test.constructor, Function);\n });\n\n test('Return value of should_receive is MockMethod.', function (assert) {\n    // Given\n   var receive = mock('RECEIVE3');\n    // When\n   var mock_method = receive.should_receive('test');\n    // The MockMethod is private. so I can't test.\n    // Instead, I made a Ducktyping test(?).\n    // I believe correct when The return value of should_receive have and_return function.\n    // ok(stub_obj instanceof MockMethod);\n    // Then\n   assert.equal(mock_method.and_return.constructor, Function);\n });\n\n test('The and_return is  setting value to return.', function (assert) {\n    // Given\n   mock('RECEIVE4').should_receive('test').and_return(3);\n    // When\n   var returnVal = RECEIVE4.test();\n    // Then\n   assert.equal(returnVal, 3);\n });\n\n test('If use with_param, mock will return value when same param.', function (assert) {\n    // Given\n   mock('RECEIVE4').should_receive('test').with_param(1, 2).and_return(4);\n    // When\n   var returnVal = RECEIVE4.test(1, 2);\n    // Then\n   assert.equal(returnVal, 4);\n });\n\n test('The Mock must be work mock before set parameter when add new parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').and_return(3);\n   this.mock.should_receive('test').with_param(1, 2).and_return(4);\n   this.mock.should_receive('test').with_param(1, 2, 3).and_return(5);\n    // When\n   var noneParam = RECEIVE.test();\n   var oneParam = RECEIVE.test(1, 2);\n   var twoParam = RECEIVE.test(1, 2, 3);\n    // Then\n   assert.equal(noneParam, 3);\n   assert.equal(oneParam, 4);\n   assert.equal(twoParam, 5);\n });\n\n test('The Mock must be change return value when add same parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').and_return(3);\n   this.mock.should_receive('test').with_param(1, 2).and_return(4);\n   this.mock.should_receive('test').with_param(1, 2).and_return(5);\n    // When\n   var noneParam = RECEIVE.test();\n   var twoParam = RECEIVE.test(1, 2);\n    // Then\n   assert.equal(noneParam, 3);\n   assert.equal(twoParam, 5);\n });\n\n test('The add_throw is throw exception when match param.', function (assert) {\n    // Given\n   var error_message = '';\n   this.mock.should_receive('test2').and_throw(new Error('and_throw test.'));\n    // When\n   try {\n     RECEIVE.test2();\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test.');\n });\n\n test('If set with_param of and_throw then throw exception when match parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2.'));\n   var error_message = '';\n\n    // When\n   try {\n     RECEIVE.test2(1, 2);\n   } catch (e) {\n     error_message = e.message;\n   }\n\n    // Then\n   assert.equal(error_message, 'and_throw test2.');\n });\n\n test('The and_throw is well work when change parameter', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param().and_throw(new Error('and_throw test'));\n   this.mock.should_receive('test2').with_param(1, 2).and_throw(new Error('and_throw test2'));\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test3'));\n   var error_message = '';\n\n    // When\n   try {\n     RECEIVE.test2();\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test');\n\n    // When\n   try {\n     RECEIVE.test2(1, 2);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test2');\n\n    // When\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test3');\n });\n test('The and_throw throw new exception when some function, same parameter, change exception.', function (assert) {\n    // Given\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('and_throw test'));\n   var error_message = '';\n    // When\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // Then\n   assert.equal(error_message, 'and_throw test');\n\n    // Then\n   this.mock.should_receive('test2').with_param(1, 2, 3).and_throw(new Error('change throw'));\n   try {\n     RECEIVE.test2(1, 2, 3);\n   } catch (e) {\n     error_message = e.message;\n   }\n    // When\n   assert.equal(error_message, 'change throw');\n });\n\n test('The and_function run function when set new function', function (assert) {\n\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').and_function(() => {\n     that.mock_test1 = 'first';\n   });\n    // Then\n   RECEIVE.test3();\n    // When\n   assert.equal(that.mock_test1, 'first');\n });\n\n test('If set a with_param then the and_functon run function when only match parameter.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param(1, 2).and_function(() => {\n     that.mock_test2 = 'second';\n   });\n    // Then\n   RECEIVE.test3(1, 2);\n    // When\n   assert.equal(that.mock_test2, 'second');\n });\n\n test('Then and_function is well work when same function change parameter.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param().and_function(() => {\n     that.mock_test1 = 'first';\n   });\n   this.mock.should_receive('test3').with_param(1, 2).and_function(() => {\n     that.mock_test2 = 'second';\n   });\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'third';\n   });\n    // When\n   RECEIVE.test3();\n    // Then\n   assert.equal(that.mock_test1, 'first');\n\n    // When\n   RECEIVE.test3(1, 2);\n    // Then\n   assert.equal(that.mock_test2, 'second');\n\n    // When\n   RECEIVE.test3(1, 2, 3);\n    // Then\n   assert.equal(that.mock_test3, 'third');\n });\n test('The and_function run new function when some function, same parameter, change and_function.', function (assert) {\n    // Given\n   var that = this;\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'third';\n   });\n   this.mock.should_receive('test3').with_param(1, 2, 3).and_function(() => {\n     that.mock_test3 = 'change third';\n   });\n    // When\n   RECEIVE.test3(1, 2, 3);\n    // Then\n   assert.equal(that.mock_test3, 'change third');\n });\n test('If use Mock.anything when run function without reference to parameter.', function (assert) {\n    // Given\n   this.mock.should_receive('test').with_param(1, 2).and_return('1');\n   this.mock.should_receive('test').with_param(1, 2, mock.anything()).and_return('2');\n   this.mock.should_receive('test').with_param(1, 2, mock.anything(), mock.anything()).and_return('3');\n\n    // When, Then\n   assert.equal(RECEIVE.test(1, 2), '1');\n   assert.equal(RECEIVE.test(1, 2, 3), '2');\n   assert.equal(RECEIVE.test(1, 2, 1), '2');\n   assert.equal(RECEIVE.test(1, 2, 4), '2');\n   assert.equal(RECEIVE.test(1, 2, 4, 5), '3');\n   assert.equal(RECEIVE.test(1, 2, 4, 6), '3');\n });\n\n  //    'param에 anything이 들어간 파라메터에서 다시 설정한 경우에 다시 설정한 값으로 반환 해야 한다.':function(){\n  //      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"5\");\n  //      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"5\");\n\n  //      mock(\"Foo\").should_receive(\"test\").with_param(\"5\",\"6\",Mock.anything()).and_return(\"6\");\n  //      value_of(Foo.test(\"5\",\"6\",\"3\")).should_be(\"6\");\n\n  //    },\n\n module('jsmock - other type', {\n   'beforeEach': function () {\n\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     global.MockInstance = undefined;\n   },\n });\n\n test('The instance type is well work too.', function (assert) {\n    // Given\n   var that = this;\n   var receive = mock('MockInstance', mock.INSTANCE);\n   receive.should_receive('test').with_param(1).and_return('1');\n   receive.should_receive('test').with_param(2).and_throw(new Error('test'));\n   receive.should_receive('test').with_param(3).and_function(() => {\n     that.mock_test1 = 'test';\n   });\n   var errormessage = '';\n\n    // When\n   var mockInstance = new MockInstance();\n    // Then\n   assert.equal(mockInstance.test(1), '1');\n\n    // When\n   try {\n     mockInstance.test(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, 'test');\n\n    // When\n   mockInstance.test(3);\n    // Then\n   assert.equal(that.mock_test1, 'test');\n });\n\n test('The normal functon is well work too.', function (assert) {\n    // Given\n   var that = this;\n   var receive = mock(global);\n   receive.should_receive('commonfunc').with_param(1).and_return('1');\n   receive.should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n   receive.should_receive('commonfunc').with_param(3).and_function(() => {\n     that.mock_test1 = 'commonfunc';\n   });\n   var errormessage = '';\n\n    // When\n   var returnVal = commonfunc(1);\n    // Then\n   assert.equal(returnVal, '1');\n\n\n    // When\n   try {\n     commonfunc(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, 'test2');\n\n    // When\n   commonfunc(3);\n    // Then\n   assert.equal(that.mock_test1, 'commonfunc');\n });\n\n test('The namespace type is well work too.', function (assert) {\n    // Given\n   mock('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\n    // Given\n   mock('aaaa.bbbb.cccc', mock.INSTANCE).should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\n    // Given\n   global['aaaaa'] = {};\n   aaaaa.bbbbb = {};\n   mock('aaaaa.bbbbb').should_receive('test').and_return('test');\n    // When, Then\n   assert.equal(aaaaa.bbbbb.test(), 'test');\n\n    // Given\n   mock('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n    // When,Then\n   assert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n });\n\n test('The with_param well work when use namespace.', function (assert) {\n    // Given\n   var that = this;\n   mock('param.test').should_receive('commonfunc').with_param(1).and_return('1');\n   mock('param.test').should_receive('commonfunc').with_param(2).and_throw(new Error('test2'));\n   mock('param.test').should_receive('commonfunc').with_param(3).and_function(() => {\n     that.mock_test1 = 'commonfunc';\n   });\n\n    // When, Then\n   assert.equal(param.test.commonfunc(1), '1');\n\n    // Given\n   var errormessage = '';\n   try {\n     param.test.commonfunc(2);\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // When, Then\n   assert.equal(errormessage, 'test2');\n\n    // When\n   param.test.commonfunc(3);\n    // Then\n   assert.equal(that.mock_test1, 'commonfunc');\n });\n\n module('jsmock - verify', {\n   'beforeEach': function () {\n     this.mock = mock('Verify');\n     this.mock_test1 = '';\n     this.mock_test2 = '';\n     this.mock_test3 = '';\n   },\n   'afterEach': function () {\n     this.mock = undefined;\n     Verify = undefined;\n   },\n });\n\n test('The verify is well work.', function (assert) {\n    // Given\n   this.mock.should_receive('kall').with_param(1, 2).and_return('1');\n   this.mock.should_receive('kall2').and_return('1');\n   Verify.kall(1, 2);\n   var errormessage = '';\n    // When\n   var result = this.mock.verify('kall');\n    // Then\n   assert.deepEqual(result, { 'total': 1, 'param': { '[1,2]': 1 } });\n\n    // When\n   try {\n     mock('Verify').verify('kall2');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall2 isn't called.\");\n\n    // When\n   try {\n     mock('Verify').verify('kall3');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall3 isn't method.\");\n });\n test('The verify_all is check all method.', function (assert) {\n\n    // Given\n   mock('Verify2').should_receive('kall').with_param(1, 2).and_return('1');\n   mock('Verify2').should_receive('kall2').and_return('1');\n   Verify2.kall(1, 2);\n   Verify2.kall2();\n   var returnVal;\n    // When\n   returnVal = mock('Verify2').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\n\n    // Given\n   mock('Verify3').should_receive('kall').with_param(1, 2).and_return('1');\n   var errormessage;\n    // When\n   try {\n     mock('Verify3').verify_all();\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n test('The reset is remove info of function call.', function (assert) {\n    // Given\n   mock('Verify4').should_receive('kall').with_param(1, 2).and_return('1');\n   Verify4.kall(1, 2);\n    // When\n   var returnVal = mock('Verify4').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } } });\n\n    // Given\n   var errormessage;\n    // When\n   mock('Verify4').reset('kall');\n   try {\n     mock('Verify4').verify('kall');\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n\n test('The reset_all is remove all info of function call.', function (assert) {\n    // Given\n   mock('Verify5').should_receive('kall').with_param(1, 2).and_return('1');\n   mock('Verify5').should_receive('kall2').and_return('1');\n   Verify5.kall(1, 2);\n   Verify5.kall2();\n    // When\n   var returnVal = mock('Verify5').verify_all();\n    // Then\n   assert.deepEqual(returnVal, { 'kall': { 'total': 1, 'param': { '[1,2]': 1 } }, 'kall2': { 'total': 1, 'param': { '[]': 1 } } });\n\n    // Given\n   var errormessage;\n    // When\n   mock('Verify5').reset_all();\n   try {\n     mock('Verify5').verify_all();\n   } catch (e) {\n     errormessage = e.message;\n   }\n    // Then\n   assert.equal(errormessage, \"kall isn't called.\");\n });\n\n module('jsmock - Support Class');\n\n test('Add method to Class', function (assert) {\n    // Given\n   class Test {\n\n    }\n\n    // When\n   mock(Test, mock.INSTANCE).should_receive('kall').and_return('1');\n\n    // Then\n   let test = new Test();\n   assert.equal(test.kall(), '1');\n });\n\n test('Add method to Class instance', function (assert) {\n    // Given\n   class Test {\n\n    }\n   let test = new Test();\n\n    // When\n   mock(test).should_receive('kall').and_return('1');\n\n    // Then\n   assert.equal(test.kall(), '1');\n });\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/jsmock.js\n **/","/**\n * @author mixed\n */\n\nimport { stub } from '../src/jsmocktool';\nimport { module, test } from '../node_modules/qunitjs/qunit/qunit';\n\nvar global = window;\n\nmodule('jsstub', {\n\t'beforeEach': function () {\n\t\t\n\t\tthis.originConsole = global.console;\n\t\tglobal.console = {\n\t\t\t'warn': function (msg) {\n\t\t\t},\n\t\t};\n\t\tthis.stub = stub('STUB');\n\t},\n\t'afterEach': function () {\n\t\tthis.stub = undefined;\n\t\tSTUB = undefined;\n\t\tglobal.console = this.originConsole;\n\t},\n});\n\ntest('The first parameter of stub is must be string,object.', function (assert) {\n\t// Given, When\n\tstub('FOO');\n\t// Then\n\tassert.deepEqual(FOO, {});\n\n\t// Given\n\tlet BAR = {};\n\t// When\n\tstub(BAR);\n\t// Then\n\t                                                                                                                                                                                                                                                assert.deepEqual(BAR, BAR);\n});\n\ntest('The Stub is only add function when already made object.', function (assert) {\n\t// Given\n\tlet Obj = { test: () => {} };\n\t// When\n\tstub('Obj');\n\t// Then\n\tassert.equal(Obj, Obj);\n\n\t// When\n\tstub(Obj);\n\t// Then\n                                                                                                                                                                                                                                        assert.equal(Obj, Obj);\n});\n\ntest(\"The second parameter of stub is must be none, 'instance' or 'object'\", function (assert) {\n\t// Given\n\t// When\n\tstub('FOO2');\n\t// Then\n\tassert.deepEqual(FOO2, {});\n\n\t// when\n\tstub('FOO3', stub.INSTANCE);\n\t// Then\n                                                                                                                                                                                                                                    assert.equal(FOO3.constructor, Function);\n});\n\ntest('The should_receive is set empty function', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test');\n\t// Then\n\tassert.equal(STUB.test.constructor, Function);\n\n\t// Given\n\t// When\n\tstub('STUB2', stub.INSTANCE).should_receive('test');\n\t// Then\n                                                                                                                                                                                                                                        assert.equal(STUB2.prototype.test.constructor, Function);\n});\n\ntest('The should_receive is change function when already function.', function (assert) {\n\t// Given\n\tlet funcObj = { test: () => false };\n\t// When\n\tstub('funcObj').should_receive('test');\n\t// Then\n                                                                                                                                                                                                                                    assert.equal(funcObj.test(), '');\n});\n\ntest('Return value of should_receive is StubMethod.', function (assert) {\n\t// Given\n\t// When\n\tlet stub_obj = this.stub.should_receive('test');\n\t// Then\n\t// The StubMethod is private. so I can't test.\n\t// Instead, I made a Ducktyping test(?).\n\t// I believe correct when The return value of should_receive have and_return function.\n\t// ok(stub_obj instanceof StubMethod);\n\tassert.equal(stub_obj.and_return.constructor, Function);\n});\n\ntest('The and_return is return value when and_return set value.', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(STUB.test(), 'test');\n});\n\ntest('The namespace type is well work too.', function (assert) {\n\t// Given\n\t// When\n\tthis.stub.should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(STUB.test(), 'test');\n\n\t// Given\n\t// When\n\tstub('aaa.bbb.ccc.ddd').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaa.bbb.ccc.ddd.test(), 'test');\n\n\t// Given\n\t// When\n\tstub('aaaa.bbbb.cccc', stub.INSTANCE).should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(new aaaa.bbbb.cccc().test(), 'test');\n\n\t// Given\n\tglobal['aaaaa'] = {};\n\taaaaa.bbbbb = {};\n\n\t// When\n\tstub('aaaaa.bbbbb').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaaaa.bbbbb.test(), 'test');\n\n\t// When\n\tstub('aaaaa.bbbbb.ccccc').should_receive('test').and_return('test');\n\t// Then\n\tassert.equal(aaaaa.bbbbb.ccccc.test(), 'test');\n});\n\n\ntest('deprecated stub.', function (assert) {\n\t// Given\n\tlet message = '';\n\tglobal.console = {\n\t\t'warn': function (msg) {\n\t\t\tmessage = msg;\n\t\t},\n\t};\n\t// When\n\tstub('FOO');\n\n\t// Then\n\tassert.equal(message, '[WARN] : Deprecated Stub. You should be change to Mock.');\n});\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/jsstub.js\n **/","import { start } from '../node_modules/qunitjs/qunit/qunit';\nstart();\n\n\n\n/** WEBPACK FOOTER **\n ** ./test/start.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 13\n ** module chunks = 0\n **/"],"sourceRoot":""}